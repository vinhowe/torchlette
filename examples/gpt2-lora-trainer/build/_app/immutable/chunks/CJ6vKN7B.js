import{g as z}from"./CNEoBiV9.js";const k={relu:(t,e="0.0")=>`select(${e}, ${t}, ${t} > ${e})`,gelu:t=>`(${t} * 0.5 * (1.0 + tanh(clamp(0.7978845608 * (${t} + 0.044715 * ${t} * ${t} * ${t}), -10.0, 10.0))))`,gelu_tanh:t=>`(${t} * 0.5 * (1.0 + tanh(clamp(0.7978845608 * (${t} + 0.044715 * ${t} * ${t} * ${t}), -10.0, 10.0))))`,gelu_erf:t=>`(${t} * 0.5 * (1.0 + sign(${t}) * (1.0 - (((((1.061405429 * (1.0 / (1.0 + 0.3275911 * abs(${t} * 0.7071067811865476))) + -1.453152027) * (1.0 / (1.0 + 0.3275911 * abs(${t} * 0.7071067811865476))) + 1.421413741) * (1.0 / (1.0 + 0.3275911 * abs(${t} * 0.7071067811865476))) + -0.284496736) * (1.0 / (1.0 + 0.3275911 * abs(${t} * 0.7071067811865476))) + 0.254829592) * (1.0 / (1.0 + 0.3275911 * abs(${t} * 0.7071067811865476))) * exp(-${t} * ${t} * 0.5)))))`,silu:t=>`(${t} / (1.0 + exp(-${t})))`,sigmoid:t=>`(1.0 / (1.0 + exp(-${t})))`,tanh:t=>`tanh(${t})`,softplus:t=>`log(1.0 + exp(${t}))`,neg:t=>`(-${t})`,abs:t=>`abs(${t})`,exp:t=>`exp(${t})`,log:t=>`log(${t})`,sqrt:t=>`sqrt(${t})`,rsqrt:t=>`inverseSqrt(${t})`,sin:t=>`sin(${t})`,cos:t=>`cos(${t})`,floor:t=>`floor(${t})`,ceil:t=>`ceil(${t})`,round:t=>`round(${t})`,sign:t=>`sign(${t})`,cast_f16:t=>`f16(${t})`,cast_f32:t=>`f32(${t})`,cast_i32:t=>`i32(${t})`,cast_u32:t=>`u32(${t})`},j={add:(t,e)=>`(${t} + ${e})`,sub:(t,e)=>`(${t} - ${e})`,mul:(t,e)=>`(${t} * ${e})`,div:(t,e)=>`(${t} / ${e})`,pow:(t,e)=>`pow(${t}, ${e})`,min:(t,e)=>`min(${t}, ${e})`,max:(t,e)=>`max(${t}, ${e})`,mod:(t,e)=>`(${t} % ${e})`,eq:(t,e)=>`select(0.0, 1.0, ${t} == ${e})`,ne:(t,e)=>`select(0.0, 1.0, ${t} != ${e})`,lt:(t,e)=>`select(0.0, 1.0, ${t} < ${e})`,le:(t,e)=>`select(0.0, 1.0, ${t} <= ${e})`,gt:(t,e)=>`select(0.0, 1.0, ${t} > ${e})`,ge:(t,e)=>`select(0.0, 1.0, ${t} >= ${e})`};function R(t,e){if(e!=="f32"&&e!=="f16"||t.length===0)return 1;const r=t[t.length-1];return t.reduce((n,s)=>n*s,1)<16?1:r>=4&&r%4===0?4:r>=2&&r%2===0?2:1}function D(t,e,r){if(r===1)return!0;if(t.length===0)return!1;const n=t[t.length-1];if(n%r!==0)return!1;for(const s of e){if(s.shape.reduce((i,f)=>i*f,1)===1)continue;if(s.shape.length===0)return!1;const a=s.shape[s.shape.length-1];if(a!==n&&a!==1||a===n&&a%r!==0)return!1}return!0}function E(t,e){return e===1?w(t):`vec${e}<${w(t)}>`}function A(t,e,r,n){if(t.length===e.length&&t.every((o,l)=>o===e[l]))return`let ${n} = ${r};`;if(e.reduce((o,l)=>o*l,1)===1)return`let ${n} = 0u;`;const s=[],a=t.length,i=e.length,f=a-i;s.push(`var _tmp_${n} = ${r};`);const $=[];for(let o=a-1;o>=0;o--){const l=`_c${o}_${n}`,h=t[o];s.push(`let ${l} = _tmp_${n} % ${h}u;`),s.push(`_tmp_${n} = _tmp_${n} / ${h}u;`),$.unshift(l)}const u=[];for(let o=0;o<i;o++){const l=o+f,h=e[o],_=$[l];h===1?u.push("0u"):u.push(_)}let d=u[0];for(let o=1;o<i;o++)e.slice(o+1).reduce((l,h)=>l*h,1),d=`(${d} * ${e[o]}u + ${u[o]})`;return i===1&&(d=u[0]),s.push(`let ${n} = ${d};`),s.join(`
  `)}function O(t,e){return t.length!==e.length?!0:!t.every((r,n)=>r===e[n])}function F(t,e=1){const r=new Map,n=[],s=e===1?"0.0":`vec${e}<f32>(0.0)`,a=e===1?"1.0":`vec${e}<f32>(1.0)`,i=new Map;for(const $ of t.nodes)for(const u of $.inputs)i.set(u,(i.get(u)??0)+1);for(let $=0;$<t.nodes.length;$++){const u=t.nodes[$],d=`t${u.id}`,o=[];for(const m of u.inputs)if(m<0){const y=-m-1;o.push(`v${y}`)}else{const y=r.get(m);if(!y)throw new Error(`Missing variable for node ${m}`);o.push(y)}let l;if(u.op in k)l=k[u.op](o[0],s,a);else if(u.op in j)l=j[u.op](o[0],o[1]);else if(u.op.startsWith("cast_")&&u.op in k)l=k[u.op](o[0],s,a);else throw new Error(`Unknown fusible op: ${u.op}`);const h=u.isOutput??$===t.nodes.length-1,_=(i.get(u.id)??0)>1;h||_?(n.push(`let ${d} = ${l};`),r.set(u.id,d)):r.set(u.id,`(${l})`)}const f=t.nodes[t.nodes.length-1];return{lines:n,varNames:r,outputVar:r.get(f.id)??`t${f.id}`}}function K(t,e={}){const r=e.workgroupSize??t.workgroupSize??256,n=t.outputs[0].shape,s=t.outputs[0].dtype,a=n.reduce((c,g)=>c*g,1);let i=1;if(e.forceVectorWidth!==void 0)i=e.forceVectorWidth;else if(e.vectorize){const c=R(n,s);D(n,t.inputs,c)&&(i=c)}const f=Math.ceil(a/i),$=i>1,u=$?E(s,i):w(s),d=[];for(let c=0;c<t.inputs.length;c++){const g=t.inputs[c],b=w(g.dtype);d.push(`@group(0) @binding(${c}) var<storage, read> in${c}: array<${b}>;`)}const o=[];for(let c=0;c<t.outputs.length;c++){const g=t.outputs[c],b=t.inputs.length+c,v=w(g.dtype);o.push(`@group(0) @binding(${b}) var<storage, read_write> out${c}: array<${v}>;`)}const l=[];for(let c=0;c<t.inputs.length;c++){const g=t.inputs[c],b=g.shape.reduce((v,M)=>v*M,1)===1;$?b?l.push(`let v${c} = ${u}(in${c}[0]);`):O(n,g.shape)?l.push(G(n,g.shape,c,i,s)):l.push(q(c,i,s)):O(n,g.shape)?(l.push(A(n,g.shape,"idx",`idx${c}`)),l.push(`let v${c} = in${c}[idx${c}];`)):l.push(`let v${c} = in${c}[idx];`)}const{lines:h,varNames:_}=F(t,i),m=[];for(let c=0;c<t.outputs.length;c++){const g=t.outputs[c],b=_.get(g.nodeId)??`t${g.nodeId}`;$?m.push(...N(b,c,i)):m.push(`out${c}[idx] = ${b};`)}const y=m.join(`
  `),p=$?`gid.x * ${i}u`:"gid.x",x=$?`if (gid.x * ${i}u >= params.total_elements) { return; }`:"if (gid.x >= params.total_elements) { return; }",T=t.inputs.length+t.outputs.length,I=`
// Fused elementwise kernel: ${t.id}
// Ops: ${t.nodes.map(c=>c.op).join(" -> ")}
// Outputs: ${t.outputs.length}
// Vectorization: ${$?`vec${i}`:"scalar"}

${d.join(`
`)}
${o.join(`
`)}

struct Params {
  total_elements: u32,
}
@group(0) @binding(${T}) var<uniform> params: Params;

@compute @workgroup_size(${r})
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  ${x}
  let idx = ${p};

  // Load inputs${$?" (vectorized)":""}
  ${l.join(`
  `)}

  // Fused computation
  ${h.join(`
  `)}

  // Store outputs${$?" (vectorized)":""}
  ${y}
}
`.trim(),P=L(t,i);return{source:I,workgroupSize:r,inputBindings:t.inputs.length,cacheKey:P,vectorWidth:i,workItems:f}}function N(t,e,r){const n=[];for(let s=0;s<r;s++){const a=r===2?["x","y"][s]:["x","y","z","w"][s];n.push(`out${e}[idx + ${s}u] = ${t}.${a};`)}return n}function q(t,e,r){const n=E(r,e),s=[];for(let a=0;a<e;a++)s.push(`in${t}[idx + ${a}u]`);return`let v${t} = ${n}(${s.join(", ")});`}function G(t,e,r,n,s){const a=E(s,n),i=[],f=[];for(let $=0;$<n;$++){const u=`idx + ${$}u`,d=`bc${r}_${$}`;i.push(U(t,e,u,d)),f.push(`in${r}[${d}]`)}return i.push(`let v${r} = ${a}(${f.join(", ")});`),i.join(`
  `)}function U(t,e,r,n){if(e.reduce((o,l)=>o*l,1)===1)return`let ${n} = 0u;`;const s=t.length,a=e.length,i=s-a,f=[];f.push(`var _t_${n} = ${r};`);const $=[];for(let o=s-1;o>=0;o--){const l=`_c${o}_${n}`,h=t[o];f.push(`let ${l} = _t_${n} % ${h}u;`),f.push(`_t_${n} = _t_${n} / ${h}u;`),$.unshift(l)}const u=[];for(let o=0;o<a;o++){const l=o+i,h=e[o],_=$[l];u.push(h===1?"0u":_)}let d=u[0];for(let o=1;o<a;o++)d=`(${d} * ${e[o]}u + ${u[o]})`;return a===1&&(d=u[0]),f.push(`let ${n} = ${d};`),f.join(`
  `)}function w(t){switch(t){case"f32":return"f32";case"f16":return"f16";case"i32":return"i32";case"u32":return"u32";case"bool":return"u32";default:return"f32"}}function L(t,e=1){const r=[t.id,`vec:${e}`];for(const s of t.outputs)r.push(`out${s.index}:${s.shape.join("x")}:${s.dtype}`);for(const s of t.inputs)r.push(`in${s.index}:${s.shape.join("x")}:${s.dtype}`);const n=t.nodes.map(s=>`${s.op}:${s.id}`).join(",");return r.push(`ops:[${n}]`),r.join("|")}const C={COPY_SRC:4,COPY_DST:8,UNIFORM:64,STORAGE:128};var Y=class{cache=new Map;maxSize;constructor(t=256){this.maxSize=t}getOrCreate(t,e,r={}){const n=K(e,r),s=this.cache.get(n.cacheKey);if(s)return{pipeline:s.pipeline,kernel:n};const a=t.createShaderModule({code:n.source}),i=t.createComputePipeline({layout:"auto",compute:{module:a,entryPoint:"main"}});if(this.cache.size>=this.maxSize){let f=null,$=1/0;for(const[u,d]of this.cache)d.createdAt<$&&($=d.createdAt,f=u);f&&this.cache.delete(f)}return this.cache.set(n.cacheKey,{pipeline:i,kernel:n,createdAt:Date.now()}),{pipeline:i,kernel:n}}clear(){this.cache.clear()}stats(){return{size:this.cache.size,maxSize:this.maxSize}}};let B=null;function S(){return B||(B=new Y),B}function H(t,e,r,n={}){const{pipeline:s,kernel:a}=(n.cache??S()).getOrCreate(t,e,{vectorize:n.vectorize??!0});if(r.length!==e.inputs.length)throw new Error(`Expected ${e.inputs.length} inputs, got ${r.length}`);const i=e.outputs[0],f=i.shape.reduce((p,x)=>p*x,1),$=p=>{z.trackAllocation(null,p.size);try{const x=t.createBuffer(p);return z.trackDeallocation(null),z.trackAllocation(x,p.size),x}catch(x){throw z.trackDeallocation(null),x}},u=[],d=[];for(const p of e.outputs){const x=$({size:f*X(p.dtype),usage:C.STORAGE|C.COPY_SRC});u.push(x),d.push({buffer:x,shape:p.shape.slice(),dtype:p.dtype})}const o=$({size:4,usage:C.UNIFORM|C.COPY_DST});t.queue.writeBuffer(o,0,new Uint32Array([f]));const l=[];for(let p=0;p<r.length;p++)l.push({binding:p,resource:{buffer:r[p].buffer}});for(let p=0;p<u.length;p++)l.push({binding:r.length+p,resource:{buffer:u[p]}});l.push({binding:r.length+e.outputs.length,resource:{buffer:o}});const h=t.createBindGroup({layout:s.getBindGroupLayout(0),entries:l}),_=t.createCommandEncoder(),m=_.beginComputePass();m.setPipeline(s),m.setBindGroup(0,h);const y=Math.ceil(a.workItems/a.workgroupSize);return m.dispatchWorkgroups(y),m.end(),t.queue.submit([_.finish()]),{outputs:d,buffer:u[0],shape:i.shape.slice(),dtype:i.dtype}}function X(t){switch(t){case"f32":case"i32":case"u32":return 4;case"f16":return 2;case"bool":return 1;default:return 4}}export{H as dispatchFusedKernel};
