import{f as ue,a as Y,c as Yt,t as Ve,d as Ri}from"./Dnu1u84q.js";import{i as ln}from"./CePjyyUQ.js";import{I as ur,h as $e,N as Pi,a as lr,D as Fi,v as Li,l as S,aq as Ni,F as qi,H as Gi,G as Es,J as dr,e as qt,Y as Ui,al as Oi,a3 as Is,c as ut,b as Pr,s as Vi,aj as ws,aI as ji,W as Fr,aB as Wi,aJ as Hi,aK as Ki,aL as Yi,aM as Oe,aN as dn,r as cn,p as hn,aO as cr,M as pn,af as Qi,aP as Zi,ai as Xi,d as Ji,aQ as ea,aR as ta,aS as ra,aT as sa,aU as na,aV as ia,aD as aa,i as oa,L as ua,aW as la,as as C,aC as ne,ar as ys,aE as Ct,y as bt,C as F,w as I,A as ye,B as vt,x as E,a4 as rt,z as mt}from"./Dg8bTafm.js";import{d as _t,e as Vt,s as le}from"./Bhr74y56.js";import{_ as Ft,b as fn,i as ce}from"./BxLj5Vw_.js";import{o as da}from"./NCSuz3cp.js";function mn(e,t){return t}function ca(e,t,r){for(var s=[],n=t.length,i,a=t.length,o=0;o<n;o++){let c=t[o];hn(c,()=>{if(i){if(i.pending.delete(c),i.done.add(c),i.pending.size===0){var h=e.outrogroups;Lr(ws(i.done)),h.delete(i),h.size===0&&(e.outrogroups=null)}}else a-=1},!1)}if(a===0){var u=s.length===0&&r!==null;if(u){var l=r,d=l.parentNode;Xi(d),d.append(l),e.items.clear()}Lr(t,!u)}else i={pending:new Set(t),done:new Set},(e.outrogroups??=new Set).add(i)}function Lr(e,t=!0){for(var r=0;r<e.length;r++)Ji(e[r],t)}var $s;function gn(e,t,r,s,n,i=null){var a=e,o=new Map,u=(t&dn)!==0;if(u){var l=e;a=$e?ur(Pi(l)):l.appendChild(lr())}$e&&Fi();var d=null,c=Ni(()=>{var g=r();return ji(g)?g:g==null?[]:ws(g)}),h,f=!0;function w(){p.fallback=d,ha(p,h,a,t,s),d!==null&&(h.length===0?(d.f&Oe)===0?cn(d):(d.f^=Oe,$t(d,null,a)):hn(d,()=>{d=null}))}var m=Li(()=>{h=S(c);var g=h.length;let b=!1;if($e){var v=qi(a)===Gi;v!==(g===0)&&(a=Es(),ur(a),dr(!1),b=!0)}for(var k=new Set,y=ut,x=Vi(),z=0;z<g;z+=1){$e&&qt.nodeType===Ui&&qt.data===Oi&&(a=qt,b=!0,dr(!1));var M=h[z],D=s(M,z),B=f?null:o.get(D);B?(B.v&&Is(B.v,M),B.i&&Is(B.i,z),x&&y.skipped_effects.delete(B.e)):(B=pa(o,f?a:$s??=lr(),M,D,z,n,t,r),f||(B.e.f|=Oe),o.set(D,B)),k.add(D)}if(g===0&&i&&!d&&(f?d=Pr(()=>i(a)):(d=Pr(()=>i($s??=lr())),d.f|=Oe)),$e&&g>0&&ur(Es()),!f)if(x){for(const[R,L]of o)k.has(R)||y.skipped_effects.add(L.e);y.oncommit(w),y.ondiscard(()=>{})}else w();b&&dr(!0),S(c)}),p={effect:m,items:o,outrogroups:null,fallback:d};f=!1,$e&&(a=qt)}function ha(e,t,r,s,n){var i=(s&Zi)!==0,a=t.length,o=e.items,u=e.effect.first,l,d=null,c,h=[],f=[],w,m,p,g;if(i)for(g=0;g<a;g+=1)w=t[g],m=n(w,g),p=o.get(m).e,(p.f&Oe)===0&&(p.nodes?.a?.measure(),(c??=new Set).add(p));for(g=0;g<a;g+=1){if(w=t[g],m=n(w,g),p=o.get(m).e,e.outrogroups!==null)for(const B of e.outrogroups)B.pending.delete(p),B.done.delete(p);if((p.f&Oe)!==0)if(p.f^=Oe,p===u)$t(p,null,r);else{var b=d?d.next:u;p===e.effect.last&&(e.effect.last=p.prev),p.prev&&(p.prev.next=p.next),p.next&&(p.next.prev=p.prev),Ye(e,d,p),Ye(e,p,b),$t(p,b,r),d=p,h=[],f=[],u=d.next;continue}if((p.f&cr)!==0&&(cn(p),i&&(p.nodes?.a?.unfix(),(c??=new Set).delete(p))),p!==u){if(l!==void 0&&l.has(p)){if(h.length<f.length){var v=f[0],k;d=v.prev;var y=h[0],x=h[h.length-1];for(k=0;k<h.length;k+=1)$t(h[k],v,r);for(k=0;k<f.length;k+=1)l.delete(f[k]);Ye(e,y.prev,x.next),Ye(e,d,y),Ye(e,x,v),u=v,d=x,g-=1,h=[],f=[]}else l.delete(p),$t(p,u,r),Ye(e,p.prev,p.next),Ye(e,p,d===null?e.effect.first:d.next),Ye(e,d,p),d=p;continue}for(h=[],f=[];u!==null&&u!==p;)(l??=new Set).add(u),f.push(u),u=u.next;if(u===null)continue}(p.f&Oe)===0&&h.push(p),d=p,u=p.next}if(e.outrogroups!==null){for(const B of e.outrogroups)B.pending.size===0&&(Lr(ws(B.done)),e.outrogroups?.delete(B));e.outrogroups.size===0&&(e.outrogroups=null)}if(u!==null||l!==void 0){var z=[];if(l!==void 0)for(p of l)(p.f&cr)===0&&z.push(p);for(;u!==null;)(u.f&cr)===0&&u!==e.fallback&&z.push(u),u=u.next;var M=z.length;if(M>0){var D=(s&dn)!==0&&a===0?r:null;if(i){for(g=0;g<M;g+=1)z[g].nodes?.a?.measure();for(g=0;g<M;g+=1)z[g].nodes?.a?.fix()}ca(e,z,D)}}i&&pn(()=>{if(c!==void 0)for(p of c)p.nodes?.a?.apply()})}function pa(e,t,r,s,n,i,a,o){var u=(a&Ki)!==0?(a&Yi)===0?Wi(r,!1,!1):Fr(r):null,l=(a&Hi)!==0?Fr(n):null;return{v:u,i:l,e:Pr(()=>(i(t,u??r,l??n,o),()=>{e.delete(s)}))}}function $t(e,t,r){if(e.nodes)for(var s=e.nodes.start,n=e.nodes.end,i=t&&(t.f&Oe)===0?t.nodes.start:r;s!==null;){var a=Qi(s);if(i.before(s),s===n)return;s=a}}function Ye(e,t,r){t===null?e.effect.first=r:t.next=r,r===null?e.effect.last=t:r.prev=t}function fa(e,t,r){var s=e==null?"":""+e;return s===""?null:s}function ma(e,t){return e==null?null:String(e)}function st(e,t,r,s,n,i){var a=e.__className;if($e||a!==r||a===void 0){var o=fa(r);(!$e||o!==e.getAttribute("class"))&&(o==null?e.removeAttribute("class"):e.className=o),e.__className=r}return i}function wn(e,t,r,s){var n=e.__style;if($e||n!==t){var i=ma(t);(!$e||i!==e.getAttribute("style"))&&(i==null?e.removeAttribute("style"):e.style.cssText=i),e.__style=t}return s}const ga=Symbol("is custom element"),wa=Symbol("is html");function qe(e){if($e){var t=!1,r=()=>{if(!t){if(t=!0,e.hasAttribute("value")){var s=e.value;gt(e,"value",null),e.value=s}if(e.hasAttribute("checked")){var n=e.checked;gt(e,"checked",null),e.checked=n}}};e.__on_r=r,pn(r),sa()}}function ya(e,t){var r=yn(e);r.value===(r.value=t??void 0)||e.value===t&&(t!==0||e.nodeName!=="PROGRESS")||(e.value=t??"")}function gt(e,t,r,s){var n=yn(e);$e&&(n[t]=e.getAttribute(t),t==="src"||t==="srcset"||t==="href"&&e.nodeName==="LINK")||n[t]!==(n[t]=r)&&(t==="loading"&&(e[na]=r),r==null?e.removeAttribute(t):typeof r!="string"&&ba(e).includes(t)?e[t]=r:e.setAttribute(t,r))}function yn(e){return e.__attributes??={[ga]:e.nodeName.includes("-"),[wa]:e.namespaceURI===ea}}var zs=new Map;function ba(e){var t=e.getAttribute("is")||e.nodeName,r=zs.get(t);if(r)return r;zs.set(t,r=[]);for(var s,n=e,i=Element.prototype;i!==n;){s=ra(n);for(var a in s)s[a].set&&r.push(a);n=ta(n)}return r}function Ue(e,t,r=t){var s=new WeakSet;ia(e,"input",async n=>{var i=n?e.defaultValue:e.value;if(i=hr(e)?pr(i):i,r(i),ut!==null&&s.add(ut),await aa(),i!==(i=t())){var a=e.selectionStart,o=e.selectionEnd,u=e.value.length;if(e.value=i??"",o!==null){var l=e.value.length;a===o&&o===u&&l>u?(e.selectionStart=l,e.selectionEnd=l):(e.selectionStart=a,e.selectionEnd=Math.min(o,l))}}}),($e&&e.defaultValue!==e.value||oa(t)==null&&e.value)&&(r(hr(e)?pr(e.value):e.value),ut!==null&&s.add(ut)),ua(()=>{var n=t();if(e===document.activeElement){var i=la??ut;if(s.has(i))return}hr(e)&&n===pr(e.value)||e.type==="date"&&!n&&!e.value||n!==e.value&&(e.value=n??"")})}function hr(e){var t=e.type;return t==="number"||t==="range"}function pr(e){return e===""?null:+e}function bn(e){var t=Fr(0);return function(){return arguments.length===1?(C(t,S(t)+1),arguments[0]):(S(t),e())}}var O=class Nr{shape;strides;data;offset;sizeValue;constructor(t,r,s,n=0,i=!0){const a=De(t);if(i&&a!==r.length)throw new Error("Tensor data length does not match shape");this.shape=t.slice(),this.strides=(s??H(t)).slice(),this.data=r,this.offset=n,this.sizeValue=a}get size(){return this.sizeValue}view(t){if(De(t)!==this.size)throw new Error("View shape does not match tensor size");if(!fr(this))throw new Error("View requires contiguous tensor");const r=H(t);return new Nr(t,this.data,r,this.offset)}isContiguous(){return fr(this)}contiguous(){if(fr(this))return this;const t=new Float32Array(this.size),r=H(this.shape);for(let s=0;s<this.size;s++)t[s]=G(this,s,r);return new Nr(this.shape,t)}toArray(){const t=new Array(this.sizeValue);if(this.sizeValue===0)return t;const r=H(this.shape);for(let s=0;s<this.sizeValue;s+=1)t[s]=G(this,s,r);return t}};function va(e,t){return new O(t,Float32Array.from(e))}function vn(e,t){return xe(e,t)}function _a(e,t,r){const s=r?.alpha??1,n=kt(e.shape,t.shape),i=xe(e,n),a=xe(t,n),o=De(n),u=new Float32Array(o),l=H(n);for(let d=0;d<o;d+=1)u[d]=G(i,d,l)-s*G(a,d,l);return new O(n,u)}function ka(e,t,r){const s=r?.roundingMode??null,n=kt(e.shape,t.shape),i=xe(e,n),a=xe(t,n),o=De(n),u=new Float32Array(o),l=H(n);for(let d=0;d<o;d+=1){let c=G(i,d,l)/G(a,d,l);s==="floor"?c=Math.floor(c):s==="trunc"&&(c=Math.trunc(c)),u[d]=c}return new O(n,u)}function _n(e,t){return e.view(t)}function Sa(e){return e.contiguous()}function kn(e,t){if(!t)throw new Error("transpose requires options.dim0 and options.dim1");const r=e.shape.length,s=Qt(t.dim0,r),n=Qt(t.dim1,r);if(s===n)return e;const i=e.shape.slice(),a=e.strides.slice();return[i[s],i[n]]=[i[n],i[s]],[a[s],a[n]]=[a[n],a[s]],new O(i,e.data,a,e.offset,!1)}function xa(e,t){const r=e.shape.length;if(t.length!==r)throw new Error(`permute: dims length ${t.length} doesn't match tensor rank ${r}`);const s=new Set;for(const o of t){const u=o<0?o+r:o;if(u<0||u>=r)throw new Error(`permute: dimension ${o} out of range for rank ${r}`);if(s.has(u))throw new Error(`permute: duplicate dimension ${o}`);s.add(u)}const n=t.map(o=>o<0?o+r:o),i=n.map(o=>e.shape[o]),a=n.map(o=>e.strides[o]);return new O(i,e.data,a,e.offset,!1)}function Aa(e,t){const r=kt(e.shape,t.shape),s=xe(e,r),n=xe(t,r),i=De(r),a=new Float32Array(i),o=H(r);for(let u=0;u<i;u+=1)a[u]=G(s,u,o)+G(n,u,o);return new O(r,a)}function Ea(e,t){const r=kt(e.shape,t.shape),s=xe(e,r),n=xe(t,r),i=De(r),a=new Float32Array(i),o=H(r);for(let u=0;u<i;u+=1)a[u]=G(s,u,o)*G(n,u,o);return new O(r,a)}function Sn(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1){const n=G(e,s,r);t[s]=n>0?n:0}return new O(e.shape,t)}function xn(e,t){const r=e.shape.length,s=t.shape.length;if(r===0||s===0)throw new Error("matmul does not support scalar inputs");const n=r===1,i=s===1,a=n?new O([1,e.shape[0]],e.data,[0,e.strides[0]],e.offset,!1):e,o=i?new O([t.shape[0],1],t.data,[t.strides[0],0],t.offset,!1):t;if(a.shape.length<2||o.shape.length<2)throw new Error("matmul requires tensors with at least 1 dimension");const u=a.shape[a.shape.length-2],l=a.shape[a.shape.length-1],d=o.shape[o.shape.length-2],c=o.shape[o.shape.length-1];if(l!==d)throw new Error("matmul dimension mismatch");const h=kt(a.shape.slice(0,-2),o.shape.slice(0,-2)),f=xe(a,h.concat([u,l])),w=xe(o,h.concat([l,c])),m=De(h),p=new Float32Array(m*u*c),g=h.length,b=H(h),v=f.strides.slice(0,g),k=w.strides.slice(0,g),y=f.strides[g],x=f.strides[g+1],z=w.strides[g],M=w.strides[g+1];for(let B=0;B<m;B+=1){const R=qr(B,b,v,f.offset),L=qr(B,b,k,w.offset),q=B*u*c;for(let _=0;_<u;_+=1){const T=R+_*y,$=q+_*c;for(let P=0;P<c;P+=1){let j=0;for(let A=0;A<l;A+=1)j+=f.data[T+A*x]*w.data[L+A*z+P*M];p[$+P]=j}}}const D=h.concat([u,c]);return n&&i?new O([],p):n?new O(h.concat([c]),p):i?new O(h.concat([u]),p):new O(D,p)}function An(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.sqrt(G(e,s,r));return new O(e.shape,t)}function Ia(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.exp(G(e,s,r));return new O(e.shape,t)}function $a(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.log(G(e,s,r));return new O(e.shape,t)}function za(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1)t[s]=-G(e,s,r);return new O(e.shape,t)}function Ca(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.abs(G(e,s,r));return new O(e.shape,t)}function Ta(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.tanh(G(e,s,r));return new O(e.shape,t)}function Ba(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1){const n=G(e,s,r);t[s]=1/(1+Math.exp(-n))}return new O(e.shape,t)}function Ma(e){const t=.254829592,r=-.284496736,s=1.421413741,n=-1.453152027,i=1.061405429,a=.3275911,o=e<0?-1:1;e=Math.abs(e);const u=1/(1+a*e);return o*(1-((((i*u+n)*u+s)*u+r)*u+t)*u*Math.exp(-e*e))}function Da(e,t){const r=t?.approximate??"tanh",s=new Float32Array(e.size),n=H(e.shape);if(r==="tanh"){const i=.7978845608;for(let a=0;a<e.size;a+=1){const o=G(e,a,n);s[a]=o*.5*(1+Math.tanh(i*(o+.044715*o*o*o)))}}else{const i=.7071067811865476;for(let a=0;a<e.size;a+=1){const o=G(e,a,n);s[a]=o*.5*(1+Ma(o*i))}}return new O(e.shape,s)}function Ra(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1){const n=G(e,s,r);t[s]=n/(1+Math.exp(-n))}return new O(e.shape,t)}function Pa(e){const t=new Float32Array(e.size),r=H(e.shape);for(let s=0;s<e.size;s+=1){const n=G(e,s,r);t[s]=Number.isFinite(n)?1:0}return new O(e.shape,t)}function H(e){const t=new Array(e.length);let r=1;for(let s=e.length-1;s>=0;s-=1)t[s]=r,r*=e[s];return t}function De(e){return e.reduce((t,r)=>t*r,1)}function fr(e){const t=H(e.shape);if(t.length!==e.strides.length)return!1;for(let r=0;r<t.length;r+=1)if(!(e.shape[r]<=1)&&e.strides[r]!==t[r])return!1;return!0}function qr(e,t,r,s){let n=e,i=s;for(let a=0;a<t.length;a+=1){const o=t[a],u=o===0?0:Math.floor(n/o);n-=u*o,i+=u*r[a]}return i}function G(e,t,r){const s=qr(t,r,e.strides,e.offset);return e.data[s]}function kt(e,t){const r=Math.max(e.length,t.length),s=new Array(r);for(let n=0;n<r;n+=1){const i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw new Error("shapes are not broadcastable");s[r-1-n]=Math.max(i,a)}return s}function xe(e,t){if(e.shape.length===t.length&&e.shape.every((n,i)=>n===t[i]))return e;if(e.shape.length>t.length)throw new Error("broadcast target has fewer dimensions than input");const r=t.length-e.shape.length,s=new Array(t.length);for(let n=0;n<t.length;n+=1){const i=n-r;if(i<0){s[n]=0;continue}const a=e.shape[i];if(a===t[n])s[n]=e.strides[i];else if(a===1)s[n]=0;else throw new Error("broadcast target shape is incompatible")}return new O(t,e.data,s,e.offset,!1)}function Qt(e,t){const r=e<0?t+e:e;if(r<0||r>=t)throw new Error(`dim out of range: ${e}`);return r}function En(e,t){if(!Number.isFinite(e)||Math.trunc(e)!==e)throw new Error("index values must be integers");if(e<0||e>=t)throw new Error("index out of range");return e}function In(e,t,r){if(!r)throw new Error("gather requires options.dim");const s=e.shape.length;if(t.shape.length!==s)throw new Error("gather requires index with the same rank as input");const n=Qt(r.dim,s);for(let u=0;u<s;u+=1)if(u!==n&&t.shape[u]>e.shape[u])throw new Error("gather index shape must be <= input shape");const i=new Float32Array(t.size),a=H(t.shape),o=e.strides;for(let u=0;u<t.size;u+=1){let l=u,d=0;for(let c=0;c<s;c+=1){const h=a[c],f=Math.floor(l/h);if(l-=f*h,c===n){const w=En(G(t,u,a),e.shape[n]);d+=w*o[c]}else d+=f*o[c]}i[u]=e.data[d+e.offset]}return new O(t.shape,i)}function $n(e,t,r,s){if(!s)throw new Error("scatterAdd requires options.dim");const n=e.shape.length;if(t.shape.length!==n||r.shape.length!==n)throw new Error("scatterAdd requires index/src with the same rank as input");const i=Qt(s.dim,n);for(let d=0;d<n;d+=1){if(t.shape[d]!==r.shape[d])throw new Error("scatterAdd requires index and src to have the same shape");if(d!==i&&t.shape[d]>e.shape[d])throw new Error("scatterAdd index shape must be <= input shape")}const a=new Float32Array(e.size),o=H(e.shape);for(let d=0;d<e.size;d+=1)a[d]=G(e,d,o);const u=H(t.shape),l=H(e.shape);for(let d=0;d<t.size;d+=1){let c=d,h=0;for(let f=0;f<n;f+=1){const w=u[f],m=Math.floor(c/w);if(c-=m*w,f===i){const p=En(G(t,d,u),e.shape[i]);h+=p*l[f]}else h+=m*l[f]}a[h]+=G(r,d,u)}return new O(e.shape,a)}function zn(e){let t=0;const r=H(e.shape);for(let s=0;s<e.size;s+=1)t+=G(e,s,r);return t}function Cn(e,t){const r=(Array.isArray(e)?e.slice():[e]).map(n=>n<0?t+n:n),s=new Set;for(const n of r){if(n<0||n>=t)throw new Error(`sum dim out of range: ${n}`);if(s.has(n))throw new Error(`sum dim repeated: ${n}`);s.add(n)}return Array.from(s).sort((n,i)=>n-i)}function Gr(e,t){if(!t||t.dim==null)return new O([],new Float32Array([zn(e)]));if(t.dtype!=null)throw new Error("sum dtype option is not supported yet");const r=e.shape.length,s=Cn(t.dim,r),n=t.keepdim??!1,i=new Set(s),a=n?e.shape.map((c,h)=>i.has(h)?1:c):e.shape.filter((c,h)=>!i.has(h)),o=a.reduce((c,h)=>c*h,1)||1,u=new Float32Array(o),l=H(e.shape),d=H(a);for(let c=0;c<e.size;c+=1){let h=c,f=0;if(n)for(let w=0;w<r;w+=1){const m=l[w],p=Math.floor(h/m);h-=p*m,i.has(w)||(f+=p*d[w])}else{let w=0;for(let m=0;m<r;m+=1){const p=l[m],g=Math.floor(h/p);h-=g*p,i.has(m)||(f+=g*d[w],w+=1)}}u[f]+=G(e,c,l)}return new O(a,u)}function Fa(e){let t=-1/0;const r=H(e.shape);for(let s=0;s<e.size;s+=1){const n=G(e,s,r);n>t&&(t=n)}return t}function La(e,t){if(!t||t.dim==null)return new O([],new Float32Array([Fa(e)]));const r=e.shape.length,s=Na(t.dim,r,"max"),n=t.keepdim??!1,i=new Set(s),a=n?e.shape.map((c,h)=>i.has(h)?1:c):e.shape.filter((c,h)=>!i.has(h)),o=a.reduce((c,h)=>c*h,1)||1,u=new Float32Array(o);u.fill(-1/0);const l=H(e.shape),d=H(a);for(let c=0;c<e.size;c+=1){let h=c,f=0;if(n)for(let m=0;m<r;m+=1){const p=l[m],g=Math.floor(h/p);h-=g*p,i.has(m)||(f+=g*d[m])}else{let m=0;for(let p=0;p<r;p+=1){const g=l[p],b=Math.floor(h/g);h-=b*g,i.has(p)||(f+=b*d[m],m+=1)}}const w=G(e,c,l);w>u[f]&&(u[f]=w)}return new O(a,u)}function Na(e,t,r){const s=(Array.isArray(e)?e.slice():[e]).map(i=>i<0?t+i:i),n=new Set;for(const i of s){if(i<0||i>=t)throw new Error(`${r} dim out of range: ${i}`);if(n.has(i))throw new Error(`${r} dim repeated: ${i}`);n.add(i)}return Array.from(n).sort((i,a)=>i-a)}function qa(e,t){const r=e.shape.length,s=t.dim<0?t.dim+r:t.dim;if(s<0||s>=r)throw new Error(`argmax: dim ${t.dim} out of range for tensor of rank ${r}`);const n=t.keepdim??!1,i=n?e.shape.map((c,h)=>h===s?1:c):e.shape.filter((c,h)=>h!==s),a=i.reduce((c,h)=>c*h,1)||1,o=new Float32Array(a),u=new Float32Array(a);u.fill(-1/0);const l=H(e.shape),d=H(i);e.shape[s];for(let c=0;c<e.size;c+=1){let h=c,f=0,w=0;if(n)for(let p=0;p<r;p+=1){const g=l[p],b=Math.floor(h/g);h-=b*g,p===s?w=b:f+=b*d[p]}else{let p=0;for(let g=0;g<r;g+=1){const b=l[g],v=Math.floor(h/b);h-=v*b,g===s?w=v:(f+=v*d[p],p+=1)}}const m=G(e,c,l);m>u[f]&&(u[f]=m,o[f]=w)}return new O(i,o)}function Ga(e,t){const r=e.shape.length,s=t.dim<0?t.dim+r:t.dim;if(s<0||s>=r)throw new Error(`argmin: dim ${t.dim} out of range for tensor of rank ${r}`);const n=t.keepdim??!1,i=n?e.shape.map((c,h)=>h===s?1:c):e.shape.filter((c,h)=>h!==s),a=i.reduce((c,h)=>c*h,1)||1,o=new Float32Array(a),u=new Float32Array(a);u.fill(1/0);const l=H(e.shape),d=H(i);for(let c=0;c<e.size;c+=1){let h=c,f=0,w=0;if(n)for(let p=0;p<r;p+=1){const g=l[p],b=Math.floor(h/g);h-=b*g,p===s?w=b:f+=b*d[p]}else{let p=0;for(let g=0;g<r;g+=1){const b=l[g],v=Math.floor(h/b);h-=v*b,g===s?w=v:(f+=v*d[p],p+=1)}}const m=G(e,c,l);m<u[f]&&(u[f]=m,o[f]=w)}return new O(i,o)}function Ua(e,t){const{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=St(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=G(r,u,a)>G(s,u,a)?1:0;return new O(n,o)}function Oa(e,t){const{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=St(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=G(r,u,a)<G(s,u,a)?1:0;return new O(n,o)}function Va(e,t){const{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=St(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=G(r,u,a)>=G(s,u,a)?1:0;return new O(n,o)}function ja(e,t){const{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=St(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=G(r,u,a)<=G(s,u,a)?1:0;return new O(n,o)}function Wa(e,t){const{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=St(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=G(r,u,a)===G(s,u,a)?1:0;return new O(n,o)}function Ha(e,t){const{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=St(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=G(r,u,a)!==G(s,u,a)?1:0;return new O(n,o)}function St(e,t){const r=kt(e.shape,t.shape);return{aBroadcast:xe(e,r),bBroadcast:xe(t,r),outShape:r,outSize:De(r),shapeStrides:H(r)}}function Ka(e,t,r){const s=Ya(e.shape,t.shape,r.shape),n=xe(e,s),i=xe(t,s),a=xe(r,s),o=De(s),u=new Float32Array(o),l=H(s);for(let d=0;d<o;d+=1){const c=G(n,d,l),h=G(i,d,l),f=G(a,d,l);u[d]=c!==0?h:f}return new O(s,u)}function Ya(e,t,r){const s=Math.max(e.length,t.length,r.length),n=new Array(s);for(let i=0;i<s;i+=1){const a=e[e.length-1-i]??1,o=t[t.length-1-i]??1,u=r[r.length-1-i]??1;if(a!==o&&a!==1&&o!==1)throw new Error("shapes are not broadcastable");if(a!==u&&a!==1&&u!==1)throw new Error("shapes are not broadcastable");if(o!==u&&o!==1&&u!==1)throw new Error("shapes are not broadcastable");n[s-1-i]=Math.max(a,o,u)}return n}function Qa(e,t,r){const{offset:s,viewShape:n,viewStrides:i}=r;if(t.shape.length!==n.length)throw new Error(`stridedScatterCopy: src rank ${t.shape.length} doesn't match view rank ${n.length}`);for(let l=0;l<n.length;l++)if(t.shape[l]!==n[l])throw new Error(`stridedScatterCopy: src shape [${t.shape}] doesn't match view shape [${n}]`);const a=new Float32Array(e.data.length);a.set(e.data);const o=De(n),u=H(n);for(let l=0;l<o;l++){let d=l,c=s;for(let h=0;h<n.length;h++){const f=u[h],w=Math.floor(d/f);d-=w*f,c+=w*i[h]}a[c]=G(t,l,u)}return new O(e.shape,a,H(e.shape),0)}function Za(e,t,r){const{offset:s,viewShape:n,viewStrides:i}=r;if(t.shape.length!==n.length)throw new Error(`stridedScatterAdd: src rank ${t.shape.length} doesn't match view rank ${n.length}`);for(let l=0;l<n.length;l++)if(t.shape[l]!==n[l])throw new Error(`stridedScatterAdd: src shape [${t.shape}] doesn't match view shape [${n}]`);const a=new Float32Array(e.data.length);a.set(e.data);const o=De(n),u=H(n);for(let l=0;l<o;l++){let d=l,c=s;for(let f=0;f<n.length;f++){const w=u[f],m=Math.floor(d/w);d-=m*w,c+=m*i[f]}const h=G(t,l,u);a[c]+=h}return new O(e.shape,a,H(e.shape),0)}function Ur(e,t){if(!t||t.dim==null)return new O([],new Float32Array([zn(e)/e.size]));if(t.dtype!=null)throw new Error("mean dtype option is not supported yet");const r=e.shape.length,s=Cn(t.dim,r),n=t.keepdim??!1,i=new Set(s),a=s.reduce((f,w)=>f*e.shape[w],1),o=n?e.shape.map((f,w)=>i.has(w)?1:f):e.shape.filter((f,w)=>!i.has(w)),u=o.reduce((f,w)=>f*w,1)||1,l=new Float32Array(u),d=H(e.shape),c=H(o);for(let f=0;f<e.size;f+=1){let w=f,m=0;if(n)for(let p=0;p<r;p+=1){const g=d[p],b=Math.floor(w/g);w-=b*g,i.has(p)||(m+=b*c[p])}else{let p=0;for(let g=0;g<r;g+=1){const b=d[g],v=Math.floor(w/b);w-=v*b,i.has(g)||(m+=v*c[p],p+=1)}}l[m]+=G(e,f,d)}const h=a||0;for(let f=0;f<l.length;f+=1)l[f]=l[f]/h;return new O(o,l)}function Xa(e){return Promise.resolve(e.toArray())}function Ja(e,t){return e}const Or={name:"cpu",ops:{tensorFromArray:va,add:Aa,sub:_a,div:ka,mul:Ea,matmul:xn,sqrt:An,relu:Sn,exp:Ia,log:$a,neg:za,abs:Ca,tanh:Ta,sigmoid:Ba,gelu:Da,silu:Ra,isfinite:Pa,gather:In,scatterAdd:$n,sum:Gr,max:La,mean:Ur,argmax:qa,argmin:Ga,gt:Ua,lt:Oa,ge:Va,le:ja,eq:Wa,ne:Ha,expand:vn,reshape:_n,transpose:kn,permute:xa,contiguous:Sa,cast:Ja,where:Ka,stridedScatterCopy:Qa,stridedScatterAdd:Za,read:Xa}};function eo(e,t){return new O(t,Float32Array.from(e))}function to(e,t){return new O(e.shape,Float32Array.from(e.toArray()))}function ro(e,t,r){return new O(e.shape,Float32Array.from(e.toArray()))}function so(e,t,r){return new O(e.shape,Float32Array.from(e.toArray()))}function no(e,t){return new O(e.shape,Float32Array.from(e.toArray()))}function io(e,t){return xn(e,t)}function ao(e){return An(e)}function oo(e){return Sn(e)}function uo(e,t){return vn(e,t)}function lo(e,t){return _n(e,t)}function co(e,t){return kn(e,t)}function ho(e,t,r){return In(e,t,r)}function po(e,t,r,s){return $n(e,t,r,s)}function fo(e,t){return t?.dim!=null?Gr(e,t):Gr(e)}function mo(e,t){return t?.dim!=null?Ur(e,t):Ur(e)}function go(e){return Promise.resolve(e.toArray())}const Cs={name:"mock",ops:{tensorFromArray:eo,add:to,sub:ro,div:so,mul:no,matmul:io,sqrt:ao,relu:oo,expand:uo,reshape:lo,transpose:co,gather:ho,scatterAdd:po,sum:fo,mean:mo,read:go}},bs=new Map;bs.set(Or.name,Or);bs.set(Cs.name,Cs);let wo=Or;function je(e){return bs.get(e)}function mr(){return wo}const yo=new Set(["add","sub","mul","div","sqrt","relu","neg","abs","exp","log","sigmoid","tanh","gelu","silu"]);function Tn(e){return yo.has(e)}function bo(e){const t=[];let r=null,s=0;const n=()=>{if(r&&r.nodes.length>=2){const i=vo(r.nodes,new Set(r.nodes.map(a=>a.id)));t.push({nodes:r.nodes,planIndices:r.indices,externalInputs:i,outputNode:r.nodes[r.nodes.length-1]})}r=null};for(let i=0;i<e.length;i++){const a=e[i];Tn(a.op)?(s++,r||(r={nodes:[],indices:[]}),r.nodes.push(a),r.indices.push(i)):n()}return n(),{groups:t,stats:{totalNodes:e.length,fusibleNodes:s,groupCount:t.length,nodesInGroups:t.reduce((i,a)=>i+a.nodes.length,0)}}}function vo(e,t){const r=[],s=new Set;for(const n of e)for(const i of n.inputs)i.kind==="materialized"?s.has(i.storage.id)||(s.add(i.storage.id),r.push(i)):i.kind==="pending"&&!t.has(i.node.id)&&!s.has(i.node.id)&&(s.add(i.node.id),r.push(i));return r}function _o(e){const t=e.nodes.map(l=>l.id),r=new Set(t),s=new Map,n=[],i=l=>{const d=l.kind==="materialized"?-l.storage.id:l.node.id;if(s.has(d))return s.get(d);const c=n.length;return s.set(d,-(c+1)),l.kind==="materialized"?n.push({id:d,index:c,shape:[l.storage.backendTensor.shape.reduce((h,f)=>h*f,1)],dtype:"f32"}):n.push({id:l.node.id,index:c,shape:l.node.shape??[1],dtype:l.node.dtype??"f32"}),-(c+1)},a=[];for(const l of e.nodes){const d=[];for(const c of l.inputs)if(c.kind==="pending"&&r.has(c.node.id))d.push(c.node.id);else{const h=i(c);d.push(h)}a.push({id:l.id,op:l.op,inputs:d,shape:l.shape??[1],dtype:l.dtype??"f32",isOutput:l===e.outputNode})}const o=e.outputNode,u=[{nodeId:o.id,index:0,shape:o.shape??[1],dtype:o.dtype??"f32"}];return{id:`lazy_fused_${t.join("_")}`,nodes:a,inputs:n,outputs:u}}function ko(e){const{groups:t}=bo(e),r=[],s=new Map;for(const i of t)for(const a of i.planIndices)s.set(a,i);let n=0;for(;n<e.length;){const i=s.get(n);if(i){const a=_o(i);r.push({kind:"fused",group:i,recipe:a}),n=Math.max(...i.planIndices)+1}else{const a=[];for(;n<e.length&&!s.has(n);)a.push(e[n]),n++;a.length>0&&r.push({kind:"sequential",nodes:a})}}return r}function So(e){let t=0;for(const r of e)if(Tn(r.op)){if(t++,t>=2)return!0}else t=0;return!1}function Z(e){return{kind:"pending",node:e}}function gr(e){return e.kind==="materialized"}function xo(e){const t=[],r=new Set,s=n=>{if(n.kind!=="materialized"&&!r.has(n.node.id)){r.add(n.node.id);for(const i of n.node.inputs)s(i);t.push(n.node)}};return s({kind:"pending",node:e}),{nodes:t}}let Ao=1;function X(e,t,r,s,n,i){return{id:Ao++,op:e,inputs:t,shape:r,dtype:s,device:n,payload:i}}let Eo=1;var Io=class{allStorages=new Map;externallyReachable=new Set;register(e){this.allStorages.set(e.id,e)}markReachable(e){this.externallyReachable.add(e)}markUnreachable(e){this.externallyReachable.delete(e)}isReachable(e){return this.externallyReachable.has(e)}unregister(e){this.allStorages.delete(e),this.externallyReachable.delete(e)}destroyUnreachable(){let e=0;const t=new Set,r=[...this.externallyReachable];for(;r.length>0;){const n=r.pop(),i=this.allStorages.get(n);i?.baseStorageId!==void 0&&!t.has(i.baseStorageId)&&(t.add(i.baseStorageId),r.push(i.baseStorageId))}const s=[];for(const[n,i]of this.allStorages)!this.externallyReachable.has(n)&&!t.has(n)&&s.push(n);for(const n of s){const i=this.allStorages.get(n);if(i){const a=i.backendTensor;a.ownsBuffer!==!1&&a.destroy&&a.destroy(),this.allStorages.delete(n),e++}}return e}stats(){return{totalStorages:this.allStorages.size,reachableStorages:this.externallyReachable.size,unreachableStorages:this.allStorages.size-this.externallyReachable.size}}reset(){this.allStorages.clear(),this.externallyReachable.clear()}};const lt=new Io;function ir(e,t,r){const s={id:Eo++,device:e,backendTensor:t,baseStorageId:r};return lt.register(s),s}function Bn(e){if(e.kind==="materialized")return e.storage;if(e.node.result)return e.node.result;throw new Error("Input not ready")}async function Mn(e,t){if(e.nodes.length===0)throw new Error("Cannot execute empty plan");for(const s of e.nodes){const n=s.inputs.map(Bn),i=n.map(l=>l.backendTensor),a=je(s.device)??t;let o;switch(s.op){case"tensorFromArray":{const l=s.payload;if(!l?.values)throw new Error("tensorFromArray requires values in payload");o=a.ops.tensorFromArray(l.values,s.shape);break}case"add":o=a.ops.add(i[0],i[1]);break;case"sub":{const l=s.payload;o=a.ops.sub(i[0],i[1],l);break}case"mul":o=a.ops.mul(i[0],i[1]);break;case"div":{const l=s.payload;o=a.ops.div(i[0],i[1],l);break}case"matmul":o=a.ops.matmul(i[0],i[1]);break;case"sqrt":o=a.ops.sqrt(i[0]);break;case"relu":o=a.ops.relu(i[0]);break;case"exp":if(!a.ops.exp)throw new Error("exp not supported by backend");o=a.ops.exp(i[0]);break;case"log":if(!a.ops.log)throw new Error("log not supported by backend");o=a.ops.log(i[0]);break;case"neg":if(!a.ops.neg)throw new Error("neg not supported by backend");o=a.ops.neg(i[0]);break;case"abs":if(!a.ops.abs)throw new Error("abs not supported by backend");o=a.ops.abs(i[0]);break;case"tanh":if(!a.ops.tanh)throw new Error("tanh not supported by backend");o=a.ops.tanh(i[0]);break;case"sigmoid":if(!a.ops.sigmoid)throw new Error("sigmoid not supported by backend");o=a.ops.sigmoid(i[0]);break;case"gelu":{if(!a.ops.gelu)throw new Error("gelu not supported by backend");const l=s.payload;o=a.ops.gelu(i[0],l);break}case"silu":if(!a.ops.silu)throw new Error("silu not supported by backend");o=a.ops.silu(i[0]);break;case"isfinite":if(!a.ops.isfinite)throw new Error("isfinite not supported by backend");o=a.ops.isfinite(i[0]);break;case"reshape":{const l=s.payload?.targetShape??s.shape;o=a.ops.reshape(i[0],l);break}case"expand":o=a.ops.expand(i[0],s.shape);break;case"transpose":{const l=s.payload;if(!l)throw new Error("transpose requires dim0 and dim1 in payload");o=a.ops.transpose(i[0],l);break}case"permute":{const l=s.payload;if(!l)throw new Error("permute requires dims in payload");o=a.ops.permute(i[0],l.dims);break}case"contiguous":o=a.ops.contiguous(i[0]);break;case"cast":{const l=s.payload;if(!l)throw new Error("cast requires dtype in payload");if(!a.ops.cast)throw new Error("cast not supported by backend");o=a.ops.cast(i[0],l.dtype);break}case"gather":{const l=s.payload;if(!l)throw new Error("gather requires dim in payload");o=a.ops.gather(i[0],i[1],l);break}case"scatterAdd":{const l=s.payload;if(!l)throw new Error("scatterAdd requires dim in payload");o=a.ops.scatterAdd(i[0],i[1],i[2],l);break}case"sum":{const l=s.payload;o=a.ops.sum(i[0],l);break}case"max":{const l=s.payload;o=a.ops.max(i[0],l);break}case"mean":{const l=s.payload;o=a.ops.mean(i[0],l);break}case"argmax":{const l=s.payload;if(!a.ops.argmax)throw new Error("argmax not supported by backend");o=a.ops.argmax(i[0],l);break}case"argmin":{const l=s.payload;if(!a.ops.argmin)throw new Error("argmin not supported by backend");o=a.ops.argmin(i[0],l);break}case"gt":if(!a.ops.gt)throw new Error("gt not supported by backend");o=a.ops.gt(i[0],i[1]);break;case"lt":if(!a.ops.lt)throw new Error("lt not supported by backend");o=a.ops.lt(i[0],i[1]);break;case"ge":if(!a.ops.ge)throw new Error("ge not supported by backend");o=a.ops.ge(i[0],i[1]);break;case"le":if(!a.ops.le)throw new Error("le not supported by backend");o=a.ops.le(i[0],i[1]);break;case"eq":if(!a.ops.eq)throw new Error("eq not supported by backend");o=a.ops.eq(i[0],i[1]);break;case"ne":if(!a.ops.ne)throw new Error("ne not supported by backend");o=a.ops.ne(i[0],i[1]);break;case"where":o=a.ops.where(i[0],i[1],i[2]);break;case"stridedScatterCopy":{const l=s.payload;if(!l)throw new Error("stridedScatterCopy requires options in payload");o=a.ops.stridedScatterCopy(i[0],i[1],l);break}case"stridedScatterAdd":{const l=s.payload;if(!l)throw new Error("stridedScatterAdd requires options in payload");o=a.ops.stridedScatterAdd(i[0],i[1],l);break}case"transfer":{const l=n[0],d=s.device,c=l.device;if(c===d)o=l.backendTensor;else{const h=je(d);if(!h)throw new Error(`Transfer failed: backend not available for ${d}`);const f=je(c);if(!f)throw new Error(`Transfer failed: backend not available for ${c}`);const w=await f.ops.read(l.backendTensor);o=h.ops.tensorFromArray(w,s.shape)}break}default:throw new Error(`Unknown op: ${s.op}`)}const u=o.ownsBuffer===!1&&n.length>0?n[0].id:void 0;s.result=ir(s.device,o,u)}const r=e.nodes[e.nodes.length-1];if(!r.result)throw new Error("Execution failed: no result for last node");return r.result}async function $o(e,t,r={}){if(e.nodes.length===0)throw new Error("Cannot execute empty plan");const{enableFusion:s=t.name==="webgpu",enableVectorization:n=!0,minFusionSize:i=2}=r,a={totalNodes:e.nodes.length,fusedNodes:0,sequentialNodes:0,fusionGroups:0,fusionEnabled:s};if(!s||!So(e.nodes)){const l=await Mn(e,t);return a.sequentialNodes=e.nodes.length,{result:l,stats:a}}const o=ko(e.nodes);for(const l of o)l.kind==="fused"&&l.group.nodes.length>=i?(await zo(l.group,l.recipe,t,n),a.fusedNodes+=l.group.nodes.length,a.fusionGroups++):l.kind==="fused"?(await dt(l.group.nodes,t),a.sequentialNodes+=l.group.nodes.length):(await dt(l.nodes,t),a.sequentialNodes+=l.nodes.length);const u=e.nodes[e.nodes.length-1];if(!u.result)throw new Error("Execution failed: no result for last node");return{result:u.result,stats:a}}async function zo(e,t,r,s){if(r.name==="webgpu"&&"dispatchFusedKernel"in r){await Co(e,t,r,s);return}await dt(e.nodes,r)}async function Co(e,t,r,s){const{dispatchFusedKernel:n}=await Ft(async()=>{const{dispatchFusedKernel:o}=await import("./CJ6vKN7B.js");return{dispatchFusedKernel:o}},[],import.meta.url),i=r.device;if(!i){await dt(e.nodes,r);return}const a=[];for(const o of e.externalInputs){const u=o.kind==="materialized"?o.storage:o.node.result;if(!u){await dt(e.nodes,r);return}const l=u.backendTensor;a.push({buffer:l.buffer,shape:l.shape??[1],dtype:l.dtype??"f32"})}try{const o=n(i,t,a,{vectorize:s}),u=e.outputNode;u.result=ir(u.device,{buffer:o.buffer,shape:o.shape,dtype:o.dtype,size:o.shape.reduce((l,d)=>l*d,1)*4,strides:Bo(o.shape),offset:0,isContiguous:!0});for(const l of e.nodes)l!==u&&!l.result&&(l.result=u.result)}catch(o){console.warn("Fusion dispatch failed, falling back to sequential:",o),await dt(e.nodes,r)}}async function dt(e,t){for(const r of e){if(r.result)continue;const s=r.inputs.map(Bn),n=await To(r,s.map(a=>a.backendTensor),je(r.device)??t),i=n.ownsBuffer===!1&&s.length>0?s[0].id:void 0;r.result=ir(r.device,n,i)}}async function To(e,t,r){switch(e.op){case"tensorFromArray":{const s=e.payload;if(!s?.values)throw new Error("tensorFromArray requires values in payload");return r.ops.tensorFromArray(s.values,e.shape)}case"add":return r.ops.add(t[0],t[1]);case"sub":{const s=e.payload;return r.ops.sub(t[0],t[1],s)}case"mul":return r.ops.mul(t[0],t[1]);case"div":{const s=e.payload;return r.ops.div(t[0],t[1],s)}case"matmul":return r.ops.matmul(t[0],t[1]);case"sqrt":return r.ops.sqrt(t[0]);case"relu":return r.ops.relu(t[0]);case"exp":if(!r.ops.exp)throw new Error("exp not supported by backend");return r.ops.exp(t[0]);case"log":if(!r.ops.log)throw new Error("log not supported by backend");return r.ops.log(t[0]);case"neg":if(!r.ops.neg)throw new Error("neg not supported by backend");return r.ops.neg(t[0]);case"abs":if(!r.ops.abs)throw new Error("abs not supported by backend");return r.ops.abs(t[0]);case"tanh":if(!r.ops.tanh)throw new Error("tanh not supported by backend");return r.ops.tanh(t[0]);case"sigmoid":if(!r.ops.sigmoid)throw new Error("sigmoid not supported by backend");return r.ops.sigmoid(t[0]);case"gelu":{if(!r.ops.gelu)throw new Error("gelu not supported by backend");const s=e.payload;return r.ops.gelu(t[0],s)}case"silu":if(!r.ops.silu)throw new Error("silu not supported by backend");return r.ops.silu(t[0]);case"isfinite":if(!r.ops.isfinite)throw new Error("isfinite not supported by backend");return r.ops.isfinite(t[0]);case"reshape":{const s=e.payload?.targetShape??e.shape;return r.ops.reshape(t[0],s)}case"expand":return r.ops.expand(t[0],e.shape);case"transpose":{const s=e.payload;if(!s)throw new Error("transpose requires dim0 and dim1 in payload");return r.ops.transpose(t[0],s)}case"permute":{const s=e.payload;if(!s)throw new Error("permute requires dims in payload");return r.ops.permute(t[0],s.dims)}case"contiguous":return r.ops.contiguous(t[0]);case"cast":{const s=e.payload;if(!s)throw new Error("cast requires dtype in payload");if(!r.ops.cast)throw new Error("cast not supported by backend");return r.ops.cast(t[0],s.dtype)}case"gather":{const s=e.payload;if(!s)throw new Error("gather requires dim in payload");return r.ops.gather(t[0],t[1],s)}case"scatterAdd":{const s=e.payload;if(!s)throw new Error("scatterAdd requires dim in payload");return r.ops.scatterAdd(t[0],t[1],t[2],s)}case"sum":{const s=e.payload;return r.ops.sum(t[0],s)}case"max":{const s=e.payload;return r.ops.max(t[0],s)}case"mean":{const s=e.payload;return r.ops.mean(t[0],s)}case"argmax":{const s=e.payload;if(!r.ops.argmax)throw new Error("argmax not supported by backend");return r.ops.argmax(t[0],s)}case"argmin":{const s=e.payload;if(!r.ops.argmin)throw new Error("argmin not supported by backend");return r.ops.argmin(t[0],s)}case"gt":if(!r.ops.gt)throw new Error("gt not supported by backend");return r.ops.gt(t[0],t[1]);case"lt":if(!r.ops.lt)throw new Error("lt not supported by backend");return r.ops.lt(t[0],t[1]);case"ge":if(!r.ops.ge)throw new Error("ge not supported by backend");return r.ops.ge(t[0],t[1]);case"le":if(!r.ops.le)throw new Error("le not supported by backend");return r.ops.le(t[0],t[1]);case"eq":if(!r.ops.eq)throw new Error("eq not supported by backend");return r.ops.eq(t[0],t[1]);case"ne":if(!r.ops.ne)throw new Error("ne not supported by backend");return r.ops.ne(t[0],t[1]);case"where":return r.ops.where(t[0],t[1],t[2]);case"stridedScatterCopy":{const s=e.payload;if(!s)throw new Error("stridedScatterCopy requires options in payload");return r.ops.stridedScatterCopy(t[0],t[1],s)}case"stridedScatterAdd":{const s=e.payload;if(!s)throw new Error("stridedScatterAdd requires options in payload");return r.ops.stridedScatterAdd(t[0],t[1],s)}case"transfer":throw new Error("Transfer ops should be handled in executePlan");default:throw new Error(`Unknown op: ${e.op}`)}}function Bo(e){const t=new Array(e.length);let r=1;for(let s=e.length-1;s>=0;s--)t[s]=r,r*=e[s];return t}const Ts=new FinalizationRegistry(e=>{e.storageId>=0&&lt.markUnreachable(e.storageId)}),wt=new Map;function Bs(e,t){let r=wt.get(e);r||(r=new Set,wt.set(e,r)),r.add(t)}function wr(e,t){const r=wt.get(e);r&&(r.delete(t),r.size===0&&wt.delete(e))}function Mo(e,t){const r=wt.get(e);if(r)for(const s of r)!s.isMaterialized()&&!s.disposed&&s._materialize(t)}function Do(){const e=[];for(const t of wt.values())for(const r of t)e.push(r);return e}var te=class Dn{baseId;device;shape;_lazyRef;_pendingNodeId=null;_held;constructor(t,r,s,n){this.baseId=t,this._lazyRef=r,this.device=n,this.shape=s.slice(),this._held={storageId:r.kind==="materialized"?r.storage.id:-1},Ts.register(this,this._held,this),r.kind==="pending"?(this._pendingNodeId=r.node.id,Bs(r.node.id,this)):r.kind==="materialized"&&lt.markReachable(r.storage.id)}get lazyRef(){return this._lazyRef}get backendTensor(){if(!gr(this._lazyRef))throw new Error("Tensor not materialized. Call cpu() or item() first to force execution.");return this._lazyRef.storage.backendTensor}isMaterialized(){return gr(this._lazyRef)}_materialize(t){this._pendingNodeId!==null&&(wr(this._pendingNodeId,this),this._pendingNodeId=null),this._lazyRef={kind:"materialized",storage:t},this._held.storageId=t.id,lt.markReachable(t.id)}_updateLazyRef(t){this._pendingNodeId!==null&&(wr(this._pendingNodeId,this),this._pendingNodeId=null),this._lazyRef=t,t.kind==="pending"&&(this._pendingNodeId=t.node.id,Bs(t.node.id,this))}toArray(){return this.backendTensor.toArray()}view(t){const r=this.backendTensor;if(!r.view)throw new Error("view is not supported for this backend tensor");const s=r.view(t);return new Dn(this.baseId,{kind:"materialized",storage:{id:-1,device:this.device,backendTensor:s}},s.shape,this.device)}_disposed=!1;dispose(){if(!this._disposed&&(this._disposed=!0,Ts.unregister(this),this._held.storageId=-1,this._pendingNodeId!==null&&(wr(this._pendingNodeId,this),this._pendingNodeId=null),gr(this._lazyRef))){const t=this._lazyRef.storage;lt.markUnreachable(t.id)}}get disposed(){return this._disposed}};let Ro=1;function ie(){return Ro++}const Po=10*1024*1024*1024;var Fo=class extends Error{constructor(e,t,r){super(`GPU memory limit exceeded: requested ${yr(e)}, current usage ${yr(t)}, limit ${yr(r)}`),this.requestedBytes=e,this.currentBytes=t,this.limitBytes=r,this.name="GPUMemoryLimitExceededError"}};function yr(e){return e>=1024*1024*1024?`${(e/(1024*1024*1024)).toFixed(2)}GB`:e>=1024*1024?`${(e/(1024*1024)).toFixed(2)}MB`:e>=1024?`${(e/1024).toFixed(2)}KB`:`${e}B`}var Lo=class{memoryLimitBytes=Po;currentAllocatedBytes=0;bufferSizes=new Map;allocationCount=0;peakUsageBytes=0;getMemoryLimit(){return this.memoryLimitBytes}setMemoryLimit(e){if(e<=0)throw new Error("Memory limit must be positive");this.memoryLimitBytes=e}getCurrentAllocatedBytes(){return this.currentAllocatedBytes}getPeakUsageBytes(){return this.peakUsageBytes}getUsagePercent(){return this.currentAllocatedBytes/this.memoryLimitBytes*100}getAllocationCount(){return this.allocationCount}trackAllocation(e,t){if(this.currentAllocatedBytes+t>this.memoryLimitBytes)throw new Fo(t,this.currentAllocatedBytes,this.memoryLimitBytes);this.bufferSizes.set(e,t),this.currentAllocatedBytes+=t,this.allocationCount++,this.currentAllocatedBytes>this.peakUsageBytes&&(this.peakUsageBytes=this.currentAllocatedBytes)}trackDeallocation(e){const t=this.bufferSizes.get(e);t!==void 0&&(this.currentAllocatedBytes-=t,this.bufferSizes.delete(e),this.allocationCount--)}wouldExceedLimit(e){return this.currentAllocatedBytes+e>this.memoryLimitBytes}stats(){return{currentBytes:this.currentAllocatedBytes,peakBytes:this.peakUsageBytes,limitBytes:this.memoryLimitBytes,usagePercent:this.getUsagePercent(),allocationCount:this.allocationCount,availableBytes:this.memoryLimitBytes-this.currentAllocatedBytes}}reset(){this.currentAllocatedBytes=0,this.bufferSizes.clear(),this.allocationCount=0,this.peakUsageBytes=0}};const vs=new Lo;function Ms(e){vs.setMemoryLimit(e)}function No(){return vs.getMemoryLimit()}function qo(){return vs.stats()}function Ds(e){if(e.length===0)return[];const t=new Array(e.length);let r=1;for(let s=e.length-1;s>=0;s--)t[s]=r,r*=e[s];return t}const Go=256;function Uo(e){const t=Math.max(e,Go);return Math.ceil(Math.log2(t))}function Oo(e){return Math.pow(2,e)}function Rn(e,t){return e.reduce((r,s)=>r*s,1)*(t==="f32"||t==="i32"?4:t==="f16"?2:1)}function Pn(e,t,r,s){const n=new Map,i=new Map;e.forEach((o,u)=>{i.set(o,u)});for(const o of e)n.set(o,{nodeId:o,firstUse:i.get(o),lastUse:i.get(o),isOutput:r.has(o),isInput:!t.has(o)||t.get(o).length===0,bufferSize:s.get(o)??0});for(const[o,u]of t){const l=i.get(o);for(const d of u){const c=n.get(d);c&&l>c.lastUse&&(c.lastUse=l)}}const a=e.length-1;for(const o of r){const u=n.get(o);u&&(u.lastUse=a)}return n}function Vo(e,t){const r=[];for(const[s,n]of e)n.lastUse<t&&!n.isOutput&&r.push(s);return r}function Fn(e,t,r){const s=new Map,n=new Set;for(let i=0;i<e.length;i++){const a=e[i],o=r.get(a)??0;if(o===0)continue;const u=Vo(t,i).filter(l=>!n.has(l)).map(l=>({id:l,lifetime:t.get(l)})).filter(l=>l.lifetime.bufferSize>=o).sort((l,d)=>l.lifetime.bufferSize-d.lifetime.bufferSize);if(u.length>0){const l=u[0];s.set(a,l.id),n.add(l.id)}}return s}const jo=10*1024*1024*1024;var Wo=class extends Error{constructor(e,t,r){super(`Memory limit exceeded: requested ${br(e)}, current usage ${br(t)}, limit ${br(r)}`),this.requestedBytes=e,this.currentBytes=t,this.limitBytes=r,this.name="MemoryLimitExceededError"}};function br(e){return e>=1024*1024*1024?`${(e/(1024*1024*1024)).toFixed(2)}GB`:e>=1024*1024?`${(e/(1024*1024)).toFixed(2)}MB`:e>=1024?`${(e/1024).toFixed(2)}KB`:`${e}B`}var Ho=class{pools=new Map;bufferInfo=new Map;nextBufferId=1;nextFenceId=1;memoryLimitBytes;currentAllocatedBytes=0;constructor(e){this.memoryLimitBytes=e?.memoryLimitBytes??jo}getMemoryLimit(){return this.memoryLimitBytes}setMemoryLimit(e){if(e<=0)throw new Error("Memory limit must be positive");this.memoryLimitBytes=e}getCurrentAllocatedBytes(){return this.currentAllocatedBytes}allocate(e,t,r){const s=Uo(e),n=this.pools.get(s)??[];for(let o=0;o<n.length;o++){const u=n[o],l=this.bufferInfo.get(u);if(l&&l.inUseByPlan===null&&l.fenceId===null)return n.splice(o,1),l.lastUsedAt=Date.now(),l.dtype=t,l.shape=r.slice(),l}const i=Oo(s);if(this.currentAllocatedBytes+i>this.memoryLimitBytes)throw new Wo(i,this.currentAllocatedBytes,this.memoryLimitBytes);const a={id:this.nextBufferId++,sizeBytes:i,sizeClass:s,dtype:t,shape:r.slice(),createdAt:Date.now(),lastUsedAt:Date.now(),inUseByPlan:null,fenceId:null};return this.bufferInfo.set(a.id,a),this.currentAllocatedBytes+=i,a}markInUse(e,t){const r=this.bufferInfo.get(e);r&&(r.inUseByPlan=t,r.lastUsedAt=Date.now())}markPendingFence(e,t){const r=this.bufferInfo.get(e);if(r){const s=t??this.nextFenceId++;return r.fenceId=s,r.inUseByPlan=null,s}return-1}signalFence(e){for(const[t,r]of this.bufferInfo)if(r.fenceId===e){r.fenceId=null;const s=this.pools.get(r.sizeClass)??[];s.push(t),this.pools.set(r.sizeClass,s)}}release(e){const t=this.bufferInfo.get(e);if(t&&(t.inUseByPlan=null,t.fenceId===null)){const r=this.pools.get(t.sizeClass)??[];r.push(e),this.pools.set(t.sizeClass,r)}}getInfo(e){return this.bufferInfo.get(e)}stats(){let e=0,t=0;for(const i of this.pools.values()){e+=i.length;for(const a of i)t+=this.bufferInfo.get(a)?.sizeBytes??0}let r=0,s=0,n=0;for(const i of this.bufferInfo.values())n+=i.sizeBytes,i.inUseByPlan!==null&&r++,i.fenceId!==null&&s++;return{totalBuffers:this.bufferInfo.size,pooledBuffers:e,inUseBuffers:r,pendingFenceBuffers:s,totalBytes:n,pooledBytes:t,memoryLimitBytes:this.memoryLimitBytes,memoryUsagePercent:this.currentAllocatedBytes/this.memoryLimitBytes*100}}clear(){this.pools.clear(),this.bufferInfo.clear(),this.nextBufferId=1,this.nextFenceId=1,this.currentAllocatedBytes=0}},Ko=class{plans=new Map;nextPlanId=1;bufferPool;constructor(e){this.bufferPool=e}registerPlan(e,t,r){const s=this.nextPlanId++,n={id:s,inputBuffers:e.slice(),outputBuffers:t.slice(),intermediateBuffers:r.slice(),startedAt:Date.now(),completedAt:null,fenceId:null};this.plans.set(s,n);for(const i of[...e,...t,...r])this.bufferPool.markInUse(i,s);return s}completePlan(e,t){const r=this.plans.get(e);if(!r)return;r.completedAt=Date.now(),r.fenceId=t??null;for(const n of r.intermediateBuffers)t!==void 0?this.bufferPool.markPendingFence(n,t):this.bufferPool.release(n);const s=new Set(r.outputBuffers);for(const n of r.inputBuffers)s.has(n)||(t!==void 0?this.bufferPool.markPendingFence(n,t):this.bufferPool.release(n))}signalFence(e){this.bufferPool.signalFence(e)}getPlan(e){return this.plans.get(e)}getActivePlans(){return Array.from(this.plans.values()).filter(e=>e.completedAt===null)}isBufferInUse(e){for(const t of this.plans.values())if(t.completedAt===null&&(t.inputBuffers.includes(e)||t.outputBuffers.includes(e)||t.intermediateBuffers.includes(e)))return!0;return!1}cleanup(e=6e4){const t=Date.now();let r=0;for(const[s,n]of this.plans)n.completedAt!==null&&t-n.completedAt>=e&&(this.plans.delete(s),r++);return r}stats(){let e=0,t=0;for(const r of this.plans.values())r.completedAt===null?e++:t++;return{totalPlans:this.plans.size,activePlans:e,completedPlans:t}}},Yo=class{bufferPool;planManager;constructor(e){this.bufferPool=new Ho({memoryLimitBytes:e?.memoryLimitBytes}),this.planManager=new Ko(this.bufferPool)}getMemoryLimit(){return this.bufferPool.getMemoryLimit()}setMemoryLimit(e){this.bufferPool.setMemoryLimit(e)}getCurrentAllocatedBytes(){return this.bufferPool.getCurrentAllocatedBytes()}planExecution(e,t,r,s,n){const i=new Map;for(const h of e){const f=s.get(h)??[1],w=n.get(h)??"f32";i.set(h,Rn(f,w))}const a=Fn(e,Pn(e,t,new Set(r),i),i),o=new Map;let u=0,l=0,d=0,c=0;for(const h of e){const f=s.get(h)??[1],w=n.get(h)??"f32",m=i.get(h)??0,p=a.get(h);if(p!==void 0){const b=o.get(p);if(b!==void 0){o.set(h,b),l+=m,c++;continue}}const g=this.bufferPool.allocate(m,w,f);o.set(h,g.id),u+=g.sizeBytes,d++}return{allocations:o,donations:a,totalAllocatedBytes:u,reusedBytes:l,newAllocations:d,reusedAllocations:c}}registerExecution(e,t){const r=Array.from(new Set(e.allocations.values())),s=t.map(i=>e.allocations.get(i)).filter(i=>i!==void 0),n=r.filter(i=>!s.includes(i));return this.planManager.registerPlan([],s,n)}completeExecution(e,t){this.planManager.completePlan(e,t)}signalFence(e){this.planManager.signalFence(e)}getBufferPool(){return this.bufferPool}getPlanManager(){return this.planManager}stats(){return{bufferPool:this.bufferPool.stats(),planManager:this.planManager.stats()}}clear(){this.bufferPool.clear()}};function Qo(e,t){return null}let zt=null,Ln=10*1024*1024*1024;function Zo(e){if(e<=0)throw new Error("Memory limit must be positive");Ln=e,zt&&zt.setMemoryLimit(e)}function _s(){return zt||(zt=new Yo({memoryLimitBytes:Ln})),zt}function Nn(e){const t=[],r=new Map,s=new Map,n=new Map;for(const i of e.nodes){t.push(i.id),s.set(i.id,i.shape),n.set(i.id,i.dtype);const a=[];for(const o of i.inputs)o.kind==="pending"&&a.push(o.node.id);r.set(i.id,a)}return{nodeOrder:t,nodeInputs:r,nodeShapes:s,nodeDtypes:n,outputNodeId:e.nodes[e.nodes.length-1].id}}function Xo(e){const t=_s(),{nodeOrder:r,nodeInputs:s,nodeShapes:n,nodeDtypes:i,outputNodeId:a}=Nn(e),o=t.planExecution(r,s,[a],n,i),u=new Map;for(const d of r){const c=n.get(d)??[1],h=i.get(d)??"f32";u.set(d,Rn(c,h))}const l=Pn(r,s,new Set([a]),u);return{memoryPlan:o,lifetimes:l,donations:Fn(r,l,u)}}function Jo(e){if(e.kind==="materialized")return e.storage;if(e.node.result)return e.node.result;throw new Error("Input not ready")}async function eu(e,t,r){const s=r?.enableDonation??!0;if(e.nodes.length===0)throw new Error("Cannot execute empty plan");const n=_s(),{memoryPlan:i,donations:a}=Xo(e),{outputNodeId:o}=Nn(e),u=n.registerExecution(i,[o]),l=new Map,d=new Set;for(const f of e.nodes){const w=f.inputs.map(Jo),m=w.map(y=>y.backendTensor),p=je(f.device)??t;let g,b=null;if(s){const y=a.get(f.id);if(y!==void 0&&!d.has(y)){const x=l.get(y);x&&(b=Qo(x.backendTensor,f.device),b&&d.add(y))}}const v=b?{outBuffer:b}:void 0;switch(f.op){case"tensorFromArray":{const y=f.payload;if(!y?.values)throw new Error("tensorFromArray requires values in payload");g=p.ops.tensorFromArray(y.values,f.shape);break}case"add":g=p.ops.add(m[0],m[1],v);break;case"sub":{const y=f.payload;g=p.ops.sub(m[0],m[1],{...y,...v});break}case"mul":g=p.ops.mul(m[0],m[1],v);break;case"div":{const y=f.payload;g=p.ops.div(m[0],m[1],{...y,...v});break}case"matmul":g=p.ops.matmul(m[0],m[1],v);break;case"sqrt":g=p.ops.sqrt(m[0],v);break;case"relu":g=p.ops.relu(m[0],v);break;case"exp":if(!p.ops.exp)throw new Error("exp not supported by backend");g=p.ops.exp(m[0],v);break;case"log":if(!p.ops.log)throw new Error("log not supported by backend");g=p.ops.log(m[0],v);break;case"neg":if(!p.ops.neg)throw new Error("neg not supported by backend");g=p.ops.neg(m[0],v);break;case"abs":if(!p.ops.abs)throw new Error("abs not supported by backend");g=p.ops.abs(m[0],v);break;case"tanh":if(!p.ops.tanh)throw new Error("tanh not supported by backend");g=p.ops.tanh(m[0],v);break;case"sigmoid":if(!p.ops.sigmoid)throw new Error("sigmoid not supported by backend");g=p.ops.sigmoid(m[0],v);break;case"gelu":if(!p.ops.gelu)throw new Error("gelu not supported by backend");g=p.ops.gelu(m[0],v);break;case"silu":if(!p.ops.silu)throw new Error("silu not supported by backend");g=p.ops.silu(m[0],v);break;case"reshape":{const y=f.payload?.targetShape??f.shape;g=p.ops.reshape(m[0],y);break}case"expand":g=p.ops.expand(m[0],f.shape);break;case"transpose":{const y=f.payload;if(!y)throw new Error("transpose requires dim0 and dim1 in payload");g=p.ops.transpose(m[0],y);break}case"permute":{const y=f.payload;if(!y)throw new Error("permute requires dims in payload");g=p.ops.permute(m[0],y.dims);break}case"contiguous":g=p.ops.contiguous(m[0]);break;case"cast":{const y=f.payload;if(!y)throw new Error("cast requires dtype in payload");if(!p.ops.cast)throw new Error("cast not supported by backend");g=p.ops.cast(m[0],y.dtype);break}case"gather":{const y=f.payload;if(!y)throw new Error("gather requires dim in payload");g=p.ops.gather(m[0],m[1],y);break}case"scatterAdd":{const y=f.payload;if(!y)throw new Error("scatterAdd requires dim in payload");g=p.ops.scatterAdd(m[0],m[1],m[2],y);break}case"sum":{const y=f.payload;g=p.ops.sum(m[0],y);break}case"max":{const y=f.payload;g=p.ops.max(m[0],y);break}case"mean":{const y=f.payload;g=p.ops.mean(m[0],y);break}case"argmax":{const y=f.payload;if(!p.ops.argmax)throw new Error("argmax not supported by backend");g=p.ops.argmax(m[0],y);break}case"argmin":{const y=f.payload;if(!p.ops.argmin)throw new Error("argmin not supported by backend");g=p.ops.argmin(m[0],y);break}case"gt":if(!p.ops.gt)throw new Error("gt not supported by backend");g=p.ops.gt(m[0],m[1],v);break;case"lt":if(!p.ops.lt)throw new Error("lt not supported by backend");g=p.ops.lt(m[0],m[1],v);break;case"ge":if(!p.ops.ge)throw new Error("ge not supported by backend");g=p.ops.ge(m[0],m[1],v);break;case"le":if(!p.ops.le)throw new Error("le not supported by backend");g=p.ops.le(m[0],m[1],v);break;case"eq":if(!p.ops.eq)throw new Error("eq not supported by backend");g=p.ops.eq(m[0],m[1],v);break;case"ne":if(!p.ops.ne)throw new Error("ne not supported by backend");g=p.ops.ne(m[0],m[1],v);break;case"where":g=p.ops.where(m[0],m[1],m[2],v);break;case"stridedScatterCopy":{const y=f.payload;if(!y)throw new Error("stridedScatterCopy requires options in payload");g=p.ops.stridedScatterCopy(m[0],m[1],y);break}case"stridedScatterAdd":{const y=f.payload;if(!y)throw new Error("stridedScatterAdd requires options in payload");g=p.ops.stridedScatterAdd(m[0],m[1],y);break}case"transfer":{const y=w[0],x=f.device,z=y.device;if(z===x)g=y.backendTensor;else{const M=je(x);if(!M)throw new Error(`Transfer failed: backend not available for ${x}`);const D=je(z);if(!D)throw new Error(`Transfer failed: backend not available for ${z}`);const B=await D.ops.read(y.backendTensor);g=M.ops.tensorFromArray(B,f.shape)}break}default:throw new Error(`Unknown op: ${f.op}`)}const k=ir(f.device,g);f.result=k,l.set(f.id,k)}n.completeExecution(u);const c=e.nodes[e.nodes.length-1];if(!c.result)throw new Error("Execution failed: no result for last node");l.clear();const h={totalNodes:e.nodes.length,totalAllocatedBytes:i.totalAllocatedBytes,reusedBytes:i.reusedBytes,newAllocations:i.newAllocations,reusedAllocations:i.reusedAllocations,donationCount:d.size};return{result:c.result,stats:h,planId:u}}function tu(){return _s().stats()}var qn=class{defaultDevice=null;memoryPlanningEnabled=!1;donationEnabled=!0;trackStats=!1;lastStats=null;fusionEnabled=!1;vectorizationEnabled=!0;lastFusionStats=null;constructor(e,t){e&&(this.defaultDevice=e),t?.enableMemoryPlanning&&(this.memoryPlanningEnabled=!0),t?.enableDonation!==void 0&&(this.donationEnabled=t.enableDonation),t?.trackStats&&(this.trackStats=!0),t?.enableFusion!==void 0&&(this.fusionEnabled=t.enableFusion),t?.enableVectorization!==void 0&&(this.vectorizationEnabled=t.enableVectorization)}setMemoryPlanning(e){this.memoryPlanningEnabled=e}isMemoryPlanningEnabled(){return this.memoryPlanningEnabled}getLastMemoryStats(){return this.lastStats}getMemoryPlannerStats(){return tu()}setFusionEnabled(e){this.fusionEnabled=e}isFusionEnabled(){return this.fusionEnabled}setVectorizationEnabled(e){this.vectorizationEnabled=e}isVectorizationEnabled(){return this.vectorizationEnabled}getLastFusionStats(){return this.lastFusionStats}setBackend(e){const t=je(e);if(!t)throw new Error(`Unknown backend: ${e}`);return this.defaultDevice=e,t}get currentDefaultDevice(){return this.defaultDevice??mr().name}getBackend(e){const t=e??this.defaultDevice??mr().name,r=je(t);if(!r)throw new Error(`Unknown backend: ${t}`);return r}getDevice(e){return e??this.defaultDevice??mr().name}assertSameDevice(...e){const t=e[0]?.device;if(!t)throw new Error("Missing tensor device");for(const r of e)if(r.device!==t)throw new Error("Tensors must be on the same device");return t}ensureSameDevice(...e){if(e.length===0)return{tensors:[],device:this.getDevice()};let t=e[0].device;for(const s of e)if(s.device==="webgpu"){t="webgpu";break}const r=[];for(const s of e)s.device!==t?r.push(this.transfer(s,t)):r.push(s);return{tensors:r,device:t}}async force(e){if(e.isMaterialized())return;const t=e.lazyRef;if(t.kind!=="pending")return;const r=xo(t.node),s=this.getBackend(e.device);let n;if(this.memoryPlanningEnabled){const i=await eu(r,s,{enableDonation:this.donationEnabled,trackStats:this.trackStats});n=i.result,this.lastStats=i.stats}else if(this.fusionEnabled){const i=await $o(r,s,{enableFusion:!0,enableVectorization:this.vectorizationEnabled});n=i.result,this.lastFusionStats=i.stats}else n=await Mn(r,s);for(const i of r.nodes)i.result&&Mo(i.id,i.result);e.isMaterialized()||e._materialize(n)}async forceAll(...e){const t=[],r=new Map;for(const s of e){if(s.isMaterialized())continue;const n=s.lazyRef;n.kind==="pending"&&(t.push(n.node),r.set(s,n.node))}if(t.length!==0)for(const s of e)await this.force(s)}async forceAllPending(){const{getAllPendingTensors:e}=await Ft(async()=>{const{getAllPendingTensors:r}=await Promise.resolve().then(()=>Hp);return{getAllPendingTensors:r}},void 0,import.meta.url),t=e();if(t.length!==0)for(const r of t)await this.force(r)}tensorFromArray(e,t,r){const s=this.getDevice(r),n=Z(X("tensorFromArray",[],t,"f32",s,{values:e.slice()}));return new te(ie(),n,t,s)}add(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("add",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}sub(e,t,r){const s=this.assertSameDevice(e,t),n=Te(e.shape,t.shape),i=X("sub",[e.lazyRef,t.lazyRef],n,"f32",s,r);return new te(ie(),Z(i),n,s)}div(e,t,r){const s=this.assertSameDevice(e,t),n=Te(e.shape,t.shape),i=X("div",[e.lazyRef,t.lazyRef],n,"f32",s,r);return new te(ie(),Z(i),n,s)}mul(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("mul",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}view(e,t){const r=X("reshape",[e.lazyRef],t,"f32",e.device,{targetShape:t});return new te(e.baseId,Z(r),t,e.device)}reshape(e,t){const r=X("reshape",[e.lazyRef],t,"f32",e.device,{targetShape:t});return new te(e.baseId,Z(r),t,e.device)}matmul(e,t){const r=this.assertSameDevice(e,t),s=ru(e.shape,t.shape),n=X("matmul",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}sqrt(e){const t=X("sqrt",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}relu(e){const t=X("relu",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}exp(e){const t=X("exp",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}log(e){const t=X("log",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}neg(e){const t=X("neg",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}abs(e){const t=X("abs",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}tanh(e){const t=X("tanh",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}sigmoid(e){const t=X("sigmoid",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}gelu(e,t){const r=X("gelu",[e.lazyRef],e.shape.slice(),"f32",e.device,t);return new te(ie(),Z(r),e.shape.slice(),e.device)}silu(e){const t=X("silu",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}isfinite(e){const t=X("isfinite",[e.lazyRef],e.shape.slice(),"f32",e.device);return new te(ie(),Z(t),e.shape.slice(),e.device)}expand(e,t){const r=X("expand",[e.lazyRef],t,"f32",e.device,{targetShape:t});return new te(e.baseId,Z(r),t,e.device)}transpose(e,t){const r=su(e.shape,t),s=X("transpose",[e.lazyRef],r,"f32",e.device,t);return new te(e.baseId,Z(s),r,e.device)}permute(e,t){const r=e.shape.length;if(t.length!==r)throw new Error(`permute: dims length ${t.length} doesn't match tensor rank ${r}`);const s=new Set;for(const o of t){const u=o<0?o+r:o;if(u<0||u>=r)throw new Error(`permute: dimension ${o} out of range for rank ${r}`);if(s.has(u))throw new Error(`permute: duplicate dimension ${o}`);s.add(u)}const n=t.map(o=>o<0?o+r:o),i=n.map(o=>e.shape[o]),a=X("permute",[e.lazyRef],i,"f32",e.device,{dims:n});return new te(e.baseId,Z(a),i,e.device)}contiguous(e){const t=X("contiguous",[e.lazyRef],e.shape,"f32",e.device,void 0);return new te(ie(),Z(t),e.shape,e.device)}cast(e,t){const r=X("cast",[e.lazyRef],e.shape,t,e.device,{dtype:t});return new te(ie(),Z(r),e.shape,e.device)}gather(e,t,r){const s=this.assertSameDevice(e,t),n=t.shape.slice(),i=X("gather",[e.lazyRef,t.lazyRef],n,"f32",s,r);return new te(ie(),Z(i),n,s)}scatterAdd(e,t,r,s){const n=this.assertSameDevice(e,t,r),i=e.shape.slice(),a=X("scatterAdd",[e.lazyRef,t.lazyRef,r.lazyRef],i,"f32",n,s);return new te(ie(),Z(a),i,n)}sum(e,t){const r=vr(e.shape,t?.dim,t?.keepdim??!1),s=X("sum",[e.lazyRef],r,"f32",e.device,t);return new te(ie(),Z(s),r,e.device)}max(e,t){const r=vr(e.shape,t?.dim,t?.keepdim??!1),s=X("max",[e.lazyRef],r,"f32",e.device,t);return new te(ie(),Z(s),r,e.device)}mean(e,t){const r=vr(e.shape,t?.dim,t?.keepdim??!1),s=X("mean",[e.lazyRef],r,"f32",e.device,t);return new te(ie(),Z(s),r,e.device)}argmax(e,t){const r=t.dim<0?e.shape.length+t.dim:t.dim,s=t.keepdim?e.shape.map((i,a)=>a===r?1:i):e.shape.filter((i,a)=>a!==r),n=X("argmax",[e.lazyRef],s,"f32",e.device,{dim:r,keepdim:t.keepdim});return new te(ie(),Z(n),s,e.device)}argmin(e,t){const r=t.dim<0?e.shape.length+t.dim:t.dim,s=t.keepdim?e.shape.map((i,a)=>a===r?1:i):e.shape.filter((i,a)=>a!==r),n=X("argmin",[e.lazyRef],s,"f32",e.device,{dim:r,keepdim:t.keepdim});return new te(ie(),Z(n),s,e.device)}gt(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("gt",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}lt(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("lt",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}ge(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("ge",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}le(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("le",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}eq(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("eq",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}ne(e,t){const r=this.assertSameDevice(e,t),s=Te(e.shape,t.shape),n=X("ne",[e.lazyRef,t.lazyRef],s,"f32",r);return new te(ie(),Z(n),s,r)}where(e,t,r){const s=this.assertSameDevice(e,t,r),n=nu(e.shape,t.shape,r.shape),i=X("where",[e.lazyRef,t.lazyRef,r.lazyRef],n,"f32",s);return new te(ie(),Z(i),n,s)}async cpu(e){return await this.force(e),this.getBackend(e.device).ops.read(e.backendTensor)}async item(e){const t=await this.cpu(e);if(t.length!==1)throw new Error("item() requires a single-element tensor");return t[0]}transfer(e,t){if(e.device===t)return e;const r=X("transfer",[e.lazyRef],e.shape.slice(),"f32",t,{sourceDevice:e.device});return new te(ie(),Z(r),e.shape.slice(),t)}async transferNow(e,t){if(e.device===t)return e;const r=this.transfer(e,t);return await this.force(r),r}copy_(e,t){if(this.assertSameDevice(e,t),e.shape.length!==t.shape.length)throw new Error(`copy_: shape mismatch - dst has rank ${e.shape.length}, src has rank ${t.shape.length}`);for(let i=0;i<e.shape.length;i++)if(e.shape[i]!==t.shape[i])throw new Error(`copy_: shape mismatch at dim ${i} - dst has ${e.shape[i]}, src has ${t.shape[i]}`);const r=Ds(e.shape),s={offset:0,viewShape:e.shape.slice(),viewStrides:r},n=X("stridedScatterCopy",[e.lazyRef,t.lazyRef],e.shape,"f32",e.device,s);return e._updateLazyRef(Z(n)),e}add_(e,t){if(this.assertSameDevice(e,t),e.shape.length!==t.shape.length)throw new Error(`add_: shape mismatch - dst has rank ${e.shape.length}, src has rank ${t.shape.length}`);for(let i=0;i<e.shape.length;i++)if(e.shape[i]!==t.shape[i])throw new Error(`add_: shape mismatch at dim ${i} - dst has ${e.shape[i]}, src has ${t.shape[i]}`);const r=Ds(e.shape),s={offset:0,viewShape:e.shape.slice(),viewStrides:r},n=X("stridedScatterAdd",[e.lazyRef,t.lazyRef],e.shape,"f32",e.device,s);return e._updateLazyRef(Z(n)),e}zero_(e){const t=e.shape.reduce((n,i)=>n*i,1),r=new Array(t).fill(0),s=this.tensorFromArray(r,e.shape,e.device);return this.copy_(e,s)}fill_(e,t){const r=e.shape.reduce((i,a)=>i*a,1),s=new Array(r).fill(t),n=this.tensorFromArray(s,e.shape,e.device);return this.copy_(e,n)}mul_(e,t){const r=this.mul(e,this.tensorFromArray([t],[],e.device));return this.copy_(e,r)}};new qn;function Te(e,t){const r=Math.max(e.length,t.length),s=new Array(r);for(let n=0;n<r;n++){const i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw new Error(`Cannot broadcast shapes [${e}] and [${t}]`);s[r-1-n]=Math.max(i,a)}return s}function ru(e,t){if(e.length<1||t.length<1)throw new Error("matmul requires at least 1D tensors");if(e.length===1&&t.length===1)return[];if(e.length===1)return[...t.slice(0,-2),t[t.length-1]];if(t.length===1)return e.slice(0,-1);const r=e[e.length-2],s=t[t.length-1];return[...Te(e.slice(0,-2),t.slice(0,-2)),r,s]}function su(e,t){const{dim0:r,dim1:s}=t,n=e.slice(),i=n[r];return n[r]=n[s],n[s]=i,n}function vr(e,t,r){if(t==null)return r?e.map(()=>1):[];const s=(Array.isArray(t)?t:[t]).map(n=>n<0?e.length+n:n);return r?e.map((n,i)=>s.includes(i)?1:n):e.filter((n,i)=>!s.includes(i))}function nu(e,t,r){const s=Math.max(e.length,t.length,r.length),n=new Array(s);for(let i=0;i<s;i++){const a=e[e.length-1-i]??1,o=t[t.length-1-i]??1,u=r[r.length-1-i]??1;if(a!==o&&a!==1&&o!==1)throw new Error(`Cannot broadcast shapes [${e}], [${t}], and [${r}]`);if(a!==u&&a!==1&&u!==1)throw new Error(`Cannot broadcast shapes [${e}], [${t}], and [${r}]`);if(o!==u&&o!==1&&u!==1)throw new Error(`Cannot broadcast shapes [${e}], [${t}], and [${r}]`);n[s-1-i]=Math.max(a,o,u)}return n}function iu(e){const t=new Map;for(let s=0;s<e.nodes.length;s++)t.set(e.nodes[s].id,s);const r=[];for(const s of e.nodes){const n=s.inputs.map(u=>{const l=t.get(u);return l!==void 0?`n${l}`:`ext${u}`}),i=s.shape?s.shape.join("x"):"?",a=s.dtype??"?",o=`${s.op}[${n.join(",")}](${i},${a})`;r.push(o)}for(const s of e.fusionGroups){const n=s.nodeIds.map(i=>t.get(i)??-1);r.push(`fuse:${s.kind}[${n.join(",")}]`)}return au(r.join("|"))}function au(e){let t=5381;for(let r=0;r<e.length;r++)t=t*33^e.charCodeAt(r);return(t>>>0).toString(16).padStart(8,"0")}function ou(e){const t=new Set(e.nodes.map(s=>s.id)),r=[];for(const s of e.nodes){const n=s.inputs.some(i=>!t.has(i));r.push({shape:s.shape?.slice()??[],dtype:s.dtype??"f32",isInput:n||s.inputs.length===0})}return r}function uu(e){return{irHash:iu(e),inputSignatures:ou(e)}}function _r(e){const t=e.inputSignatures.map(r=>`${r.shape.join("x")}:${r.dtype}:${r.isInput?"i":"c"}`);return`${e.irHash}|${t.join(";")}`}var lu=class{cache=new Map;maxSize;constructor(e=64){this.maxSize=e}get(e){const t=_r(e),r=this.cache.get(t);return r&&(r.hitCount++,this.cache.delete(t),this.cache.set(t,r)),r}set(e,t){const r=_r(e);for(;this.cache.size>=this.maxSize;){const n=this.cache.keys().next().value;n&&this.cache.delete(n)}const s={key:e,graph:t,createdAt:Date.now(),hitCount:0};return this.cache.set(r,s),s}has(e){return this.cache.has(_r(e))}get size(){return this.cache.size}clear(){this.cache.clear()}stats(){const e=Array.from(this.cache.entries()).map(([t,r])=>({key:t,hitCount:r.hitCount}));return{size:this.cache.size,entries:e}}};const Gn=new Set(["matmul","linear","conv1d","conv2d","conv3d","bmm","addmm"]),Un=new Set(["sum","mean","softmax","log_softmax","layer_norm","batch_norm","group_norm","exp","log","pow","loss","cross_entropy","mse_loss"]),Vr={enabled:!0,computeDtype:"f16",accumulateDtype:"f32",memoryDtype:"f32",reductionDtype:"f32"},On={enabled:!1,computeDtype:"f32",accumulateDtype:"f32",memoryDtype:"f32",reductionDtype:"f32"};function du(){return{configStack:[],current:{enabled:!1,policy:On,deviceType:"cpu"}}}function Rs(e,t){const r={enabled:t.enabled??!0,policy:t.policy??Vr,deviceType:t.deviceType??e.current.deviceType};e.configStack.push(r),e.current=r}function Ps(e){e.configStack.pop(),e.current=e.configStack.length>0?e.configStack[e.configStack.length-1]:{enabled:!1,policy:On,deviceType:"cpu"}}function cu(e,t,r){if(!r.current.enabled)return{outputDtype:t[0]??"f32",needsCast:!1,isGated:!1};const s=r.current.policy;if(Un.has(e)){const a=t.some(o=>o==="f16");return{outputDtype:"f32",needsCast:a,sourceDtype:a?"f16":void 0,isGated:!0}}if(Gn.has(e)){const a=t.some(o=>o==="f32");return{outputDtype:s.computeDtype,needsCast:a&&s.computeDtype==="f16",sourceDtype:a?"f32":void 0,isGated:!0}}const n=t.some(a=>a==="f16"),i=t.some(a=>a==="f32");return n&&i?{outputDtype:s.memoryDtype,needsCast:!0,sourceDtype:s.memoryDtype==="f32"?"f16":"f32",isGated:!0}:{outputDtype:t[0]??"f32",needsCast:!1,isGated:r.current.enabled}}function hu(e){return e.enabled?`${e.computeDtype}:${e.accumulateDtype}:${e.memoryDtype}`:"disabled"}function pu(e,t){if(!t.current.enabled)return{graph:e,castsInserted:0,nodeIdMap:new Map,modified:!1};const r=t.current.policy,s=[],n=new Map;let i=Math.max(...e.nodes.map(l=>l.id))+1,a=0;const o=new Map;for(const l of e.nodes)if(l.inputs.length>0){const d=fu(l,l.inputs.map(c=>e.nodes.find(h=>h.id===c)?.dtype??"f32"),r);d.length>0&&o.set(l.id,d)}const u=new Map;for(const l of e.nodes){const d=o.get(l.id);if(d)for(const m of d){const p={id:i++,op:"cast",epoch:l.epoch,kind:"lazy_op",inputs:[m.inputNodeId],shape:m.shape.slice(),dtype:m.toDtype};s.push(p),u.set(m.inputNodeId,p.id),a++}const c=l.inputs.map(m=>u.get(m)??m),h=c.map(m=>{const p=s.find(g=>g.id===m);return p?p.dtype??"f32":e.nodes.find(g=>g.id===m)?.dtype??"f32"}),f=cu(l.op,h,t),w={...l,inputs:c,dtype:f.outputDtype};s.push(w),n.set(l.id,w.id);for(const m of d??[])u.delete(m.inputNodeId)}return{graph:{...e,nodes:s},castsInserted:a,nodeIdMap:n,modified:a>0}}function fu(e,t,r){if(!r.enabled)return[];const s=[],n=e.op;if(Gn.has(n)&&r.computeDtype==="f16"){for(let i=0;i<e.inputs.length;i++)if(t[i]==="f32"){const a=e.shape?.slice()??[];s.push({inputNodeId:e.inputs[i],fromDtype:"f32",toDtype:"f16",shape:a})}}if(Un.has(n)){for(let i=0;i<e.inputs.length;i++)if(t[i]==="f16"){const a=e.shape?.slice()??[];s.push({inputNodeId:e.inputs[i],fromDtype:"f16",toDtype:"f32",shape:a})}}return s}const mu=new Set(["add","sub","mul","div","neg","abs","exp","log","relu","sqrt"]);function Fs(e){return mu.has(e)}function gu(e,t){const r=Math.max(e.length,t.length),s=new Array(r);for(let n=0;n<r;n+=1){const i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw new Error("compile ir shape mismatch: not broadcastable");s[r-1-n]=Math.max(i,a)}return s}function wu(e,t){if(t.length===0)throw new Error(`compile ir cannot infer shape for op ${e}`);const r=t[0].shape;if(!r)throw new Error(`compile ir missing input shape for op ${e}`);if(t.length===1)return r.slice();let s=r.slice();for(let n=1;n<t.length;n+=1){const i=t[n].shape;if(!i)throw new Error(`compile ir missing input shape for op ${e}`);s=gu(s,i)}return s}function yu(e,t){if(t.length===0)throw new Error(`compile ir cannot infer dtype for op ${e}`);const r=t[0].dtype;if(!r)throw new Error(`compile ir missing input dtype for op ${e}`);for(const s of t){if(!s.dtype)throw new Error(`compile ir missing input dtype for op ${e}`);if(s.dtype!==r)throw new Error(`compile ir dtype mismatch for op ${e}`)}return r}function bu(e,t){const r=[],s=new Map;for(const a of e){if(a.type!=="lazy_op"||a.epoch!==t)continue;const o={id:a.traceId,op:a.op,epoch:a.epoch,kind:"lazy_op",inputs:a.inputs?a.inputs.slice():[],shape:a.shape?a.shape.slice():void 0,dtype:a.dtype};r.push(o),s.set(o.id,o)}for(const a of r){if(!Fs(a.op)||a.inputs.length===0)continue;const o=a.inputs.map(u=>{const l=s.get(u);if(!l)throw new Error(`compile ir missing input node ${u}`);return l});a.shape||(a.shape=wu(a.op,o)),a.dtype||(a.dtype=yu(a.op,o))}const n=[];let i=[];for(const a of r){if(Fs(a.op)){i.push(a.id);continue}i.length>1&&n.push({id:n.length,kind:"elementwise",nodeIds:i}),i=[]}return i.length>1&&n.push({id:n.length,kind:"elementwise",nodeIds:i}),{epoch:t,nodes:r,fusionGroups:n}}function vu(e,t){return e.graphInstanceId!==t.graphInstanceId?e.graphInstanceId-t.graphInstanceId:e.callInstanceId!==t.callInstanceId?e.callInstanceId-t.callInstanceId:e.planInstanceId!==t.planInstanceId?e.planInstanceId-t.planInstanceId:e.opNonce!==t.opNonce?e.opNonce-t.opNonce:e.drawNonce!==t.drawNonce?e.drawNonce-t.drawNonce:e.mutId!==t.mutId?e.mutId-t.mutId:e.kind<t.kind?-1:e.kind>t.kind?1:0}function kr(e){const t=e.slice().sort((r,s)=>vu(r.key,s.key));return{orderedEvents:t,eventKeys:t.map(r=>r.key)}}function _u(e){return e.subevents.map(t=>({name:t.kind,key:{graphInstanceId:e.graphInstanceId,callInstanceId:e.callInstanceId,planInstanceId:e.callInstanceId,opNonce:t.opNonce,drawNonce:t.drawNonce??0,mutId:t.mutId??0,kind:t.kind},payload:t.payload}))}function Ls(e){const t=Array.from(new Set(e));return t.sort((r,s)=>r-s),t}function Ns(e){return e.join(",")}var ku=class{nextId=1;joinCache=new Map;root;constructor(){this.root=this.makeToken("root",[0],0),this.nextId=1}createEffectToken(){const e=this.nextId++;return this.makeToken("effect",[e],e)}createTokenOnlyToken(){const e=this.nextId++;return this.makeToken("token_only",[e],e)}createDebugToken(){return this.createEffectToken()}afterAll(e){if(e.length===0)throw new Error("afterAll requires at least one token");const t=Ls(e.flatMap(i=>i.roots)),r=Ns(t);for(const i of e)if(i.key===r)return{token:i,roots:t};const s=this.joinCache.get(r);if(s)return{token:s,roots:t};const n=this.makeToken("join",t,this.nextId++);return this.joinCache.set(r,n),{token:n,roots:t}}makeToken(e,t,r){const s=Ls(t);return{id:r,kind:e,roots:s,key:Ns(s)}}},Su=class{events=[];record(e){this.events.push(e)}snapshot(){return this.events.slice()}},Vn=class{id;baseId;origin;escapes=!1;disposed=!1;onDispose;constructor(e,t,r){this.id=e,this.baseId=t,this.origin=r}},xu=class{tokenStore;tokGlobal;tokLoc=new Map;locState=new Map;baseState=new Map;baseBindings=new Map;finalizeQueue=[];execLock={held:!1,ownerId:0,depth:0};nextOwnerId=1;poisoned=!1;recomputeMode=!1;stagingActive=!1;currentEpoch=0;currentStagingIds=new Set;traceTensorStatus=new Map;lastCompiledGraph=null;lastCacheKey=null;lastCacheHit=!1;compiledCache=new lu;nextTraceTensorId=1;nextSavedTensorId=1;backwardActive=!1;nextTensorId=1;nextBaseId=1;nextScopeId=1;nextMutIdValue=1;tidyScopes=[];basePinCount=new Map;rngBasis={algorithmId:0,seed:0};rngDrawNonce=0;rngCheckpointMode=null;rngCheckpointDraws=[];rngCheckpointIndex=0;nextCheckpointPackId=1;checkpointReachableBases=null;activeCheckpointPackId=null;autocastContext=null;trace;constructor(e=new Su){this.trace=e,this.tokenStore=new ku,this.tokGlobal=this.tokenStore.root}setAutocastContext(e){this.autocastContext=e}getAutocastContext(){return this.autocastContext}afterAll(...e){const{token:t,roots:r}=this.tokenStore.afterAll(e),s=Array.from(new Set(e.map(n=>n.id))).sort((n,i)=>n-i);return this.trace.record({type:"after_all",inputs:s,output:t.id,outputKey:r.join(",")}),t}orderedAccess(e,t="access",r=[]){this.ensureNotPoisoned();const s=this.tokLoc.get(e),n=this.afterAll(this.tokGlobal,s??this.tokGlobal,...r),i=this.tokenStore.createEffectToken();return this.trace.record({type:"effect",op:`ordered_${t}`,input:n.id,output:i.id,locId:e}),this.tokGlobal=i,this.tokLoc.set(e,i),this.trace.record({type:"set_token",target:"global",token:i.id}),this.trace.record({type:"set_token",target:"loc",locId:e,token:i.id}),i}emitEffect(e){return this.ensureNotPoisoned(),this.emitEffectFrom(this.tokGlobal,e)}_debug_publishSave(e){const t=this.emitEffect("publish_save");return this.trace.record({type:"publish_save"}),t}_debug_emitCompiledCall(e,t){this.trace.record({type:"compiled_call",graphInstanceId:e,callInstanceId:t})}_debug_setRngBasis(e){this.rngBasis={...e},this.rngDrawNonce=0,this.trace.record({type:"rng_basis",algorithmId:e.algorithmId,seed:e.seed})}_debug_getRngDrawNonce(){return this.rngDrawNonce}_debug_startCheckpointRecord(){if(this.rngCheckpointMode)throw new Error("Checkpoint RNG already active");this.rngCheckpointMode="record",this.rngCheckpointDraws=[],this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_record_start"})}_debug_finishCheckpointRecord(){if(this.rngCheckpointMode!=="record")throw new Error("Checkpoint RNG record not active");const e=this.rngCheckpointDraws.slice();return this.rngCheckpointMode=null,this.rngCheckpointDraws=[],this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_record_finish",count:e.length}),e}_debug_startCheckpointReplay(e){if(this.rngCheckpointMode)throw new Error("Checkpoint RNG already active");this.rngCheckpointMode="replay",this.rngCheckpointDraws=e.slice(),this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_replay_start",count:e.length})}_debug_finishCheckpointReplay(){if(this.rngCheckpointMode!=="replay")throw new Error("Checkpoint RNG replay not active");const e=this.rngCheckpointDraws.length;this.rngCheckpointMode=null,this.rngCheckpointDraws=[],this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_replay_finish",count:e})}_debug_random(e,t){if(this.rngCheckpointMode==="replay"){const n=this.rngCheckpointDraws[this.rngCheckpointIndex];if(!n)throw new Bu("RNG replay exhausted");if(n.opNonce!==e)throw new Gs("RNG replay opNonce mismatch");if(t!==void 0&&t!==n.drawNonce)throw new Gs("RNG replay drawNonce mismatch");return this.rngCheckpointIndex+=1,this.trace.record({type:"rng_draw",opNonce:n.opNonce,drawNonce:n.drawNonce,value:n.value}),{drawNonce:n.drawNonce,value:n.value}}const r=t??this.nextRngDrawNonce();t!==void 0&&t>this.rngDrawNonce&&(this.rngDrawNonce=t);const s=Ru(this.rngBasis,e,r);return this.rngCheckpointMode==="record"&&this.rngCheckpointDraws.push({opNonce:e,drawNonce:r,value:s}),this.trace.record({type:"rng_draw",opNonce:e,drawNonce:r,value:s}),{drawNonce:r,value:s}}_debug_backward(e){if(this.backwardActive)throw new zu("Backward is already running");this.backwardActive=!0,this.emitEffect("backward_root");try{return e()}finally{this.backwardActive=!1}}_debug_saveForBackward(e){const t=this.getOrCreateBaseState(e);return{id:this.nextSavedTensorId++,baseId:e,baseCommitVersionAtSave:t.baseCommitVersion}}_debug_useSavedTensor(e){if(this.getOrCreateBaseState(e.baseId).baseCommitVersion!==e.baseCommitVersionAtSave)throw new $u(`Saved tensor modified for baseId ${e.baseId}`)}compile(e){return(...t)=>{if(this.stagingActive)throw new Error("Compile already active");this.stagingActive=!0,this.currentEpoch+=1,this.currentStagingIds=new Set;let r;try{r=e(...t)}catch(s){throw this.finishStaging(void 0),s}if(Mu(r))throw this.finishStaging(void 0),new Eu("Async work is not allowed in compile");return this.finishStaging(r),r}}_debug_hostRead(){if(this.stagingActive)throw new Au("Host reads are forbidden during compile")}_debug_makeTraceTensor(e){if(!this.stagingActive)throw new Error("Trace tensors may only be created during compile");const t={id:this.nextTraceTensorId++,epoch:this.currentEpoch,label:e};return this.currentStagingIds.add(t.id),this.traceTensorStatus.set(t.id,"staging"),t}_debug_emitLazyOp(e,t){const r=t?.inputs??[];for(const n of r){if(n.epoch!==this.currentEpoch)throw new Error("Trace tensor belongs to a different epoch");this._debug_useTraceTensor(n)}const s=this._debug_makeTraceTensor(e);return this.trace.record({type:"lazy_op",op:e,traceId:s.id,epoch:s.epoch,inputs:r.length>0?r.map(n=>n.id):void 0,shape:t?.shape?t.shape.slice():void 0,dtype:t?.dtype}),s}_debug_getLastCompiledGraph(){return this.lastCompiledGraph}_debug_getLastCacheKey(){return this.lastCacheKey}_debug_wasLastCompileCacheHit(){return this.lastCacheHit}_debug_getCompiledCacheStats(){return this.compiledCache.stats()}_debug_clearCompiledCache(){this.compiledCache.clear()}_debug_useTraceTensor(e){const t=this.traceTensorStatus.get(e.id);if(!t)throw new Error(`Unknown trace tensor ${e.id}`);if(t==="stale")throw new Iu("Trace tensor is stale")}_debug_bindPendingLoc(e,t){this.getOrCreateLocState(t),this.baseBindings.set(e,{kind:"pending_loc",locId:t})}_debug_setLocRole(e,t){const r=this.getOrCreateLocState(e);r.role=t}_debug_setRecomputeMode(e){this.recomputeMode=e,e||(this.checkpointReachableBases=null)}_debug_ensureInitialized(e,t={}){const r=this.getBaseBinding(e);if(r.kind!=="pending_loc"||r.locId===void 0)throw new Error("ensureInitialized requires a pending_loc binding");if(r.initTok)return r.initTok;if(this.recomputeMode)throw new Gt("Cannot initialize loc during recompute");this.getOrCreateLocState(r.locId);const s=t.subsumedByStore?this.tokenStore.createTokenOnlyToken():this.tokenStore.createEffectToken(),n=t.subsumedByStore?"init_loc_token_only":"init_loc_store";return this.trace.record({type:"effect",op:n,input:this.tokGlobal.id,output:s.id,locId:r.locId}),this.tokGlobal=s,this.trace.record({type:"set_token",target:"global",token:s.id}),r.initTok=s,s}_debug_orderedAccessBase(e,t){const r=this.getBaseBinding(e);if(r.kind==="pending_loc"&&r.locId!==void 0){const s=this._debug_ensureInitialized(e);return this.orderedAccess(r.locId,t,[s])}if(r.kind==="loc"&&r.locId!==void 0)return this.orderedAccess(r.locId,t);throw new Error("orderedAccessBase requires a loc-backed binding")}_debug_recomputeLocStore(e){const t=this.getOrCreateLocState(e);if(this.recomputeMode&&t.role==="persistent")throw new Gt("Cannot store to persistent loc during recompute");this._debug_commitLocStore(e)}_debug_writeSavedState(){if(this.recomputeMode)throw new Gt("Cannot create saved_state during recompute")}_debug_recomputeMutateBase(e,t){if(this.recomputeMode&&this.checkpointReachableBases?.has(e))throw new Gt(`Cannot mutate base ${e} during recompute`);this._debug_baseCommit(e,t)}_debug_checkpointPack(e){const t=Array.from(new Set(e)).sort((s,n)=>s-n),r={id:this.nextCheckpointPackId++,reachableBases:t};return this.trace.record({type:"checkpoint_pack",packId:r.id,reachableBases:r.reachableBases.slice()}),r}_debug_startCheckpointRecompute(e){this.recomputeMode=!0,this.checkpointReachableBases=new Set(e.reachableBases),this.activeCheckpointPackId=e.id,this.trace.record({type:"checkpoint_recompute_start",packId:e.id,reachableBases:e.reachableBases.slice()})}_debug_finishCheckpointRecompute(){this.recomputeMode=!1,this.checkpointReachableBases=null,this.trace.record({type:"checkpoint_recompute_finish",packId:this.activeCheckpointPackId}),this.activeCheckpointPackId=null}_debug_enqueueFinalize(e){this.finalizeQueue.push(e),this.trace.record({type:"finalize_enqueue",recordId:e.id})}_debug_drainFinalizeQueueCleanupOnly(){const e=this.finalizeQueue.splice(0);return this.trace.record({type:"finalize_drain",count:e.length}),e}createTensor(e){const t=e??this.nextBaseId++;t>=this.nextBaseId&&(this.nextBaseId=t+1);const r=this.tidyScopes.length>0?{kind:"tidy",scopeId:this.tidyScopes[this.tidyScopes.length-1].id}:{kind:"global"},s=new Vn(this.nextTensorId++,t,r);return this.registerTensor(s),s}forceRead(e){this._debug_hostRead(),this.finalizePendingLocBindings();const t=this.collectForcePlanTokens(e),r=Array.from(new Set(t.map(n=>n.id))).sort((n,i)=>n-i);this.trace.record({type:"force_plan",baseId:e,tokenIds:r});const s=this.afterAll(t);this.emitEffectFrom(s,`host_read:${e}`)}tidy(e){const t={id:this.nextScopeId++,tensors:new Set};this.tidyScopes.push(t);let r,s=!1;try{r=e(),s=!0}finally{const n=s?Tu(r):[];for(const a of n)a.escapes=!0;const i=Array.from(t.tensors);for(const a of i)a.escapes||this.dispose(a);this.tidyScopes.pop()}return r}keep(e){e.disposed||(e.escapes=!0)}dispose(e){if(e.disposed)return;e.disposed=!0,e.onDispose&&e.onDispose();const t=this.basePinCount.get(e.baseId)??0;t<=1?this.basePinCount.delete(e.baseId):this.basePinCount.set(e.baseId,t-1);for(const r of this.tidyScopes)r.tensors.delete(e)}async markStep(){this._debug_runEntryPoint(()=>{this.trace.record({type:"mark_step_begin"}),this.emitEffect("mark_step");const e=this.finalizePendingLocBindings();this.trace.record({type:"mark_step_finalize_bindings",count:e}),this.trace.record({type:"mark_step_retain"}),this.trace.record({type:"mark_step_gc"}),this._debug_drainFinalizeQueueCleanupOnly(),this.tokGlobal=this.tokenStore.root,this.tokLoc.clear(),this.trace.record({type:"set_token",target:"global",token:this.tokGlobal.id}),this.trace.record({type:"mark_step_end"})})}_debug_runEntryPoint(e){if(this.execLock.held)throw new qs("Engine is busy");const t=this.nextOwnerId++;this.execLock.held=!0,this.execLock.ownerId=t,this.execLock.depth=1,this._debug_drainFinalizeQueueCleanupOnly();try{return this.ensureNotPoisoned(),e()}finally{this._debug_drainFinalizeQueueCleanupOnly(),this.execLock.held=!1,this.execLock.ownerId=0,this.execLock.depth=0}}async runEntryPoint(e){if(this.execLock.held)throw new qs("Engine is busy");const t=this.nextOwnerId++;this.execLock.held=!0,this.execLock.ownerId=t,this.execLock.depth=1,this._debug_drainFinalizeQueueCleanupOnly();try{return this.ensureNotPoisoned(),await e()}finally{this._debug_drainFinalizeQueueCleanupOnly(),this.execLock.held=!1,this.execLock.ownerId=0,this.execLock.depth=0}}_debug_poison(){this.poisoned=!0}_debug_getBasePinCount(e){return this.basePinCount.get(e)??0}_debugSnapshot(){const e=Array.from(this.tokLoc.entries()).sort(([u],[l])=>u-l),t={};for(const[u,l]of e)t[u.toString()]=this.snapshotToken(l);const r=Array.from(this.locState.entries()).sort(([u],[l])=>u-l),s={};for(const[u,l]of r)s[u.toString()]={locLogicalVersion:l.locLogicalVersion,locVersion:l.locVersion,role:l.role,hasValue:l.hasValue};const n=Array.from(this.baseState.entries()).sort(([u],[l])=>u-l),i={};for(const[u,l]of n)i[u.toString()]={baseCommitVersion:l.baseCommitVersion,committedMutations:Array.from(l.committed).sort((d,c)=>d-c)};const a=Array.from(this.baseBindings.entries()).sort(([u],[l])=>u-l),o={};for(const[u,l]of a)o[u.toString()]={kind:l.kind,locId:l.locId,initTokId:l.initTok?.id,initTokKind:l.initTok?.kind};return{tokGlobal:this.snapshotToken(this.tokGlobal),tokLoc:t,locs:s,bases:i,bindings:o}}_debugCreateToken(){return this.tokenStore.createDebugToken()}_debug_buildPlan(e){return{rootTokenIds:e.map(t=>t.id)}}_debug_buildPlanLinearOrder(e){return kr(e)}_debug_buildPlanFromTrace(e=this.trace.snapshot()){let t=0;const r=[];for(const s of e)s.type==="rng_basis"&&(t+=1,r.push({name:"rng_basis",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"rng_basis"},payload:{algorithmId:s.algorithmId,seed:s.seed}})),(s.type==="rng_checkpoint_record_start"||s.type==="rng_checkpoint_record_finish"||s.type==="rng_checkpoint_replay_start"||s.type==="rng_checkpoint_replay_finish")&&(t+=1,r.push({name:s.type,key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:s.type}})),s.type==="publish_save"&&(t+=1,r.push({name:"publish_save",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"publish_save"}})),s.type==="rng_draw"&&(t=Math.max(t,s.opNonce),r.push({name:"rng_draw",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:s.opNonce,drawNonce:s.drawNonce,mutId:0,kind:"rng_draw"},payload:{drawNonce:s.drawNonce,opNonce:s.opNonce}})),s.type==="loc_schedule"&&(t+=1,r.push({name:"loc_schedule",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"loc_schedule"},payload:{locId:s.locId}})),s.type==="loc_commit"&&(t+=1,r.push({name:"loc_commit",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"loc_commit"},payload:{locId:s.locId}})),s.type==="base_commit"&&(t+=1,r.push({name:"base_commit",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:s.mutId,kind:"base_commit"},payload:{baseId:s.baseId,mutId:s.mutId}}));return kr(r)}_debug_buildPlanFromSchedules(e,t=this.trace.snapshot()){const r=this._debug_buildPlanFromTrace(t),s=e.flatMap(n=>_u(n));return kr([...r.orderedEvents,...s])}_debug_buildPlanWithCompiledCalls(e,t=this.trace.snapshot()){const r=[];for(const s of t)if(s.type==="compiled_call"){const n=e[s.callInstanceId];if(!n)throw new Error(`Missing schedule for compiled call ${s.callInstanceId}`);r.push(n)}return this._debug_buildPlanFromSchedules(r,t)}_debug_simulateCommitPlan(e){const t={},r={},s={},n={};let i=0;for(const a of e.orderedEvents){if(a.key.kind==="loc_schedule"){const o=a.payload?.locId;if(o!==void 0){const u=o.toString();t[u]=(t[u]??0)+1}}if(a.key.kind==="loc_commit"){const o=a.payload?.locId;if(o!==void 0){const u=o.toString();r[u]=(r[u]??0)+1}}if(a.key.kind==="base_commit"){const o=a.payload?.baseId;if(o!==void 0){const u=o.toString();s[u]=(s[u]??0)+1;const l=a.payload?.mutId??a.key.mutId;n[u]||(n[u]=[]),n[u].push(l)}}a.key.kind==="publish_save"&&(i+=1)}return{locLogicalVersions:t,locVersions:r,baseCommitVersions:s,baseCommittedMutations:n,publishSaveCount:i}}_debug_scheduleLocAccess(e){const t=this.getOrCreateLocState(e);return t.locLogicalVersion+=1,this.trace.record({type:"loc_schedule",locId:e,locLogicalVersion:t.locLogicalVersion}),{...t}}_debug_commitLocStore(e){const t=this.getOrCreateLocState(e);return t.locVersion+=1,t.hasValue=!0,this.trace.record({type:"loc_commit",locId:e,locVersion:t.locVersion}),{...t}}nextMutId(){return this.nextMutIdValue++}_debug_baseCommit(e,t){const r=this.getOrCreateBaseState(e);if(r.committed.has(t))throw new Error(`base_commit already recorded for mutId ${t}`);return r.committed.add(t),r.baseCommitVersion+=1,this.trace.record({type:"base_commit",baseId:e,mutId:t,baseCommitVersion:r.baseCommitVersion}),{baseCommitVersion:r.baseCommitVersion,committedMutations:Array.from(r.committed).sort((s,n)=>s-n)}}_debug_simulateCommit(e){const t=this._debugSnapshot(),r={};for(const[s,n]of Object.entries(t.tokLoc))r[s]=n.id;return{tokGlobalId:t.tokGlobal.id,tokLocIds:r}}snapshotToken(e){return{id:e.id,key:e.key,kind:e.kind,roots:e.roots.slice()}}getOrCreateLocState(e){const t=this.locState.get(e);if(t)return t;const r={locLogicalVersion:0,locVersion:0,role:"ephemeral",hasValue:!1};return this.locState.set(e,r),r}getOrCreateBaseState(e){const t=this.baseState.get(e);if(t)return t;const r={baseCommitVersion:0,committed:new Set};return this.baseState.set(e,r),r}getBaseBinding(e){const t=this.baseBindings.get(e);if(!t)throw new Error(`No binding for baseId ${e}`);return t}ensureNotPoisoned(){if(this.poisoned)throw new Cu("Engine is poisoned")}nextRngDrawNonce(){return this.rngDrawNonce+=1,this.rngDrawNonce}finishStaging(e){const t=new Set(jn(e));for(const n of this.currentStagingIds)t.has(n)?this.traceTensorStatus.set(n,"live"):this.traceTensorStatus.set(n,"stale");let r=bu(this.trace.snapshot(),this.currentEpoch),s="disabled";if(this.autocastContext?.current.enabled){const n=pu(r,this.autocastContext);n.modified&&(r=n.graph),s=hu(this.autocastContext.current.policy)}if(r.nodes.length>0){const n=uu(r),i={...n,irHash:`${n.irHash}:amp=${s}`},a=this.compiledCache.get(i);a?(this.lastCacheHit=!0,this.lastCacheKey=i,this.lastCompiledGraph=a.graph):(this.compiledCache.set(i,r),this.lastCacheHit=!1,this.lastCacheKey=i,this.lastCompiledGraph=r)}else this.lastCompiledGraph=null,this.lastCacheKey=null,this.lastCacheHit=!1;this.currentStagingIds.clear(),this.stagingActive=!1}registerTensor(e){const t=this.basePinCount.get(e.baseId)??0;this.basePinCount.set(e.baseId,t+1);for(const r of this.tidyScopes)r.tensors.add(e)}finalizePendingLocBindings(){let e=0;for(const[t,r]of this.baseBindings.entries()){if(r.kind!=="pending_loc"||r.locId===void 0)continue;const s=this.locState.get(r.locId);!s||!s.hasValue||(this.baseBindings.set(t,{kind:"loc",locId:r.locId}),e+=1)}return e}collectForcePlanTokens(e){const t=[],r=this.baseBindings.get(e);if(r&&(r.initTok&&t.push(r.initTok),(r.kind==="pending_loc"||r.kind==="loc")&&r.locId!==void 0)){const s=this.tokLoc.get(r.locId);s&&t.push(s)}return t.length===0&&t.push(this.tokGlobal),t}emitEffectFrom(e,t){const r=this.tokenStore.createEffectToken();return this.trace.record({type:"effect",op:t,input:e.id,output:r.id}),this.tokGlobal=r,this.trace.record({type:"set_token",target:"global",token:r.id}),r}},qs=class extends Error{name="EngineBusyError"},Gt=class extends Error{name="CheckpointImpureRegionError"},Au=class extends Error{name="HostReadInCompileError"},Eu=class extends Error{name="AsyncInCompileError"},Iu=class extends Error{name="InvalidTraceTensorEscapeError"},$u=class extends Error{name="SavedTensorModifiedError"},zu=class extends Error{name="NonReentrantBackwardError"},Cu=class extends Error{name="PoisonedEngineError"};function Tu(e){const t=[],r=new Set,s=n=>{if(n!=null){if(n instanceof Vn){t.push(n);return}if(typeof n=="object"&&!r.has(n)){if(r.add(n),Array.isArray(n)){for(const i of n)s(i);return}for(const i of Object.values(n))s(i)}}};return s(e),t}var Bu=class extends Error{name="RngReplayExhaustedError"},Gs=class extends Error{name="RngReplayMismatchError"};function Mu(e){return e?typeof e.then=="function":!1}function jn(e){return e?Array.isArray(e)?e.flatMap(t=>jn(t)):Du(e)?[e.id]:[]:[]}function Du(e){if(!e||typeof e!="object")return!1;const t=e;return typeof t.id=="number"&&typeof t.epoch=="number"}function Ru(e,t,r){const s=e.seed>>>0,n=e.algorithmId>>>0,i=t>>>0,a=r>>>0;let o=s^Math.imul(n,2654435769)^i^Math.imul(a,2246822507);return o=Pu(o),(o>>>0)/2**32}function Pu(e){let t=e>>>0;return t^=t>>>16,t=Math.imul(t,2146121005),t^=t>>>15,t=Math.imul(t,2221713035),t^=t>>>16,t>>>0}async function Fu(){}var Lu=class extends Error{name="DisposedTensorError"},Wn=class{engine;inner;engineTensor;requiresGradValue;gradNode=null;gradValue=null;constructor(e,t,r,s){this.engine=e,this.inner=t,this.engineTensor=r,this.requiresGradValue=s?.requiresGrad??!1,r.onDispose=()=>{t.dispose()}}get baseId(){return this.inner.baseId}get requiresGrad(){return this.requiresGradValue}get grad(){return this.gradValue}get shape(){return this.inner.shape.slice()}get device(){return this.inner.device}zeroGrad(){this.ensureNotDisposed(),this.gradValue&&this.gradValue.dispose(),this.gradValue=null}toArray(){return this.ensureNotDisposed(),this.inner.toArray()}async cpu(){return this.engine.cpu(this)}async item(){return this.engine.item(this)}backward(e){return this.engine.backward(this,e)}keep(){this.engine.keep(this)}dispose(){this.engine.dispose(this)}[Symbol.toPrimitive](){throw this.ensureNotDisposed(),new Error("Tensor cannot be implicitly converted to a primitive")}valueOf(){throw this.ensureNotDisposed(),new Error("Tensor cannot be implicitly converted to a primitive")}toString(){return this.ensureNotDisposed(),`Tensor(shape=[${this.shape.join(", ")}], device=${this.device}, baseId=${this.baseId})`}view(e){return this.engine.view(this,e)}reshape(e){return this.engine.reshape(this,e)}add(e){return this.engine.add(this,e)}sub(e,t){return this.engine.sub(this,e,t)}mul(e){return this.engine.mul(this,e)}div(e){return this.engine.div(this,e)}matmul(e){return this.engine.matmul(this,e)}sqrt(){return this.engine.sqrt(this)}relu(){return this.engine.relu(this)}exp(){return this.engine.exp(this)}log(){return this.engine.log(this)}neg(){return this.engine.neg(this)}abs(){return this.engine.abs(this)}tanh(){return this.engine.tanh(this)}sigmoid(){return this.engine.sigmoid(this)}gelu(e){return this.engine.gelu(this,e)}silu(){return this.engine.silu(this)}isfinite(){return this.engine.isfinite(this)}expand(e){return this.engine.expand(this,e)}transpose(e){return this.engine.transpose(this,e)}permute(e){return this.engine.permute(this,e)}contiguous(){return this.engine.contiguous(this)}toDtype(e){return this.engine.toDtype(this,e)}half(){return this.toDtype("f16")}float(){return this.toDtype("f32")}int(){return this.toDtype("i32")}to(e){return this.engine.to(this,e)}async toNow(e){return this.engine.toNow(this,e)}sum(e){return this.engine.sum(this,e)}max(e){return this.engine.max(this,e)}mean(e){return this.engine.mean(this,e)}argmax(e){return this.engine.argmax(this,e)}argmin(e){return this.engine.argmin(this,e)}gt(e){return this.engine.gt(this,e)}lt(e){return this.engine.lt(this,e)}ge(e){return this.engine.ge(this,e)}le(e){return this.engine.le(this,e)}eq(e){return this.engine.eq(this,e)}ne(e){return this.engine.ne(this,e)}softmax(e){return this.engine.softmax(this,e)}layernorm(e,t,r=1e-5){return this.engine.layernorm(this,e,t,r)}gather(e,t){return this.engine.gather(this,e,t)}scatterAdd(e,t,r){return this.engine.scatterAdd(this,e,t,r)}detach(){return this.engine.detach(this)}copy_(e){return this.engine.copy_(this,e)}add_(e){return this.engine.add_(this,e)}zero_(){return this.engine.zero_(this)}fill_(e){return this.engine.fill_(this,e)}mul_(e){return this.engine.mul_(this,e)}_unwrap(){return this.inner}_engine(){return this.engine}_engineTensor(){return this.engineTensor}_runtimeTensor(){return this.inner}_gradNode(){return this.gradNode}_setGradNode(e){this.gradNode=e}_setGrad(e){this.gradValue&&this.gradValue!==e&&this.gradValue.dispose(),this.gradValue=e}_ensureNotDisposed(){this.ensureNotDisposed()}ensureNotDisposed(){if(this.engineTensor.disposed)throw new Lu("Tensor has been disposed")}},Nu=class{engine;runtime;autocastContext;inCompileRegion=!1;memoryPlanningAvailable;savedTensorHooksStack=[];constructor(e,t){this.engine=new xu,t?.memoryLimitBytes!==void 0&&(Zo(t.memoryLimitBytes),Ms(t.memoryLimitBytes)),this.memoryPlanningAvailable=t?.enableMemoryPlanning??!1,this.runtime=new qn(e,{enableFusion:t?.enableFusion??!1,enableMemoryPlanning:!1}),this.autocastContext=du()}static getGPUMemoryLimit(){return No()}static setGPUMemoryLimit(e){Ms(e)}static getGPUMemoryStats(){return qo()}setFusionEnabled(e){this.runtime.setFusionEnabled(e)}isFusionEnabled(){return this.runtime.isFusionEnabled()}compile(e){const t=this.engine.compile((...r)=>{});return(...r)=>{this.inCompileRegion=!0;const s=this.runtime.isFusionEnabled(),n=this.runtime.isMemoryPlanningEnabled();this.runtime.setFusionEnabled(!0),this.memoryPlanningAvailable&&this.runtime.setMemoryPlanning(!0);try{return t(),this.tidy(()=>e(...r))}finally{this.runtime.setFusionEnabled(s),this.runtime.setMemoryPlanning(n),this.inCompileRegion=!1}}}get isAutocastEnabled(){return this.autocastContext.current.enabled}get currentAutocastConfig(){return{...this.autocastContext.current}}setBackend(e){this.runtime.setBackend(e)}setDevice(e){this.runtime.setBackend(e)}autocast(e,t){const r=t?.deviceType??(this.runtime.currentDefaultDevice==="webgpu"?"webgpu":"cpu");Rs(this.autocastContext,{enabled:t?.enabled??!0,policy:t?.policy??Vr,deviceType:r}),this.engine.setAutocastContext(this.autocastContext);try{return e()}finally{Ps(this.autocastContext),this.engine.setAutocastContext(this.autocastContext.configStack.length>0?this.autocastContext:null)}}async autocastAsync(e,t){const r=t?.deviceType??(this.runtime.currentDefaultDevice==="webgpu"?"webgpu":"cpu");Rs(this.autocastContext,{enabled:t?.enabled??!0,policy:t?.policy??Vr,deviceType:r}),this.engine.setAutocastContext(this.autocastContext);try{return await e()}finally{Ps(this.autocastContext),this.engine.setAutocastContext(this.autocastContext.configStack.length>0?this.autocastContext:null)}}saved_tensors_hooks(e,t,r){this.savedTensorHooksStack.push({packHook:e,unpackHook:t});try{return r()}finally{this.savedTensorHooksStack.pop()}}_getSavedTensorHooks(){return this.savedTensorHooksStack.length>0?this.savedTensorHooksStack[this.savedTensorHooksStack.length-1]:null}_getAutocastContext(){return this.autocastContext}tensorFromArray(e,t,r){return this.wrap(this.runtime.tensorFromArray(e,t,r?.device),r?.requiresGrad??!1)}rand(e,t){const r=e.reduce((n,i)=>n*i,1),s=new Array(r);for(let n=0;n<r;n++)s[n]=Math.random();return this.tensorFromArray(s,e,t)}randn(e,t){const r=e.reduce((n,i)=>n*i,1),s=new Array(r);for(let n=0;n<r;n+=2){const i=Math.random(),a=Math.random(),o=Math.sqrt(-2*Math.log(i||1e-10)),u=2*Math.PI*a;s[n]=o*Math.cos(u),n+1<r&&(s[n+1]=o*Math.sin(u))}return this.tensorFromArray(s,e,t)}bernoulli(e,t=.5,r){if(t<0||t>1)throw new Error(`Bernoulli probability must be between 0 and 1, got ${t}`);const s=e.reduce((i,a)=>i*a,1),n=new Array(s);for(let i=0;i<s;i++)n[i]=Math.random()<t?1:0;return this.tensorFromArray(n,e,r)}zeros(e,t){const r=e.reduce((n,i)=>n*i,1),s=new Array(r).fill(0);return this.tensorFromArray(s,e,t)}ones(e,t){const r=e.reduce((n,i)=>n*i,1),s=new Array(r).fill(1);return this.tensorFromArray(s,e,t)}full(e,t,r){const s=e.reduce((i,a)=>i*a,1),n=new Array(s).fill(t);return this.tensorFromArray(n,e,r)}add(e,t){this.assertUsable(e,t);const r=this.runtime.add(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape;return this.wrapWithGrad(r,[e,t],(i,a)=>[this.sumToShape(i,s),this.sumToShape(i,n)])}sub(e,t,r){this.assertUsable(e,t);const s=this.runtime.sub(e._unwrap(),t._unwrap(),r),n=e.shape,i=t.shape,a=e.device;return this.wrapWithGrad(s,[e,t],(o,u)=>{const l=r?.alpha??1,d=this.sumToShape(o,n),c=this.runtime.mul(o,this.runtime.tensorFromArray([-l],[],a));return[d,this.sumToShape(c,i)]})}mul(e,t){this.assertUsable(e,t);const r=this.runtime.mul(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape,i=e.requiresGrad||t.requiresGrad?[e,t]:[];return this.wrapWithGrad(r,[e,t],(a,o)=>{const u=o(0),l=o(1);return[this.sumToShape(this.runtime.mul(a,l._unwrap()),s),this.sumToShape(this.runtime.mul(a,u._unwrap()),n)]},i)}div(e,t){this.assertUsable(e,t);const r=this.runtime.div(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape,i=e.requiresGrad||t.requiresGrad?[e,t]:[];return this.wrapWithGrad(r,[e,t],(a,o)=>{const u=o(0),l=o(1),d=this.sumToShape(this.runtime.div(a,l._unwrap()),s),c=this.runtime.mul(l._unwrap(),l._unwrap()),h=this.runtime.neg(u._unwrap());return[d,this.sumToShape(this.runtime.mul(a,this.runtime.div(h,c)),n)]},i)}matmul(e,t){this.assertUsable(e,t);const r=this.runtime.matmul(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape,i=e.requiresGrad||t.requiresGrad?[e,t]:[];return this.wrapWithGrad(r,[e,t],(a,o)=>{if(s.length<2||n.length<2)throw new Error("matmul backward requires rank >= 2");const u=o(0),l=o(1),d=this.runtime.contiguous(this.runtime.transpose(u._unwrap(),{dim0:s.length-2,dim1:s.length-1})),c=this.runtime.contiguous(this.runtime.transpose(l._unwrap(),{dim0:n.length-2,dim1:n.length-1})),h=this.runtime.contiguous(a),f=this.runtime.matmul(h,c),w=this.runtime.matmul(d,h);return[this.sumToShape(f,s),this.sumToShape(w,n)]},i)}sqrt(e){this.assertUsable(e);const t=this.runtime.sqrt(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{const a=i(0),o=this.runtime.sqrt(a._unwrap()),u=this.runtime.tensorFromArray([1e-8],[],r),l=this.runtime.tensorFromArray([.5],[],r),d=this.runtime.add(o,u),c=this.runtime.div(l,d);return[this.runtime.mul(n,c)]},s)}relu(e){this.assertUsable(e);const t=this.runtime.relu(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{const a=i(0),o=this.runtime.tensorFromArray([0],[],r),u=this.runtime.gt(a._unwrap(),o);return[this.runtime.mul(n,u)]},s)}exp(e){this.assertUsable(e);const t=this.runtime.exp(e._unwrap()),r=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(s,n)=>{const i=n(0),a=this.runtime.exp(i._unwrap());return[this.runtime.mul(s,a)]},r)}log(e){this.assertUsable(e);const t=this.runtime.log(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{const a=i(0),o=this.runtime.tensorFromArray([1e-8],[],r),u=this.runtime.add(a._unwrap(),o);return[this.runtime.div(n,u)]},s)}neg(e){this.assertUsable(e);const t=this.runtime.neg(e._unwrap());return this.wrapWithGrad(t,[e],(r,s)=>[this.runtime.neg(r)])}abs(e){this.assertUsable(e);const t=this.runtime.abs(e._unwrap()),r=e.shape,s=e.device,n=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(i,a)=>{const o=a(0)._unwrap().toArray(),u=i.toArray().map((l,d)=>o[d]>=0?l:-l);return[this.runtime.tensorFromArray(u,r,s)]},n)}tanh(e){this.assertUsable(e);const t=this.runtime.tanh(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{const a=i(0),o=this.runtime.tanh(a._unwrap()),u=this.runtime.mul(o,o),l=this.runtime.tensorFromArray([1],[],r),d=this.runtime.sub(this.runtime.expand(l,u.shape),u);return[this.runtime.mul(d,n)]},s)}sigmoid(e){this.assertUsable(e);const t=this.runtime.sigmoid(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{const a=i(0),o=this.runtime.sigmoid(a._unwrap()),u=this.runtime.tensorFromArray([1],[],r),l=this.runtime.sub(this.runtime.expand(u,o.shape),o),d=this.runtime.mul(o,l);return[this.runtime.mul(d,n)]},s)}gelu(e,t){this.assertUsable(e);const r=t?.approximate??"tanh",s=this.runtime.gelu(e._unwrap(),t),n=e.device,i=e.requiresGrad?[e]:[];return r==="tanh"?this.wrapWithGrad(s,[e],(a,o)=>{const u=o(0)._unwrap(),l=this.runtime.tensorFromArray([.7978845608],[],n),d=this.runtime.tensorFromArray([.5],[],n),c=this.runtime.tensorFromArray([1],[],n),h=this.runtime.tensorFromArray([.044715],[],n),f=this.runtime.tensorFromArray([.134145],[],n),w=this.runtime.mul(u,u),m=this.runtime.mul(w,u),p=this.runtime.add(u,this.runtime.mul(h,m)),g=this.runtime.mul(l,p),b=this.runtime.tanh(g),v=this.runtime.mul(d,this.runtime.add(c,b)),k=this.runtime.mul(b,b),y=this.runtime.sub(c,k),x=this.runtime.add(c,this.runtime.mul(f,w)),z=this.runtime.mul(this.runtime.mul(l,x),y),M=this.runtime.mul(this.runtime.mul(u,z),d),D=this.runtime.add(v,M);return[this.runtime.mul(a,D)]},i):this.wrapWithGrad(s,[e],(a,o)=>{const u=o(0)._unwrap(),l=this.runtime.tensorFromArray([.5],[],n),d=this.runtime.tensorFromArray([1],[],n),c=this.runtime.tensorFromArray([-.5],[],n),h=this.runtime.tensorFromArray([.7071067811865476],[],n),f=this.runtime.tensorFromArray([.3989422804014327],[],n),w=this.runtime.tensorFromArray([.3275911],[],n),m=this.runtime.tensorFromArray([.254829592],[],n),p=this.runtime.tensorFromArray([-.284496736],[],n),g=this.runtime.tensorFromArray([1.421413741],[],n),b=this.runtime.tensorFromArray([-1.453152027],[],n),v=this.runtime.tensorFromArray([1.061405429],[],n),k=this.runtime.mul(u,h),y=this.runtime.abs(k),x=this.runtime.div(d,this.runtime.add(d,this.runtime.mul(w,y))),z=this.runtime.mul(x,x),M=this.runtime.mul(z,x),D=this.runtime.mul(M,x),B=this.runtime.mul(D,x),R=this.runtime.add(this.runtime.mul(m,x),this.runtime.add(this.runtime.mul(p,z),this.runtime.add(this.runtime.mul(g,M),this.runtime.add(this.runtime.mul(b,D),this.runtime.mul(v,B)))));this.runtime.mul(k,k);const L=this.runtime.mul(c,this.runtime.mul(u,u)),q=this.runtime.exp(L),_=this.runtime.sub(d,this.runtime.mul(R,q)),T=this.runtime.tensorFromArray([0],[],n),$=this.runtime.ge(u,T),P=this.runtime.add(d,_),j=this.runtime.sub(d,_),A=this.runtime.where($,P,j),Q=this.runtime.mul(l,A),he=this.runtime.mul(q,f),pe=this.runtime.mul(u,he),we=this.runtime.add(Q,pe);return[this.runtime.mul(a,we)]},i)}silu(e){this.assertUsable(e);const t=this.runtime.silu(e._unwrap()),r=e.shape,s=e.device,n=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(i,a)=>{const o=a(0)._unwrap().toArray(),u=i.toArray().map((l,d)=>{const c=o[d],h=1/(1+Math.exp(-c));return l*(h+c*h*(1-h))});return[this.runtime.tensorFromArray(u,r,s)]},n)}isfinite(e){this.assertUsable(e);const t=this.runtime.isfinite(e._unwrap());return this.wrap(t)}expand(e,t){this.assertUsable(e);const r=e.shape,s=this.runtime.expand(e._unwrap(),t);return this.wrapWithGrad(s,[e],(n,i)=>[this.sumToShape(n,r)])}sum(e,t){this.assertUsable(e);const r=this.runtime.sum(e._unwrap(),t);if(typeof r=="number"){if(e.requiresGrad)throw new Error("sum with requiresGrad must specify dim");return r}const s=e.shape,n=s.length;return this.wrapWithGrad(r,[e],(i,a)=>{const o=this.normalizeDims(t?.dim??null,n),u=t?.keepdim??!1;return[this.expandGrad(i,s,o,u)]})}max(e,t){this.assertUsable(e);const r=this.runtime.max(e._unwrap(),t);return typeof r=="number"?r:this.wrap(r)}mean(e,t){this.assertUsable(e);const r=this.runtime.mean(e._unwrap(),t);if(typeof r=="number"){if(e.requiresGrad)throw new Error("mean with requiresGrad must specify dim");return r}const s=e.shape,n=e.device,i=this.normalizeDims(t?.dim??null,s.length),a=t?.keepdim??!1,o=i.length===0?1:i.reduce((u,l)=>u*s[l],1);return this.wrapWithGrad(r,[e],(u,l)=>{const d=this.expandGrad(u,s,i,a);return[this.runtime.mul(d,this.runtime.tensorFromArray([1/o],[],n))]})}argmax(e,t){this.assertUsable(e);const r=this.runtime.argmax(e._unwrap(),t);return this.wrap(r)}argmin(e,t){this.assertUsable(e);const r=this.runtime.argmin(e._unwrap(),t);return this.wrap(r)}gt(e,t){this.assertUsable(e,t);const r=this.runtime.gt(e._unwrap(),t._unwrap());return this.wrap(r)}lt(e,t){this.assertUsable(e,t);const r=this.runtime.lt(e._unwrap(),t._unwrap());return this.wrap(r)}ge(e,t){this.assertUsable(e,t);const r=this.runtime.ge(e._unwrap(),t._unwrap());return this.wrap(r)}le(e,t){this.assertUsable(e,t);const r=this.runtime.le(e._unwrap(),t._unwrap());return this.wrap(r)}eq(e,t){this.assertUsable(e,t);const r=this.runtime.eq(e._unwrap(),t._unwrap());return this.wrap(r)}ne(e,t){this.assertUsable(e,t);const r=this.runtime.ne(e._unwrap(),t._unwrap());return this.wrap(r)}softmax(e,t){this.assertUsable(e);const r=e.shape.length,s=t<0?t+r:t;if(s<0||s>=r)throw new Error(`softmax: dim ${t} out of range for tensor of rank ${r}`);const n=this.runtime.max(e._unwrap(),{dim:s,keepdim:!0});if(typeof n=="number")throw new Error("softmax: max with keepdim=true should return tensor");const i=this.runtime.sub(e._unwrap(),n),a=this.runtime.exp(i),o=this.runtime.sum(a,{dim:s,keepdim:!0});if(typeof o=="number")throw new Error("softmax: sum with keepdim=true should return tensor");const u=this.runtime.div(a,o),l=e.requiresGrad?[e]:[];return this.wrapWithGrad(u,[e],(d,c)=>{const h=c(0),f=this.runtime.max(h._unwrap(),{dim:s,keepdim:!0});if(typeof f=="number")throw new Error("softmax backward: max with keepdim=true should return tensor");const w=this.runtime.sub(h._unwrap(),f),m=this.runtime.exp(w),p=this.runtime.sum(m,{dim:s,keepdim:!0});if(typeof p=="number")throw new Error("softmax backward: sum with keepdim=true should return tensor");const g=this.runtime.div(m,p),b=this.runtime.mul(g,d),v=this.runtime.sum(b,{dim:s,keepdim:!0});if(typeof v=="number")throw new Error("softmax backward: sum with keepdim=true should return tensor");const k=this.runtime.sub(d,v);return[this.runtime.mul(g,k)]},l)}layernorm(e,t,r,s=1e-5){this.assertUsable(e,t,r);const n=e.shape,i=e.device,a=n.length,u=-1+a,l=n[n.length-1],d=this.runtime.mean(e._unwrap(),{dim:u,keepdim:!0});if(typeof d=="number")throw new Error("layernorm: mean with keepdim=true should return tensor");const c=this.runtime.sub(e._unwrap(),d),h=this.runtime.mul(c,c),f=this.runtime.mean(h,{dim:u,keepdim:!0});if(typeof f=="number")throw new Error("layernorm: variance mean with keepdim=true should return tensor");const w=this.runtime.tensorFromArray([s],[],i),m=this.runtime.add(f,w),p=this.runtime.sqrt(m),g=this.runtime.div(c,p),b=this.runtime.mul(g,t._unwrap()),v=this.runtime.add(b,r._unwrap()),k=e.requiresGrad||t.requiresGrad||r.requiresGrad?[e,t,r]:[];return this.wrapWithGrad(v,[e,t,r],(y,x)=>{const z=x(0),M=x(1),D=this.runtime.mean(z._unwrap(),{dim:u,keepdim:!0});if(typeof D=="number")throw new Error("layernorm backward: mean should return tensor");const B=this.runtime.sub(z._unwrap(),D),R=this.runtime.mul(B,B),L=this.runtime.mean(R,{dim:u,keepdim:!0});if(typeof L=="number")throw new Error("layernorm backward: variance mean should return tensor");const q=this.runtime.tensorFromArray([s],[],i),_=this.runtime.add(L,q),T=this.runtime.sqrt(_),$=this.runtime.div(B,T),P=Array.from({length:a-1},(Se,et)=>et);let j=y;for(let Se=P.length-1;Se>=0;Se--){const et=this.runtime.sum(j,{dim:P[Se],keepdim:!1});if(typeof et=="number")throw new Error("layernorm backward: sum for gradBias should return tensor");j=et}let A=this.runtime.mul(y,$);for(let Se=P.length-1;Se>=0;Se--){const et=this.runtime.sum(A,{dim:P[Se],keepdim:!1});if(typeof et=="number")throw new Error("layernorm backward: sum for gradWeight should return tensor");A=et}const Q=this.runtime.mul(y,M._unwrap()),he=this.runtime.div(Q,T),pe=this.runtime.mul(Q,B),we=this.runtime.sum(pe,{dim:u,keepdim:!0});if(typeof we=="number")throw new Error("layernorm backward: sum should return tensor");const Ee=this.runtime.tensorFromArray([-.5],[],i),ge=this.runtime.mul(_,T),ve=this.runtime.mul(Ee,this.runtime.div(we,ge)),_e=this.runtime.tensorFromArray([2],[],i),Ce=this.runtime.tensorFromArray([l],[],i),Xe=this.runtime.div(this.runtime.mul(this.runtime.mul(_e,ve),B),Ce),Je=this.runtime.add(he,Xe),Nt=this.runtime.sum(Je,{dim:u,keepdim:!0});if(typeof Nt=="number")throw new Error("layernorm backward: sum should return tensor");const Fe=this.runtime.neg(this.runtime.div(Nt,Ce));return[this.runtime.add(Je,Fe),A,j]},k)}async cpu(e){return this.assertUsable(e),this.runEntryPoint(async()=>(this.engine.forceRead(e.baseId),this.runtime.cpu(e._unwrap())))}async item(e){return this.assertUsable(e),this.runEntryPoint(async()=>(this.engine.forceRead(e.baseId),this.runtime.item(e._unwrap())))}to(e,t){if(this.assertUsable(e),e.device===t)return e;const r=this.runtime.transfer(e._unwrap(),t);return this.wrap(r,e.requiresGrad)}async toNow(e,t){return this.assertUsable(e),this.runEntryPoint(async()=>{this.engine.forceRead(e.baseId);const r=await this.runtime.transferNow(e._unwrap(),t);return this.wrap(r,e.requiresGrad)})}copy_(e,t){return this.assertUsable(e,t),this.runtime.copy_(e._unwrap(),t._unwrap()),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}add_(e,t){return this.assertUsable(e,t),this.runtime.add_(e._unwrap(),t._unwrap()),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}zero_(e){return this.assertUsable(e),this.runtime.zero_(e._unwrap()),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}fill_(e,t){return this.assertUsable(e),this.runtime.fill_(e._unwrap(),t),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}mul_(e,t){return this.assertUsable(e),this.runtime.mul_(e._unwrap(),t),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}gather(e,t,r){this.assertUsable(e,t);const s=this.runtime.gather(e._unwrap(),t._unwrap(),r),n=e.shape,i=t._unwrap();return this.wrapWithGrad(s,[e],(a,o)=>{const u=this.runtime.tensorFromArray(new Array(n.reduce((l,d)=>l*d,1)).fill(0),n);return[this.runtime.scatterAdd(u,i,a,r)]})}scatterAdd(e,t,r,s){this.assertUsable(e,t,r);const n=this.runtime.scatterAdd(e._unwrap(),t._unwrap(),r._unwrap(),s),i=t._unwrap();return this.wrapWithGrad(n,[e,r],(a,o)=>[a,this.runtime.gather(a,i,s)])}where(e,t,r){this.assertUsable(e,t,r);const s=this.runtime.where(e._unwrap(),t._unwrap(),r._unwrap()),n=t.shape,i=r.shape,a=e._unwrap();return this.wrapWithGrad(s,[t,r],(o,u)=>{const l=this.runtime.tensorFromArray(new Array(o.shape.reduce((h,f)=>h*f,1)).fill(0),o.shape,o.device),d=this.runtime.where(a,o,l),c=this.runtime.where(a,l,o);return[this.sumToShape(d,n),this.sumToShape(c,i)]})}view(e,t){this.assertUsable(e);const r=e.shape,s=this.runtime.view(e._unwrap(),t);return this.wrapWithGrad(s,[e],(n,i)=>[this.runtime.reshape(this.runtime.contiguous(n),r)])}reshape(e,t){this.assertUsable(e);const r=e.shape,s=this.runtime.reshape(e._unwrap(),t);return this.wrapWithGrad(s,[e],(n,i)=>[this.runtime.reshape(this.runtime.contiguous(n),r)])}transpose(e,t){this.assertUsable(e);const r=this.runtime.transpose(e._unwrap(),t);return this.wrapWithGrad(r,[e],(s,n)=>[this.runtime.transpose(s,t)])}permute(e,t){this.assertUsable(e);const r=this.runtime.permute(e._unwrap(),t),s=new Array(t.length);for(let n=0;n<t.length;n++)s[t[n]]=n;return this.wrapWithGrad(r,[e],(n,i)=>[this.runtime.permute(n,s)])}contiguous(e){this.assertUsable(e);const t=this.runtime.contiguous(e._unwrap());return this.wrapWithGrad(t,[e],(r,s)=>[r])}toDtype(e,t){this.assertUsable(e);const r=this.runtime.cast(e._unwrap(),t);return this.wrap(r)}detach(e){return this.assertUsable(e),this.wrap(e._unwrap())}async backward(e,t){if(this.assertUsable(e),t&&(this.assertUsable(t),!Sr(t.shape,e.shape)))throw new Error("backward grad shape mismatch");return this.runEntryPoint(async()=>{const r=t?t._unwrap():this.seedGrad(e),s=new Map;s.set(e,r);const n=[],i=new Set,a=l=>{if(!i.has(l)){for(const d of l.inputs){const c=d._gradNode();c&&a(c)}i.add(l),n.push(l)}},o=e._gradNode();o&&a(o);const u=[r];for(const l of n)for(const d of l.inputs)u.push(d._unwrap());await this.runtime.forceAll(...u);for(let l=n.length-1;l>=0;l-=1){const d=n[l],c=s.get(d.output);if(!c)continue;await this.runtime.force(c);for(const m of d.savedSlots)this.engine._debug_useSavedTensor(m.record);const h=[];for(const m of d.savedSlots){const p=m.unpackHook(m.packed);h.push(p)}h.length>0&&await this.runtime.forceAll(...h.map(m=>m._unwrap()));const f=m=>{if(m>=h.length)throw new Error(`No saved tensor at index ${m}`);return h[m]},w=d.backward(c,f);for(let m=0;m<d.inputs.length;m+=1){const p=d.inputs[m],g=w[m];if(!g||!p.requiresGrad)continue;const b=s.get(p);b?s.set(p,this.runtime.add(b,g)):s.set(p,g)}}for(const[l,d]of s)l.requiresGrad&&!l._gradNode()&&l._setGrad(this.wrap(d,!1))})}wrap(e,t=!1){const r=this.engine.createTensor(e.baseId);return new Wn(this,e,r,{requiresGrad:t})}wrapWithGrad(e,t,r,s=[]){const n=t.some(a=>a.requiresGrad),i=this.wrap(e,n);if(n){const a=[],o=this._getSavedTensorHooks();for(const u of s)if(o){const l=o.packHook(u),d=this.engine._debug_saveForBackward(u.baseId);a.push({packed:l,unpackHook:o.unpackHook,record:d})}else{this.keep(u);const l=this.engine._debug_saveForBackward(u.baseId);a.push({packed:u,unpackHook:d=>d,record:l})}a.length>0&&this.engine._debug_publishSave(i.baseId),i._setGradNode({inputs:t,output:i,backward:r,savedSlots:a})}return i}seedGrad(e){if(Gu(e.shape)!==1)throw new Error("backward requires an explicit grad for non-scalars");return this.runtime.tensorFromArray([1],[],e.device)}saveForBackward(e){return this.keep(e),this.engine._debug_saveForBackward(e.baseId)}sumToShape(e,t){if(Sr(e.shape,t))return e;const r=e.shape.length,s=t.length,n=Math.max(0,r-s),i=new Array(n).fill(1).concat(t),a=[];for(let u=0;u<r;u+=1){const l=i[u],d=e.shape[u];l===1&&d!==1&&a.push(u)}let o=e;if(a.length>0){const u=this.runtime.sum(o,{dim:a,keepdim:!0});typeof u=="number"?o=this.runtime.tensorFromArray([u],[],e.device):o=u}return Sr(o.shape,t)||(o=this.runtime.reshape(o,t)),o}expandGrad(e,t,r,s){let n=e;if(!s&&r.length>0){const i=t.length,a=new Set(r),o=new Array(i);let u=0;for(let l=0;l<i;l+=1)a.has(l)?o[l]=1:(o[l]=e.shape[u],u+=1);n=this.runtime.reshape(n,o)}return this.runtime.expand(n,t)}normalizeDims(e,t){if(e==null)return Array.from({length:t},(n,i)=>i);const r=(Array.isArray(e)?e.slice():[e]).map(n=>n<0?t+n:n),s=new Set;for(const n of r){if(n<0||n>=t)throw new Error(`dim out of range: ${n}`);s.has(n)||s.add(n)}return Array.from(s).sort((n,i)=>n-i)}tidy(e){let t;return this.engine.tidy(()=>(t=e(),qu(t))),t}keep(e){this.assertUsable(e),this.engine.keep(e._engineTensor())}dispose(e){this.assertSameEngine(e),this.engine.dispose(e._engineTensor())}async markStep(){await this.engine.markStep(),await this.runtime.forceAllPending(),this.defaultDevice==="webgpu"&&await Fu(),lt.destroyUnreachable()}_debug_baseCommit(e,t){this.engine._debug_baseCommit(e,t)}_runtime(){return this.runtime}_wrapRuntime(e,t){return this.wrap(e,t)}assertUsable(...e){this.assertSameEngine(...e),this.assertSameDevice(...e);for(const t of e)t._ensureNotDisposed()}assertSameEngine(...e){for(const t of e)if(t._engine()!==this)throw new Error("Tensor belongs to a different Torchlette instance")}assertSameDevice(...e){if(e.length<=1)return;const t=e[0].device;for(const r of e)if(r.device!==t)throw new Error("Tensors must be on the same device")}async runEntryPoint(e){return this.engine.runEntryPoint(e)}};new Nu;function qu(e){const t=[],r=new Set,s=n=>{if(n!=null){if(n instanceof Wn){t.push(n._engineTensor());return}if(typeof n=="object"&&!r.has(n)){if(r.add(n),Array.isArray(n)){for(const i of n)s(i);return}for(const i of Object.values(n))s(i)}}};return s(e),t}function Gu(e){return e.reduce((t,r)=>t*r,1)}function Sr(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r+=1)if(e[r]!==t[r])return!1;return!0}var Uu=class{params;api;lr;beta1;beta2;eps;weightDecay;device;expAvg;expAvgSq;steps;constructor(e,t,r){if(e.length===0)throw new Error("Adam requires at least one parameter");const s=r??e[0]._engine(),n=e[0].device;for(const l of e){if(l._engine()!==s)throw new Error("Adam parameters must share the same Torchlette instance");if(l.device!==n)throw new Error("Adam parameters must share the same device");if(!l.requiresGrad)throw new Error("Adam parameters must have requiresGrad=true")}if(t.lr<=0)throw new Error("Adam learning rate must be > 0");const i=t.betas??[.9,.999];if(i.length!==2)throw new Error("Adam betas must have two entries");const[a,o]=i;if(a<0||a>=1||o<0||o>=1)throw new Error("Adam betas must be in the range [0, 1)");const u=t.eps??1e-8;if(u<=0)throw new Error("Adam eps must be > 0");this.api=s,this.lr=t.lr,this.beta1=a,this.beta2=o,this.eps=u,this.params=e.slice(),this.weightDecay=t.weightDecay??0,this.device=n,this.expAvg=new Array(e.length).fill(null),this.expAvgSq=new Array(e.length).fill(null),this.steps=new Array(e.length).fill(0)}getParams(){return this.params.slice()}step(){const e=this.api._runtime(),t=[],r=l=>e.tensorFromArray([l],[],this.device),s=r(this.beta1),n=r(this.beta2),i=r(1-this.beta1),a=r(1-this.beta2),o=r(this.eps),u=this.weightDecay!==0?r(this.weightDecay):null;for(let l=0;l<this.params.length;l+=1){const d=this.params[l],c=d.grad?._unwrap()??null;if(!c){t.push(d);continue}const h=this.steps[l]+1;this.steps[l]=h;const f=1-this.beta1**h,w=1-this.beta2**h,m=r(this.lr*Math.sqrt(w)/f);let p=c;u&&(p=e.add(p,e.mul(d._unwrap(),u)));const g=this.expAvg[l],b=this.expAvgSq[l],v=g?e.add(e.mul(g,s),e.mul(p,i)):e.mul(p,i),k=e.mul(p,p),y=b?e.add(e.mul(b,n),e.mul(k,a)):e.mul(k,a);this.expAvg[l]=v,this.expAvgSq[l]=y;const x=e.add(e.sqrt(y),o),z=e.div(v,x),M=e.mul(z,m),D=e.sub(d._unwrap(),M);e.copy_(d._unwrap(),D),t.push(d)}return t}zeroGrad(){for(const e of this.params)e.zeroGrad()}},Ou=class{api;growthFactor;backoffFactor;growthInterval;enabled;_scale;_growthTracker;_foundInfThisStep;_unscaleCalled;constructor(e,t={}){this.api=e,this._scale=t.initScale??65536,this.growthFactor=t.growthFactor??2,this.backoffFactor=t.backoffFactor??.5,this.growthInterval=t.growthInterval??2e3,this.enabled=t.enabled??!0,this._growthTracker=0,this._foundInfThisStep=!1,this._unscaleCalled=!1}getScale(){return this._scale}get foundInf(){return this._foundInfThisStep}stateDict(){return{scale:this._scale,growthTracker:this._growthTracker}}loadStateDict(e){this._scale=e.scale,this._growthTracker=e.growthTracker}scale(e){if(!this.enabled)return e;const t=this.api.tensorFromArray([this._scale],[],{device:e.device});return this.api.mul(e,t)}async unscale_(e){if(!this.enabled){this._unscaleCalled=!0,this._foundInfThisStep=!1;return}this._foundInfThisStep=!1,this._unscaleCalled=!0;const t=e.getParams(),r=1/this._scale,s=this.api._runtime();for(const n of t){const i=n.grad;if(!i)continue;const a=this.api.tensorFromArray([r],[],{device:n.device}),o=this.api.mul(i,a);s.copy_(i._unwrap(),o._unwrap());const u=this.api.isfinite(o);(await this.api.sum(u).cpu())[0]<o.shape.reduce((l,d)=>l*d,1)&&(this._foundInfThisStep=!0)}}async step(e){if(!this._unscaleCalled)throw new Error("GradScaler.step() called before unscale_(). Call unscale_() first.");return this.enabled&&this._foundInfThisStep?!1:(e.step(),!0)}update(){if(!this.enabled){this._unscaleCalled=!1;return}if(!this._unscaleCalled)throw new Error("GradScaler.update() called before unscale_(). Call unscale_() first.");this._foundInfThisStep?(this._scale*=this.backoffFactor,this._growthTracker=0):(this._growthTracker+=1,this._growthTracker>=this.growthInterval&&(this._scale*=this.growthFactor,this._growthTracker=0)),this._foundInfThisStep=!1,this._unscaleCalled=!1}isEnabled(){return this.enabled}};class Vu{constructor(t,r,s,n){this.api=t,this.batchSize=s,this.seqLength=n,this.tokens=new Uint32Array(r)}tokens;currentIdx=0;hasMore(){return this.tokens.length>=this.batchSize*(this.seqLength+1)}reset(){this.currentIdx=0}nextBatch(){const t=[],r=[];for(let s=0;s<this.batchSize;s++){this.currentIdx+this.seqLength+1>this.tokens.length&&(this.currentIdx=Math.floor(Math.random()*(this.tokens.length-this.seqLength-1)));for(let n=0;n<this.seqLength;n++)t.push(this.tokens[this.currentIdx+n]),r.push(this.tokens[this.currentIdx+n+1]);this.currentIdx=Math.floor(Math.random()*(this.tokens.length-this.seqLength-1))}return{input:this.api.tensorFromArray(t,[this.batchSize,this.seqLength],{device:"webgpu"}),target:this.api.tensorFromArray(r,[this.batchSize,this.seqLength],{device:"webgpu"})}}}class ju{model;tokenizer;api;optimizer=null;gradScaler=null;constructor(t,r,s){this.api=t,this.model=r,this.tokenizer=s}async train(t,r,s={}){const n=r.useAMP??!1,i=r.useCheckpointing??!1,a=this.tokenizer.encode(t);if(a.length<r.batchSize*(r.seqLength+1))throw new Error(`Training text too short. Need at least ${r.batchSize*(r.seqLength+1)} tokens, got ${a.length}`);const o=new Vu(this.api,a,r.batchSize,r.seqLength),u=this.model.getLoRAParameters();this.optimizer=new Uu(u,{lr:r.learningRate},this.api),n&&(this.gradScaler=new Ou(this.api,{initScale:65536,growthFactor:2,backoffFactor:.5,growthInterval:2e3})),i&&this.model.enableCheckpointing(!0),this.model.train(!0);let l=0;const d=performance.now(),c=this.model,h=this.api,f=n?h.compile((m,p)=>h.autocast(()=>{const{loss:g}=c.forwardWithLoss(m,p);return g},{deviceType:"webgpu"})):null;for(let m=0;m<r.maxSteps&&!s.shouldStop?.();m++){s.onStepStart?.(m);const p=performance.now(),{input:g,target:b}=o.nextBatch();let v;if(n&&f?(v=f(g,b),v=this.gradScaler.scale(v)):v=this.model.forwardWithLoss(g,b).loss,await v.backward(),n&&this.gradScaler){await this.gradScaler.unscale_(this.optimizer);const x=await this.gradScaler.step(this.optimizer);this.gradScaler.update(),x||console.warn(`Step ${m}: Skipped due to NaN/Inf gradients, scale=${this.gradScaler.getScale()}`)}else this.optimizer.step();this.optimizer.zeroGrad();let k=await v.item();n&&this.gradScaler&&(k=k/this.gradScaler.getScale()),l=k,g.dispose(),b.dispose();const y=performance.now()-p;s.onStepEnd?.(m,k,y),await this.api.markStep()}this.model.train(!1),i&&this.model.enableCheckpointing(!1);const w=performance.now()-d;return{finalLoss:l,totalSteps:r.maxSteps,totalTimeMs:w}}getLoRAWeights(){const t=new Map,r=this.model.getLoRAParameters(),s=r.length/2;for(let n=0;n<s;n++){const i=r[n*2],a=r[n*2+1];t.set(`h.${n}.attn.c_attn.lora_A`,{data:new Float32Array([]),shape:i.shape}),t.set(`h.${n}.attn.c_attn.lora_B`,{data:new Float32Array([]),shape:a.shape})}return t}async exportLoRAWeights(){const t=new Map,r=this.model.getLoRAParameters(),s=r.length/2;for(let n=0;n<s;n++){const i=r[n*2],a=r[n*2+1],o=await i.cpu(),u=await a.cpu();t.set(`h.${n}.attn.c_attn.lora_A`,{data:new Float32Array(o),shape:i.shape}),t.set(`h.${n}.attn.c_attn.lora_B`,{data:new Float32Array(u),shape:a.shape})}return t}}const Wu="gpt2-lora-cache",Hu=1,Qe="weights",Ze="tokenizer";let Ut=null;async function Lt(){return Ut||new Promise((e,t)=>{const r=indexedDB.open(Wu,Hu);r.onerror=()=>t(r.error),r.onsuccess=()=>{Ut=r.result,e(Ut)},r.onupgradeneeded=s=>{const n=s.target.result;n.objectStoreNames.contains(Qe)||n.createObjectStore(Qe),n.objectStoreNames.contains(Ze)||n.createObjectStore(Ze)}})}async function Ku(e){const t=await Lt();return new Promise((r,s)=>{const a=t.transaction(Qe,"readwrite").objectStore(Qe).put({buffer:e,timestamp:Date.now(),version:1},"gpt2-weights");a.onerror=()=>s(a.error),a.onsuccess=()=>r()})}async function Hn(){try{const e=await Lt();return new Promise((t,r)=>{const i=e.transaction(Qe,"readonly").objectStore(Qe).get("gpt2-weights");i.onerror=()=>r(i.error),i.onsuccess=()=>{const a=i.result;a&&a.buffer?t(a.buffer):t(null)}})}catch{return null}}async function Yu(e){const t=await Lt();return new Promise((r,s)=>{const a=t.transaction(Ze,"readwrite").objectStore(Ze).put({...e,timestamp:Date.now(),version:1},"gpt2-tokenizer");a.onerror=()=>s(a.error),a.onsuccess=()=>r()})}async function Kn(){try{const e=await Lt();return new Promise((t,r)=>{const i=e.transaction(Ze,"readonly").objectStore(Ze).get("gpt2-tokenizer");i.onerror=()=>r(i.error),i.onsuccess=()=>{const a=i.result;a&&a.vocab&&a.merges?t({vocab:a.vocab,merges:a.merges}):t(null)}})}catch{return null}}async function Qu(){const e=await Lt();return new Promise((t,r)=>{const s=e.transaction([Qe,Ze],"readwrite");s.objectStore(Qe).clear(),s.objectStore(Ze).clear(),s.oncomplete=()=>t(),s.onerror=()=>r(s.error)})}async function Us(){const e=await Hn(),t=await Kn();return{hasWeights:e!==null,hasTokenizer:t!==null,weightsSize:e?.byteLength??0}}const jr="https://huggingface.co/openai-community/gpt2/resolve/main";async function Zu(e){e?.(0,100,"Checking local cache...");const t=await Hn();if(t){e?.(100,100,"Loading from cache...");const h=Os(t,e);return e?.(100,100,"Loaded from cache!"),h}e?.(0,100,"Downloading model weights (~500MB)...");const r=await fetch(`${jr}/model.safetensors`);if(!r.ok)throw new Error(`Failed to fetch weights: ${r.status} ${r.statusText}`);const s=r.headers.get("content-length"),n=s?parseInt(s,10):0,i=r.body?.getReader();if(!i)throw new Error("Failed to get response reader");const a=[];let o=0;for(;;){const{done:h,value:f}=await i.read();if(h)break;if(a.push(f),o+=f.length,n>0){const w=Math.round(o/n*100);e?.(o,n,`Downloading: ${w}% (${xr(o)} / ${xr(n)})`)}else e?.(o,0,`Downloading: ${xr(o)}`)}const u=a.reduce((h,f)=>h+f.length,0),l=new ArrayBuffer(u),d=new Uint8Array(l);let c=0;for(const h of a)d.set(h,c),c+=h.length;e?.(n,n,"Caching locally...");try{await Ku(l)}catch(h){console.warn("Failed to cache weights:",h)}return e?.(n,n,"Parsing weights..."),Os(l,e)}async function Xu(e){const t=await Kn();if(t)return e?.(2,2,"Tokenizer loaded from cache!"),t;e?.(0,2,"Fetching tokenizer...");const[r,s]=await Promise.all([fetch(`${jr}/vocab.json`),fetch(`${jr}/merges.txt`)]);if(!r.ok||!s.ok)throw new Error("Failed to fetch tokenizer files");e?.(1,2,"Parsing tokenizer...");const n=await r.json(),a=(await s.text()).split(`
`).slice(1).filter(o=>o.trim());try{await Yu({vocab:n,merges:a})}catch(o){console.warn("Failed to cache tokenizer:",o)}return e?.(2,2,"Tokenizer ready"),{vocab:n,merges:a}}function Os(e,t){const r=new DataView(e),s=Number(r.getBigUint64(0,!0)),n=new Uint8Array(e,8,s),i=new TextDecoder().decode(n),a=JSON.parse(i),o=8+s,u=new Map,l=Object.entries(a).filter(([c])=>c!=="__metadata__");let d=0;for(const[c,h]of l){const f=h,[w,m]=f.data_offsets,p=new Uint8Array(e,o+w,m-w);let g;switch(f.dtype){case"F32":{const b=new ArrayBuffer(p.length);new Uint8Array(b).set(p),g=new Float32Array(b);break}case"F16":g=Ju(p);break;case"BF16":g=tl(p);break;default:console.warn(`Unsupported dtype: ${f.dtype} for ${c}`);continue}u.set(c,{data:g,shape:f.shape}),d++,t&&d%10===0&&t(d,l.length,`Loading tensors: ${d}/${l.length}`)}return u}function Ju(e){const t=new ArrayBuffer(e.length);new Uint8Array(t).set(e);const r=new Uint16Array(t),s=new Float32Array(r.length);for(let n=0;n<r.length;n++)s[n]=el(r[n]);return s}function el(e){const t=(e&32768)>>15,r=(e&31744)>>10,s=e&1023;return r===0?s===0?t?-0:0:(t?-1:1)*Math.pow(2,-14)*(s/1024):r===31?s===0?t?-1/0:1/0:NaN:(t?-1:1)*Math.pow(2,r-15)*(1+s/1024)}function tl(e){const t=new ArrayBuffer(e.length);new Uint8Array(t).set(e);const r=new Uint16Array(t),s=new Float32Array(r.length);for(let n=0;n<r.length;n++){const i=r[n]<<16,a=new Float32Array(1);new Uint32Array(a.buffer)[0]=i,s[n]=a[0]}return s}function xr(e){return e<1024?`${e} B`:e<1024*1024?`${(e/1024).toFixed(1)} KB`:e<1024*1024*1024?`${(e/(1024*1024)).toFixed(1)} MB`:`${(e/(1024*1024*1024)).toFixed(1)} GB`}function rl(e,t){const r={__metadata__:t};let s=0;const n=new Map;for(const[f,{data:w,shape:m}]of e){const p=s,g=w.byteLength;s+=g,r[f]={dtype:"F32",shape:m,data_offsets:[p,p+g]},n.set(f,[p,p+g])}const i=JSON.stringify(r),a=new TextEncoder().encode(i),o=Math.ceil(a.length/8)*8,u=8+o+s,l=new ArrayBuffer(u),d=new DataView(l),c=new Uint8Array(l);d.setBigUint64(0,BigInt(o),!0),c.set(a,8);let h=8+o;for(const[f,{data:w}]of e)new Float32Array(l,h,w.length).set(w),h+=w.byteLength;return l}var V=class Wr{shape;strides;data;offset;sizeValue;constructor(t,r,s,n=0,i=!0){let a=Re(t);if(i&&a!==r.length)throw Error("Tensor data length does not match shape");this.shape=t.slice(),this.strides=(s??K(t)).slice(),this.data=r,this.offset=n,this.sizeValue=a}get size(){return this.sizeValue}view(t){if(Re(t)!==this.size)throw Error("View shape does not match tensor size");if(!Ar(this))throw Error("View requires contiguous tensor");let r=K(t);return new Wr(t,this.data,r,this.offset)}isContiguous(){return Ar(this)}contiguous(){if(Ar(this))return this;let t=new Float32Array(this.size),r=K(this.shape);for(let s=0;s<this.size;s++)t[s]=U(this,s,r);return new Wr(this.shape,t)}toArray(){let t=Array(this.sizeValue);if(this.sizeValue===0)return t;let r=K(this.shape);for(let s=0;s<this.sizeValue;s+=1)t[s]=U(this,s,r);return t}};function sl(e,t){return new V(t,Float32Array.from(e))}function Yn(e,t){return Ae(e,t)}function nl(e,t,r){let s=r?.alpha??1,n=xt(e.shape,t.shape),i=Ae(e,n),a=Ae(t,n),o=Re(n),u=new Float32Array(o),l=K(n);for(let d=0;d<o;d+=1)u[d]=U(i,d,l)-s*U(a,d,l);return new V(n,u)}function il(e,t,r){let s=r?.roundingMode??null,n=xt(e.shape,t.shape),i=Ae(e,n),a=Ae(t,n),o=Re(n),u=new Float32Array(o),l=K(n);for(let d=0;d<o;d+=1){let c=U(i,d,l)/U(a,d,l);s==="floor"?c=Math.floor(c):s==="trunc"&&(c=Math.trunc(c)),u[d]=c}return new V(n,u)}function Qn(e,t){return e.view(t)}function al(e){return e.contiguous()}function Zn(e,t){if(!t)throw Error("transpose requires options.dim0 and options.dim1");let r=e.shape.length,s=Zt(t.dim0,r),n=Zt(t.dim1,r);if(s===n)return e;let i=e.shape.slice(),a=e.strides.slice();return[i[s],i[n]]=[i[n],i[s]],[a[s],a[n]]=[a[n],a[s]],new V(i,e.data,a,e.offset,!1)}function ol(e,t){let r=e.shape.length;if(t.length!==r)throw Error(`permute: dims length ${t.length} doesn't match tensor rank ${r}`);let s=new Set;for(let o of t){let u=o<0?o+r:o;if(u<0||u>=r)throw Error(`permute: dimension ${o} out of range for rank ${r}`);if(s.has(u))throw Error(`permute: duplicate dimension ${o}`);s.add(u)}let n=t.map(o=>o<0?o+r:o),i=n.map(o=>e.shape[o]),a=n.map(o=>e.strides[o]);return new V(i,e.data,a,e.offset,!1)}function ul(e,t){let r=xt(e.shape,t.shape),s=Ae(e,r),n=Ae(t,r),i=Re(r),a=new Float32Array(i),o=K(r);for(let u=0;u<i;u+=1)a[u]=U(s,u,o)+U(n,u,o);return new V(r,a)}function ll(e,t){let r=xt(e.shape,t.shape),s=Ae(e,r),n=Ae(t,r),i=Re(r),a=new Float32Array(i),o=K(r);for(let u=0;u<i;u+=1)a[u]=U(s,u,o)*U(n,u,o);return new V(r,a)}function Xn(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1){let n=U(e,s,r);t[s]=n>0?n:0}return new V(e.shape,t)}function Jn(e,t){let r=e.shape.length,s=t.shape.length;if(r===0||s===0)throw Error("matmul does not support scalar inputs");let n=r===1,i=s===1,a=n?new V([1,e.shape[0]],e.data,[0,e.strides[0]],e.offset,!1):e,o=i?new V([t.shape[0],1],t.data,[t.strides[0],0],t.offset,!1):t;if(a.shape.length<2||o.shape.length<2)throw Error("matmul requires tensors with at least 1 dimension");let u=a.shape[a.shape.length-2],l=a.shape[a.shape.length-1],d=o.shape[o.shape.length-2],c=o.shape[o.shape.length-1];if(l!==d)throw Error("matmul dimension mismatch");let h=xt(a.shape.slice(0,-2),o.shape.slice(0,-2)),f=Ae(a,h.concat([u,l])),w=Ae(o,h.concat([l,c])),m=Re(h),p=new Float32Array(m*u*c),g=h.length,b=K(h),v=f.strides.slice(0,g),k=w.strides.slice(0,g),y=f.strides[g],x=f.strides[g+1],z=w.strides[g],M=w.strides[g+1];for(let B=0;B<m;B+=1){let R=Hr(B,b,v,f.offset),L=Hr(B,b,k,w.offset),q=B*u*c;for(let _=0;_<u;_+=1){let T=R+_*y,$=q+_*c;for(let P=0;P<c;P+=1){let j=0;for(let A=0;A<l;A+=1)j+=f.data[T+A*x]*w.data[L+A*z+P*M];p[$+P]=j}}}let D=h.concat([u,c]);return n&&i?new V([],p):n?new V(h.concat([c]),p):i?new V(h.concat([u]),p):new V(D,p)}function ei(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.sqrt(U(e,s,r));return new V(e.shape,t)}function dl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.exp(U(e,s,r));return new V(e.shape,t)}function cl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.log(U(e,s,r));return new V(e.shape,t)}function hl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1)t[s]=-U(e,s,r);return new V(e.shape,t)}function pl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.abs(U(e,s,r));return new V(e.shape,t)}function fl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1)t[s]=Math.tanh(U(e,s,r));return new V(e.shape,t)}function ml(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1){let n=U(e,s,r);t[s]=1/(1+Math.exp(-n))}return new V(e.shape,t)}function gl(e){let t=e<0?-1:1;e=Math.abs(e);let r=1/(1+.3275911*e);return t*(1-((((1.061405429*r+-1.453152027)*r+1.421413741)*r+-.284496736)*r+.254829592)*r*Math.exp(-e*e))}function wl(e,t){let r=t?.approximate??"tanh",s=new Float32Array(e.size),n=K(e.shape);if(r==="tanh")for(let i=0;i<e.size;i+=1){let a=U(e,i,n);s[i]=a*.5*(1+Math.tanh(.7978845608*(a+.044715*a*a*a)))}else for(let i=0;i<e.size;i+=1){let a=U(e,i,n);s[i]=a*.5*(1+gl(a*.7071067811865476))}return new V(e.shape,s)}function yl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1){let n=U(e,s,r);t[s]=n/(1+Math.exp(-n))}return new V(e.shape,t)}function bl(e){let t=new Float32Array(e.size),r=K(e.shape);for(let s=0;s<e.size;s+=1){let n=U(e,s,r);t[s]=Number.isFinite(n)?1:0}return new V(e.shape,t)}function K(e){let t=Array(e.length),r=1;for(let s=e.length-1;s>=0;--s)t[s]=r,r*=e[s];return t}function Re(e){return e.reduce((t,r)=>t*r,1)}function Ar(e){let t=K(e.shape);if(t.length!==e.strides.length)return!1;for(let r=0;r<t.length;r+=1)if(!(e.shape[r]<=1)&&e.strides[r]!==t[r])return!1;return!0}function Hr(e,t,r,s){let n=e,i=s;for(let a=0;a<t.length;a+=1){let o=t[a],u=o===0?0:Math.floor(n/o);n-=u*o,i+=u*r[a]}return i}function U(e,t,r){let s=Hr(t,r,e.strides,e.offset);return e.data[s]}function xt(e,t){let r=Math.max(e.length,t.length),s=Array(r);for(let n=0;n<r;n+=1){let i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw Error("shapes are not broadcastable");s[r-1-n]=Math.max(i,a)}return s}function Ae(e,t){if(e.shape.length===t.length&&e.shape.every((n,i)=>n===t[i]))return e;if(e.shape.length>t.length)throw Error("broadcast target has fewer dimensions than input");let r=t.length-e.shape.length,s=Array(t.length);for(let n=0;n<t.length;n+=1){let i=n-r;if(i<0){s[n]=0;continue}let a=e.shape[i];if(a===t[n])s[n]=e.strides[i];else if(a===1)s[n]=0;else throw Error("broadcast target shape is incompatible")}return new V(t,e.data,s,e.offset,!1)}function Zt(e,t){let r=e<0?t+e:e;if(r<0||r>=t)throw Error(`dim out of range: ${e}`);return r}function ti(e,t){if(!Number.isFinite(e)||Math.trunc(e)!==e)throw Error("index values must be integers");if(e<0||e>=t)throw Error("index out of range");return e}function ri(e,t,r){if(!r)throw Error("gather requires options.dim");let s=e.shape.length;if(t.shape.length!==s)throw Error("gather requires index with the same rank as input");let n=Zt(r.dim,s);for(let u=0;u<s;u+=1)if(u!==n&&t.shape[u]>e.shape[u])throw Error("gather index shape must be <= input shape");let i=new Float32Array(t.size),a=K(t.shape),o=e.strides;for(let u=0;u<t.size;u+=1){let l=u,d=0;for(let c=0;c<s;c+=1){let h=a[c],f=Math.floor(l/h);if(l-=f*h,c===n){let w=ti(U(t,u,a),e.shape[n]);d+=w*o[c]}else d+=f*o[c]}i[u]=e.data[d+e.offset]}return new V(t.shape,i)}function si(e,t,r,s){if(!s)throw Error("scatterAdd requires options.dim");let n=e.shape.length;if(t.shape.length!==n||r.shape.length!==n)throw Error("scatterAdd requires index/src with the same rank as input");let i=Zt(s.dim,n);for(let d=0;d<n;d+=1){if(t.shape[d]!==r.shape[d])throw Error("scatterAdd requires index and src to have the same shape");if(d!==i&&t.shape[d]>e.shape[d])throw Error("scatterAdd index shape must be <= input shape")}let a=new Float32Array(e.size),o=K(e.shape);for(let d=0;d<e.size;d+=1)a[d]=U(e,d,o);let u=K(t.shape),l=K(e.shape);for(let d=0;d<t.size;d+=1){let c=d,h=0;for(let f=0;f<n;f+=1){let w=u[f],m=Math.floor(c/w);if(c-=m*w,f===i){let p=ti(U(t,d,u),e.shape[i]);h+=p*l[f]}else h+=m*l[f]}a[h]+=U(r,d,u)}return new V(e.shape,a)}function ni(e){let t=0,r=K(e.shape);for(let s=0;s<e.size;s+=1)t+=U(e,s,r);return t}function ii(e,t){let r=(Array.isArray(e)?e.slice():[e]).map(n=>n<0?t+n:n),s=new Set;for(let n of r){if(n<0||n>=t)throw Error(`sum dim out of range: ${n}`);if(s.has(n))throw Error(`sum dim repeated: ${n}`);s.add(n)}return Array.from(s).sort((n,i)=>n-i)}function Kr(e,t){if(!t||t.dim==null)return new V([],new Float32Array([ni(e)]));if(t.dtype!=null)throw Error("sum dtype option is not supported yet");let r=e.shape.length,s=ii(t.dim,r),n=t.keepdim??!1,i=new Set(s),a=n?e.shape.map((c,h)=>i.has(h)?1:c):e.shape.filter((c,h)=>!i.has(h)),o=a.reduce((c,h)=>c*h,1)||1,u=new Float32Array(o),l=K(e.shape),d=K(a);for(let c=0;c<e.size;c+=1){let h=c,f=0;if(n)for(let w=0;w<r;w+=1){let m=l[w],p=Math.floor(h/m);h-=p*m,i.has(w)||(f+=p*d[w])}else{let w=0;for(let m=0;m<r;m+=1){let p=l[m],g=Math.floor(h/p);h-=g*p,i.has(m)||(f+=g*d[w],w+=1)}}u[f]+=U(e,c,l)}return new V(a,u)}function vl(e){let t=-1/0,r=K(e.shape);for(let s=0;s<e.size;s+=1){let n=U(e,s,r);n>t&&(t=n)}return t}function _l(e,t){if(!t||t.dim==null)return new V([],new Float32Array([vl(e)]));let r=e.shape.length,s=kl(t.dim,r,"max"),n=t.keepdim??!1,i=new Set(s),a=n?e.shape.map((c,h)=>i.has(h)?1:c):e.shape.filter((c,h)=>!i.has(h)),o=a.reduce((c,h)=>c*h,1)||1,u=new Float32Array(o);u.fill(-1/0);let l=K(e.shape),d=K(a);for(let c=0;c<e.size;c+=1){let h=c,f=0;if(n)for(let m=0;m<r;m+=1){let p=l[m],g=Math.floor(h/p);h-=g*p,i.has(m)||(f+=g*d[m])}else{let m=0;for(let p=0;p<r;p+=1){let g=l[p],b=Math.floor(h/g);h-=b*g,i.has(p)||(f+=b*d[m],m+=1)}}let w=U(e,c,l);w>u[f]&&(u[f]=w)}return new V(a,u)}function kl(e,t,r){let s=(Array.isArray(e)?e.slice():[e]).map(i=>i<0?t+i:i),n=new Set;for(let i of s){if(i<0||i>=t)throw Error(`${r} dim out of range: ${i}`);if(n.has(i))throw Error(`${r} dim repeated: ${i}`);n.add(i)}return Array.from(n).sort((i,a)=>i-a)}function Sl(e,t){let r=e.shape.length,s=t.dim<0?t.dim+r:t.dim;if(s<0||s>=r)throw Error(`argmax: dim ${t.dim} out of range for tensor of rank ${r}`);let n=t.keepdim??!1,i=n?e.shape.map((c,h)=>h===s?1:c):e.shape.filter((c,h)=>h!==s),a=i.reduce((c,h)=>c*h,1)||1,o=new Float32Array(a),u=new Float32Array(a);u.fill(-1/0);let l=K(e.shape),d=K(i);e.shape[s];for(let c=0;c<e.size;c+=1){let h=c,f=0,w=0;if(n)for(let p=0;p<r;p+=1){let g=l[p],b=Math.floor(h/g);h-=b*g,p===s?w=b:f+=b*d[p]}else{let p=0;for(let g=0;g<r;g+=1){let b=l[g],v=Math.floor(h/b);h-=v*b,g===s?w=v:(f+=v*d[p],p+=1)}}let m=U(e,c,l);m>u[f]&&(u[f]=m,o[f]=w)}return new V(i,o)}function xl(e,t){let r=e.shape.length,s=t.dim<0?t.dim+r:t.dim;if(s<0||s>=r)throw Error(`argmin: dim ${t.dim} out of range for tensor of rank ${r}`);let n=t.keepdim??!1,i=n?e.shape.map((c,h)=>h===s?1:c):e.shape.filter((c,h)=>h!==s),a=i.reduce((c,h)=>c*h,1)||1,o=new Float32Array(a),u=new Float32Array(a);u.fill(1/0);let l=K(e.shape),d=K(i);for(let c=0;c<e.size;c+=1){let h=c,f=0,w=0;if(n)for(let p=0;p<r;p+=1){let g=l[p],b=Math.floor(h/g);h-=b*g,p===s?w=b:f+=b*d[p]}else{let p=0;for(let g=0;g<r;g+=1){let b=l[g],v=Math.floor(h/b);h-=v*b,g===s?w=v:(f+=v*d[p],p+=1)}}let m=U(e,c,l);m<u[f]&&(u[f]=m,o[f]=w)}return new V(i,o)}function Al(e,t){let{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=At(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=U(r,u,a)>U(s,u,a)?1:0;return new V(n,o)}function El(e,t){let{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=At(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=U(r,u,a)<U(s,u,a)?1:0;return new V(n,o)}function Il(e,t){let{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=At(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=U(r,u,a)>=U(s,u,a)?1:0;return new V(n,o)}function $l(e,t){let{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=At(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=U(r,u,a)<=U(s,u,a)?1:0;return new V(n,o)}function zl(e,t){let{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=At(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=U(r,u,a)===U(s,u,a)?1:0;return new V(n,o)}function Cl(e,t){let{aBroadcast:r,bBroadcast:s,outShape:n,outSize:i,shapeStrides:a}=At(e,t),o=new Float32Array(i);for(let u=0;u<i;u+=1)o[u]=U(r,u,a)===U(s,u,a)?0:1;return new V(n,o)}function At(e,t){let r=xt(e.shape,t.shape);return{aBroadcast:Ae(e,r),bBroadcast:Ae(t,r),outShape:r,outSize:Re(r),shapeStrides:K(r)}}function Tl(e,t,r){let s=Bl(e.shape,t.shape,r.shape),n=Ae(e,s),i=Ae(t,s),a=Ae(r,s),o=Re(s),u=new Float32Array(o),l=K(s);for(let d=0;d<o;d+=1){let c=U(n,d,l),h=U(i,d,l),f=U(a,d,l);u[d]=c===0?f:h}return new V(s,u)}function Bl(e,t,r){let s=Math.max(e.length,t.length,r.length),n=Array(s);for(let i=0;i<s;i+=1){let a=e[e.length-1-i]??1,o=t[t.length-1-i]??1,u=r[r.length-1-i]??1;if(a!==o&&a!==1&&o!==1||a!==u&&a!==1&&u!==1||o!==u&&o!==1&&u!==1)throw Error("shapes are not broadcastable");n[s-1-i]=Math.max(a,o,u)}return n}function Ml(e,t,r){let{offset:s,viewShape:n,viewStrides:i}=r;if(t.shape.length!==n.length)throw Error(`stridedScatterCopy: src rank ${t.shape.length} doesn't match view rank ${n.length}`);for(let l=0;l<n.length;l++)if(t.shape[l]!==n[l])throw Error(`stridedScatterCopy: src shape [${t.shape}] doesn't match view shape [${n}]`);let a=new Float32Array(e.data.length);a.set(e.data);let o=Re(n),u=K(n);for(let l=0;l<o;l++){let d=l,c=s;for(let h=0;h<n.length;h++){let f=u[h],w=Math.floor(d/f);d-=w*f,c+=w*i[h]}a[c]=U(t,l,u)}return new V(e.shape,a,K(e.shape),0)}function Dl(e,t,r){let{offset:s,viewShape:n,viewStrides:i}=r;if(t.shape.length!==n.length)throw Error(`stridedScatterAdd: src rank ${t.shape.length} doesn't match view rank ${n.length}`);for(let l=0;l<n.length;l++)if(t.shape[l]!==n[l])throw Error(`stridedScatterAdd: src shape [${t.shape}] doesn't match view shape [${n}]`);let a=new Float32Array(e.data.length);a.set(e.data);let o=Re(n),u=K(n);for(let l=0;l<o;l++){let d=l,c=s;for(let f=0;f<n.length;f++){let w=u[f],m=Math.floor(d/w);d-=m*w,c+=m*i[f]}let h=U(t,l,u);a[c]+=h}return new V(e.shape,a,K(e.shape),0)}function Yr(e,t){if(!t||t.dim==null)return new V([],new Float32Array([ni(e)/e.size]));if(t.dtype!=null)throw Error("mean dtype option is not supported yet");let r=e.shape.length,s=ii(t.dim,r),n=t.keepdim??!1,i=new Set(s),a=s.reduce((f,w)=>f*e.shape[w],1),o=n?e.shape.map((f,w)=>i.has(w)?1:f):e.shape.filter((f,w)=>!i.has(w)),u=o.reduce((f,w)=>f*w,1)||1,l=new Float32Array(u),d=K(e.shape),c=K(o);for(let f=0;f<e.size;f+=1){let w=f,m=0;if(n)for(let p=0;p<r;p+=1){let g=d[p],b=Math.floor(w/g);w-=b*g,i.has(p)||(m+=b*c[p])}else{let p=0;for(let g=0;g<r;g+=1){let b=d[g],v=Math.floor(w/b);w-=v*b,i.has(g)||(m+=v*c[p],p+=1)}}l[m]+=U(e,f,d)}let h=a||0;for(let f=0;f<l.length;f+=1)l[f]=l[f]/h;return new V(o,l)}function Rl(e){return Promise.resolve(e.toArray())}function Pl(e,t){return e}const Qr={name:"cpu",ops:{tensorFromArray:sl,add:ul,sub:nl,div:il,mul:ll,matmul:Jn,sqrt:ei,relu:Xn,exp:dl,log:cl,neg:hl,abs:pl,tanh:fl,sigmoid:ml,gelu:wl,silu:yl,isfinite:bl,gather:ri,scatterAdd:si,sum:Kr,max:_l,mean:Yr,argmax:Sl,argmin:xl,gt:Al,lt:El,ge:Il,le:$l,eq:zl,ne:Cl,expand:Yn,reshape:Qn,transpose:Zn,permute:ol,contiguous:al,cast:Pl,where:Tl,stridedScatterCopy:Ml,stridedScatterAdd:Dl,read:Rl}};function Fl(e,t){return new V(t,Float32Array.from(e))}function Ll(e,t){return new V(e.shape,Float32Array.from(e.toArray()))}function Nl(e,t,r){return new V(e.shape,Float32Array.from(e.toArray()))}function ql(e,t,r){return new V(e.shape,Float32Array.from(e.toArray()))}function Gl(e,t){return new V(e.shape,Float32Array.from(e.toArray()))}function Ul(e,t){return Jn(e,t)}function Ol(e){return ei(e)}function Vl(e){return Xn(e)}function jl(e,t){return Yn(e,t)}function Wl(e,t){return Qn(e,t)}function Hl(e,t){return Zn(e,t)}function Kl(e,t,r){return ri(e,t,r)}function Yl(e,t,r,s){return si(e,t,r,s)}function Ql(e,t){return t?.dim==null?Kr(e):Kr(e,t)}function Zl(e,t){return t?.dim==null?Yr(e):Yr(e,t)}function Xl(e){return Promise.resolve(e.toArray())}const Vs={name:"mock",ops:{tensorFromArray:Fl,add:Ll,sub:Nl,div:ql,mul:Gl,matmul:Ul,sqrt:Ol,relu:Vl,expand:jl,reshape:Wl,transpose:Hl,gather:Kl,scatterAdd:Yl,sum:Ql,mean:Zl,read:Xl}},Xt=new Map;Xt.set(Qr.name,Qr),Xt.set(Vs.name,Vs);let Jl=Qr;function We(e){return Xt.get(e)}function ed(e){Xt.set(e.name,e)}function Er(){return Jl}const td=new Set(["add","sub","mul","div","sqrt","relu","neg","abs","exp","log","sigmoid","tanh","gelu","silu"]);function ai(e){return td.has(e)}function rd(e){let t=[],r=null,s=0,n=()=>{if(r&&r.nodes.length>=2){let i=sd(r.nodes,new Set(r.nodes.map(a=>a.id)));t.push({nodes:r.nodes,planIndices:r.indices,externalInputs:i,outputNode:r.nodes[r.nodes.length-1]})}r=null};for(let i=0;i<e.length;i++){let a=e[i];ai(a.op)?(s++,r||={nodes:[],indices:[]},r.nodes.push(a),r.indices.push(i)):n()}return n(),{groups:t,stats:{totalNodes:e.length,fusibleNodes:s,groupCount:t.length,nodesInGroups:t.reduce((i,a)=>i+a.nodes.length,0)}}}function sd(e,t){let r=[],s=new Set;for(let n of e)for(let i of n.inputs)i.kind==="materialized"?s.has(i.storage.id)||(s.add(i.storage.id),r.push(i)):i.kind==="pending"&&!t.has(i.node.id)&&!s.has(i.node.id)&&(s.add(i.node.id),r.push(i));return r}function nd(e){let t=e.nodes.map(l=>l.id),r=new Set(t),s=new Map,n=[],i=l=>{let d=l.kind==="materialized"?-l.storage.id:l.node.id;if(s.has(d))return s.get(d);let c=n.length;return s.set(d,-(c+1)),l.kind==="materialized"?n.push({id:d,index:c,shape:[l.storage.backendTensor.shape.reduce((h,f)=>h*f,1)],dtype:"f32"}):n.push({id:l.node.id,index:c,shape:l.node.shape??[1],dtype:l.node.dtype??"f32"}),-(c+1)},a=[];for(let l of e.nodes){let d=[];for(let c of l.inputs)if(c.kind==="pending"&&r.has(c.node.id))d.push(c.node.id);else{let h=i(c);d.push(h)}a.push({id:l.id,op:l.op,inputs:d,shape:l.shape??[1],dtype:l.dtype??"f32",isOutput:l===e.outputNode})}let o=e.outputNode,u=[{nodeId:o.id,index:0,shape:o.shape??[1],dtype:o.dtype??"f32"}];return{id:`lazy_fused_${t.join("_")}`,nodes:a,inputs:n,outputs:u}}function id(e){let{groups:t}=rd(e),r=[],s=new Map;for(let i of t)for(let a of i.planIndices)s.set(a,i);let n=0;for(;n<e.length;){let i=s.get(n);if(i){let a=nd(i);r.push({kind:"fused",group:i,recipe:a}),n=Math.max(...i.planIndices)+1}else{let a=[];for(;n<e.length&&!s.has(n);)a.push(e[n]),n++;a.length>0&&r.push({kind:"sequential",nodes:a})}}return r}function ad(e){let t=0;for(let r of e)if(ai(r.op)){if(t++,t>=2)return!0}else t=0;return!1}function J(e){return{kind:"pending",node:e}}function Ir(e){return e.kind==="materialized"}function od(e){let t=[],r=new Set,s=n=>{if(n.kind!=="materialized"&&!r.has(n.node.id)){r.add(n.node.id);for(let i of n.node.inputs)s(i);t.push(n.node)}};return s({kind:"pending",node:e}),{nodes:t}}let ud=1;function ee(e,t,r,s,n,i){return{id:ud++,op:e,inputs:t,shape:r,dtype:s,device:n,payload:i}}let ld=1;const ct=new class{allStorages=new Map;externallyReachable=new Set;register(e){this.allStorages.set(e.id,e)}markReachable(e){this.externallyReachable.add(e)}markUnreachable(e){this.externallyReachable.delete(e)}isReachable(e){return this.externallyReachable.has(e)}unregister(e){this.allStorages.delete(e),this.externallyReachable.delete(e)}destroyUnreachable(){let e=0,t=new Set,r=[...this.externallyReachable];for(;r.length>0;){let n=r.pop(),i=this.allStorages.get(n);i?.baseStorageId!==void 0&&!t.has(i.baseStorageId)&&(t.add(i.baseStorageId),r.push(i.baseStorageId))}let s=[];for(let[n,i]of this.allStorages)!this.externallyReachable.has(n)&&!t.has(n)&&s.push(n);for(let n of s){let i=this.allStorages.get(n);if(i){let a=i.backendTensor;a.ownsBuffer!==!1&&a.destroy&&a.destroy(),this.allStorages.delete(n),e++}}return e}stats(){return{totalStorages:this.allStorages.size,reachableStorages:this.externallyReachable.size,unreachableStorages:this.allStorages.size-this.externallyReachable.size}}reset(){this.allStorages.clear(),this.externallyReachable.clear()}};function ar(e,t,r){let s={id:ld++,device:e,backendTensor:t,baseStorageId:r};return ct.register(s),s}function oi(e){if(e.kind==="materialized")return e.storage;if(e.node.result)return e.node.result;throw Error("Input not ready")}async function ui(e,t){if(e.nodes.length===0)throw Error("Cannot execute empty plan");for(let s of e.nodes){let n=s.inputs.map(oi),i=n.map(l=>l.backendTensor),a=We(s.device)??t,o;switch(s.op){case"tensorFromArray":{let l=s.payload;if(!l?.values)throw Error("tensorFromArray requires values in payload");o=a.ops.tensorFromArray(l.values,s.shape);break}case"add":o=a.ops.add(i[0],i[1]);break;case"sub":{let l=s.payload;o=a.ops.sub(i[0],i[1],l);break}case"mul":o=a.ops.mul(i[0],i[1]);break;case"div":{let l=s.payload;o=a.ops.div(i[0],i[1],l);break}case"matmul":o=a.ops.matmul(i[0],i[1]);break;case"sqrt":o=a.ops.sqrt(i[0]);break;case"relu":o=a.ops.relu(i[0]);break;case"exp":if(!a.ops.exp)throw Error("exp not supported by backend");o=a.ops.exp(i[0]);break;case"log":if(!a.ops.log)throw Error("log not supported by backend");o=a.ops.log(i[0]);break;case"neg":if(!a.ops.neg)throw Error("neg not supported by backend");o=a.ops.neg(i[0]);break;case"abs":if(!a.ops.abs)throw Error("abs not supported by backend");o=a.ops.abs(i[0]);break;case"tanh":if(!a.ops.tanh)throw Error("tanh not supported by backend");o=a.ops.tanh(i[0]);break;case"sigmoid":if(!a.ops.sigmoid)throw Error("sigmoid not supported by backend");o=a.ops.sigmoid(i[0]);break;case"gelu":{if(!a.ops.gelu)throw Error("gelu not supported by backend");let l=s.payload;o=a.ops.gelu(i[0],l);break}case"silu":if(!a.ops.silu)throw Error("silu not supported by backend");o=a.ops.silu(i[0]);break;case"isfinite":if(!a.ops.isfinite)throw Error("isfinite not supported by backend");o=a.ops.isfinite(i[0]);break;case"reshape":{let l=s.payload?.targetShape??s.shape;o=a.ops.reshape(i[0],l);break}case"expand":o=a.ops.expand(i[0],s.shape);break;case"transpose":{let l=s.payload;if(!l)throw Error("transpose requires dim0 and dim1 in payload");o=a.ops.transpose(i[0],l);break}case"permute":{let l=s.payload;if(!l)throw Error("permute requires dims in payload");o=a.ops.permute(i[0],l.dims);break}case"contiguous":o=a.ops.contiguous(i[0]);break;case"cast":{let l=s.payload;if(!l)throw Error("cast requires dtype in payload");if(!a.ops.cast)throw Error("cast not supported by backend");o=a.ops.cast(i[0],l.dtype);break}case"gather":{let l=s.payload;if(!l)throw Error("gather requires dim in payload");o=a.ops.gather(i[0],i[1],l);break}case"scatterAdd":{let l=s.payload;if(!l)throw Error("scatterAdd requires dim in payload");o=a.ops.scatterAdd(i[0],i[1],i[2],l);break}case"sum":{let l=s.payload;o=a.ops.sum(i[0],l);break}case"max":{let l=s.payload;o=a.ops.max(i[0],l);break}case"mean":{let l=s.payload;o=a.ops.mean(i[0],l);break}case"argmax":{let l=s.payload;if(!a.ops.argmax)throw Error("argmax not supported by backend");o=a.ops.argmax(i[0],l);break}case"argmin":{let l=s.payload;if(!a.ops.argmin)throw Error("argmin not supported by backend");o=a.ops.argmin(i[0],l);break}case"gt":if(!a.ops.gt)throw Error("gt not supported by backend");o=a.ops.gt(i[0],i[1]);break;case"lt":if(!a.ops.lt)throw Error("lt not supported by backend");o=a.ops.lt(i[0],i[1]);break;case"ge":if(!a.ops.ge)throw Error("ge not supported by backend");o=a.ops.ge(i[0],i[1]);break;case"le":if(!a.ops.le)throw Error("le not supported by backend");o=a.ops.le(i[0],i[1]);break;case"eq":if(!a.ops.eq)throw Error("eq not supported by backend");o=a.ops.eq(i[0],i[1]);break;case"ne":if(!a.ops.ne)throw Error("ne not supported by backend");o=a.ops.ne(i[0],i[1]);break;case"where":o=a.ops.where(i[0],i[1],i[2]);break;case"stridedScatterCopy":{let l=s.payload;if(!l)throw Error("stridedScatterCopy requires options in payload");o=a.ops.stridedScatterCopy(i[0],i[1],l);break}case"stridedScatterAdd":{let l=s.payload;if(!l)throw Error("stridedScatterAdd requires options in payload");o=a.ops.stridedScatterAdd(i[0],i[1],l);break}case"transfer":{let l=n[0],d=s.device,c=l.device;if(c===d)o=l.backendTensor;else{let h=We(d);if(!h)throw Error(`Transfer failed: backend not available for ${d}`);let f=We(c);if(!f)throw Error(`Transfer failed: backend not available for ${c}`);let w=await f.ops.read(l.backendTensor);o=h.ops.tensorFromArray(w,s.shape)}break}default:throw Error(`Unknown op: ${s.op}`)}let u=o.ownsBuffer===!1&&n.length>0?n[0].id:void 0;s.result=ar(s.device,o,u)}let r=e.nodes[e.nodes.length-1];if(!r.result)throw Error("Execution failed: no result for last node");return r.result}async function dd(e,t,r={}){if(e.nodes.length===0)throw Error("Cannot execute empty plan");let{enableFusion:s=t.name==="webgpu",enableVectorization:n=!0,minFusionSize:i=2}=r,a={totalNodes:e.nodes.length,fusedNodes:0,sequentialNodes:0,fusionGroups:0,fusionEnabled:s};if(!s||!ad(e.nodes)){let l=await ui(e,t);return a.sequentialNodes=e.nodes.length,{result:l,stats:a}}let o=id(e.nodes);for(let l of o)l.kind==="fused"&&l.group.nodes.length>=i?(await cd(l.group,l.recipe,t,n),a.fusedNodes+=l.group.nodes.length,a.fusionGroups++):l.kind==="fused"?(await ht(l.group.nodes,t),a.sequentialNodes+=l.group.nodes.length):(await ht(l.nodes,t),a.sequentialNodes+=l.nodes.length);let u=e.nodes[e.nodes.length-1];if(!u.result)throw Error("Execution failed: no result for last node");return{result:u.result,stats:a}}async function cd(e,t,r,s){if(r.name==="webgpu"&&"dispatchFusedKernel"in r){await hd(e,t,r,s);return}await ht(e.nodes,r)}async function hd(e,t,r,s){let{dispatchFusedKernel:n}=await Ft(()=>import("./BczbaFgV.js"),[],import.meta.url),i=r.device;if(!i){await ht(e.nodes,r);return}let a=[];for(let o of e.externalInputs){let u=o.kind==="materialized"?o.storage:o.node.result;if(!u){await ht(e.nodes,r);return}let l=u.backendTensor;a.push({buffer:l.buffer,shape:l.shape??[1],dtype:l.dtype??"f32"})}try{let o=n(i,t,a,{vectorize:s}),u=e.outputNode;u.result=ar(u.device,{buffer:o.buffer,shape:o.shape,dtype:o.dtype,size:o.shape.reduce((l,d)=>l*d,1)*4,strides:fd(o.shape),offset:0,isContiguous:!0});for(let l of e.nodes)l!==u&&!l.result&&(l.result=u.result)}catch(o){console.warn("Fusion dispatch failed, falling back to sequential:",o),await ht(e.nodes,r)}}async function ht(e,t){for(let r of e){if(r.result)continue;let s=r.inputs.map(oi),n=await pd(r,s.map(a=>a.backendTensor),We(r.device)??t),i=n.ownsBuffer===!1&&s.length>0?s[0].id:void 0;r.result=ar(r.device,n,i)}}async function pd(e,t,r){switch(e.op){case"tensorFromArray":{let s=e.payload;if(!s?.values)throw Error("tensorFromArray requires values in payload");return r.ops.tensorFromArray(s.values,e.shape)}case"add":return r.ops.add(t[0],t[1]);case"sub":{let s=e.payload;return r.ops.sub(t[0],t[1],s)}case"mul":return r.ops.mul(t[0],t[1]);case"div":{let s=e.payload;return r.ops.div(t[0],t[1],s)}case"matmul":return r.ops.matmul(t[0],t[1]);case"sqrt":return r.ops.sqrt(t[0]);case"relu":return r.ops.relu(t[0]);case"exp":if(!r.ops.exp)throw Error("exp not supported by backend");return r.ops.exp(t[0]);case"log":if(!r.ops.log)throw Error("log not supported by backend");return r.ops.log(t[0]);case"neg":if(!r.ops.neg)throw Error("neg not supported by backend");return r.ops.neg(t[0]);case"abs":if(!r.ops.abs)throw Error("abs not supported by backend");return r.ops.abs(t[0]);case"tanh":if(!r.ops.tanh)throw Error("tanh not supported by backend");return r.ops.tanh(t[0]);case"sigmoid":if(!r.ops.sigmoid)throw Error("sigmoid not supported by backend");return r.ops.sigmoid(t[0]);case"gelu":{if(!r.ops.gelu)throw Error("gelu not supported by backend");let s=e.payload;return r.ops.gelu(t[0],s)}case"silu":if(!r.ops.silu)throw Error("silu not supported by backend");return r.ops.silu(t[0]);case"isfinite":if(!r.ops.isfinite)throw Error("isfinite not supported by backend");return r.ops.isfinite(t[0]);case"reshape":{let s=e.payload?.targetShape??e.shape;return r.ops.reshape(t[0],s)}case"expand":return r.ops.expand(t[0],e.shape);case"transpose":{let s=e.payload;if(!s)throw Error("transpose requires dim0 and dim1 in payload");return r.ops.transpose(t[0],s)}case"permute":{let s=e.payload;if(!s)throw Error("permute requires dims in payload");return r.ops.permute(t[0],s.dims)}case"contiguous":return r.ops.contiguous(t[0]);case"cast":{let s=e.payload;if(!s)throw Error("cast requires dtype in payload");if(!r.ops.cast)throw Error("cast not supported by backend");return r.ops.cast(t[0],s.dtype)}case"gather":{let s=e.payload;if(!s)throw Error("gather requires dim in payload");return r.ops.gather(t[0],t[1],s)}case"scatterAdd":{let s=e.payload;if(!s)throw Error("scatterAdd requires dim in payload");return r.ops.scatterAdd(t[0],t[1],t[2],s)}case"sum":{let s=e.payload;return r.ops.sum(t[0],s)}case"max":{let s=e.payload;return r.ops.max(t[0],s)}case"mean":{let s=e.payload;return r.ops.mean(t[0],s)}case"argmax":{let s=e.payload;if(!r.ops.argmax)throw Error("argmax not supported by backend");return r.ops.argmax(t[0],s)}case"argmin":{let s=e.payload;if(!r.ops.argmin)throw Error("argmin not supported by backend");return r.ops.argmin(t[0],s)}case"gt":if(!r.ops.gt)throw Error("gt not supported by backend");return r.ops.gt(t[0],t[1]);case"lt":if(!r.ops.lt)throw Error("lt not supported by backend");return r.ops.lt(t[0],t[1]);case"ge":if(!r.ops.ge)throw Error("ge not supported by backend");return r.ops.ge(t[0],t[1]);case"le":if(!r.ops.le)throw Error("le not supported by backend");return r.ops.le(t[0],t[1]);case"eq":if(!r.ops.eq)throw Error("eq not supported by backend");return r.ops.eq(t[0],t[1]);case"ne":if(!r.ops.ne)throw Error("ne not supported by backend");return r.ops.ne(t[0],t[1]);case"where":return r.ops.where(t[0],t[1],t[2]);case"stridedScatterCopy":{let s=e.payload;if(!s)throw Error("stridedScatterCopy requires options in payload");return r.ops.stridedScatterCopy(t[0],t[1],s)}case"stridedScatterAdd":{let s=e.payload;if(!s)throw Error("stridedScatterAdd requires options in payload");return r.ops.stridedScatterAdd(t[0],t[1],s)}case"transfer":throw Error("Transfer ops should be handled in executePlan");default:throw Error(`Unknown op: ${e.op}`)}}function fd(e){let t=Array(e.length),r=1;for(let s=e.length-1;s>=0;s--)t[s]=r,r*=e[s];return t}const js=new FinalizationRegistry(e=>{e.storageId>=0&&ct.markUnreachable(e.storageId)}),yt=new Map;function Ws(e,t){let r=yt.get(e);r||(r=new Set,yt.set(e,r)),r.add(t)}function $r(e,t){let r=yt.get(e);r&&(r.delete(t),r.size===0&&yt.delete(e))}function md(e,t){let r=yt.get(e);if(r)for(let s of r)!s.isMaterialized()&&!s.disposed&&s._materialize(t)}function gd(){let e=[];for(let t of yt.values())for(let r of t)e.push(r);return e}var re=class li{baseId;device;shape;_lazyRef;_pendingNodeId=null;_held;constructor(t,r,s,n){this.baseId=t,this._lazyRef=r,this.device=n,this.shape=s.slice(),this._held={storageId:r.kind==="materialized"?r.storage.id:-1},js.register(this,this._held,this),r.kind==="pending"?(this._pendingNodeId=r.node.id,Ws(r.node.id,this)):r.kind==="materialized"&&ct.markReachable(r.storage.id)}get lazyRef(){return this._lazyRef}get backendTensor(){if(!Ir(this._lazyRef))throw Error("Tensor not materialized. Call cpu() or item() first to force execution.");return this._lazyRef.storage.backendTensor}isMaterialized(){return Ir(this._lazyRef)}_materialize(t){this._pendingNodeId!==null&&($r(this._pendingNodeId,this),this._pendingNodeId=null),this._lazyRef={kind:"materialized",storage:t},this._held.storageId=t.id,ct.markReachable(t.id)}_updateLazyRef(t){this._pendingNodeId!==null&&($r(this._pendingNodeId,this),this._pendingNodeId=null),this._lazyRef=t,t.kind==="pending"&&(this._pendingNodeId=t.node.id,Ws(t.node.id,this))}toArray(){return this.backendTensor.toArray()}view(t){let r=this.backendTensor;if(!r.view)throw Error("view is not supported for this backend tensor");let s=r.view(t);return new li(this.baseId,{kind:"materialized",storage:{id:-1,device:this.device,backendTensor:s}},s.shape,this.device)}_disposed=!1;dispose(){if(!this._disposed&&(this._disposed=!0,js.unregister(this),this._held.storageId=-1,this._pendingNodeId!==null&&($r(this._pendingNodeId,this),this._pendingNodeId=null),Ir(this._lazyRef))){let t=this._lazyRef.storage;ct.markUnreachable(t.id)}}get disposed(){return this._disposed}};let wd=1;function ae(){return wd++}var yd=class extends Error{constructor(e,t,r){super(`GPU memory limit exceeded: requested ${zr(e)}, current usage ${zr(t)}, limit ${zr(r)}`),this.requestedBytes=e,this.currentBytes=t,this.limitBytes=r,this.name="GPUMemoryLimitExceededError"}};function zr(e){return e>=1024*1024*1024?`${(e/(1024*1024*1024)).toFixed(2)}GB`:e>=1024*1024?`${(e/(1024*1024)).toFixed(2)}MB`:e>=1024?`${(e/1024).toFixed(2)}KB`:`${e}B`}const Ie=new class{memoryLimitBytes=10737418240;currentAllocatedBytes=0;bufferSizes=new Map;allocationCount=0;peakUsageBytes=0;getMemoryLimit(){return this.memoryLimitBytes}setMemoryLimit(e){if(e<=0)throw Error("Memory limit must be positive");this.memoryLimitBytes=e}getCurrentAllocatedBytes(){return this.currentAllocatedBytes}getPeakUsageBytes(){return this.peakUsageBytes}getUsagePercent(){return this.currentAllocatedBytes/this.memoryLimitBytes*100}getAllocationCount(){return this.allocationCount}trackAllocation(e,t){if(this.currentAllocatedBytes+t>this.memoryLimitBytes)throw new yd(t,this.currentAllocatedBytes,this.memoryLimitBytes);this.bufferSizes.set(e,t),this.currentAllocatedBytes+=t,this.allocationCount++,this.currentAllocatedBytes>this.peakUsageBytes&&(this.peakUsageBytes=this.currentAllocatedBytes)}trackDeallocation(e){let t=this.bufferSizes.get(e);t!==void 0&&(this.currentAllocatedBytes-=t,this.bufferSizes.delete(e),this.allocationCount--)}wouldExceedLimit(e){return this.currentAllocatedBytes+e>this.memoryLimitBytes}stats(){return{currentBytes:this.currentAllocatedBytes,peakBytes:this.peakUsageBytes,limitBytes:this.memoryLimitBytes,usagePercent:this.getUsagePercent(),allocationCount:this.allocationCount,availableBytes:this.memoryLimitBytes-this.currentAllocatedBytes}}reset(){this.currentAllocatedBytes=0,this.bufferSizes.clear(),this.allocationCount=0,this.peakUsageBytes=0}};function Hs(e){Ie.setMemoryLimit(e)}function bd(){return Ie.getMemoryLimit()}function vd(){return Ie.stats()}var _d={};function it(e){let t=Math.max(e,256);return Math.ceil(Math.log2(t))}function at(e){return 2**e}function di(e,t){return e.reduce((r,s)=>r*s,1)*(t==="f32"||t==="i32"?4:t==="f16"?2:1)}function ci(e,t,r,s){let n=new Map,i=new Map;e.forEach((o,u)=>{i.set(o,u)});for(let o of e)n.set(o,{nodeId:o,firstUse:i.get(o),lastUse:i.get(o),isOutput:r.has(o),isInput:!t.has(o)||t.get(o).length===0,bufferSize:s.get(o)??0});for(let[o,u]of t){let l=i.get(o);for(let d of u){let c=n.get(d);c&&l>c.lastUse&&(c.lastUse=l)}}let a=e.length-1;for(let o of r){let u=n.get(o);u&&(u.lastUse=a)}return n}function kd(e,t){let r=[];for(let[s,n]of e)n.lastUse<t&&!n.isOutput&&r.push(s);return r}function hi(e,t,r){let s=new Map,n=new Set;for(let i=0;i<e.length;i++){let a=e[i],o=r.get(a)??0;if(o===0)continue;let u=kd(t,i).filter(l=>!n.has(l)).map(l=>({id:l,lifetime:t.get(l)})).filter(l=>l.lifetime.bufferSize>=o).sort((l,d)=>l.lifetime.bufferSize-d.lifetime.bufferSize);if(u.length>0){let l=u[0];s.set(a,l.id),n.add(l.id)}}return s}var Sd=class extends Error{constructor(e,t,r){super(`Memory limit exceeded: requested ${Cr(e)}, current usage ${Cr(t)}, limit ${Cr(r)}`),this.requestedBytes=e,this.currentBytes=t,this.limitBytes=r,this.name="MemoryLimitExceededError"}};function Cr(e){return e>=1024*1024*1024?`${(e/(1024*1024*1024)).toFixed(2)}GB`:e>=1024*1024?`${(e/(1024*1024)).toFixed(2)}MB`:e>=1024?`${(e/1024).toFixed(2)}KB`:`${e}B`}var xd=class{pools=new Map;bufferInfo=new Map;nextBufferId=1;nextFenceId=1;memoryLimitBytes;currentAllocatedBytes=0;constructor(e){this.memoryLimitBytes=e?.memoryLimitBytes??10737418240}getMemoryLimit(){return this.memoryLimitBytes}setMemoryLimit(e){if(e<=0)throw Error("Memory limit must be positive");this.memoryLimitBytes=e}getCurrentAllocatedBytes(){return this.currentAllocatedBytes}allocate(e,t,r){let s=it(e),n=this.pools.get(s)??[];for(let o=0;o<n.length;o++){let u=n[o],l=this.bufferInfo.get(u);if(l&&l.inUseByPlan===null&&l.fenceId===null)return n.splice(o,1),l.lastUsedAt=Date.now(),l.dtype=t,l.shape=r.slice(),l}let i=at(s);if(this.currentAllocatedBytes+i>this.memoryLimitBytes)throw new Sd(i,this.currentAllocatedBytes,this.memoryLimitBytes);let a={id:this.nextBufferId++,sizeBytes:i,sizeClass:s,dtype:t,shape:r.slice(),createdAt:Date.now(),lastUsedAt:Date.now(),inUseByPlan:null,fenceId:null};return this.bufferInfo.set(a.id,a),this.currentAllocatedBytes+=i,a}markInUse(e,t){let r=this.bufferInfo.get(e);r&&(r.inUseByPlan=t,r.lastUsedAt=Date.now())}markPendingFence(e,t){let r=this.bufferInfo.get(e);if(r){let s=t??this.nextFenceId++;return r.fenceId=s,r.inUseByPlan=null,s}return-1}signalFence(e){for(let[t,r]of this.bufferInfo)if(r.fenceId===e){r.fenceId=null;let s=this.pools.get(r.sizeClass)??[];s.push(t),this.pools.set(r.sizeClass,s)}}release(e){let t=this.bufferInfo.get(e);if(t&&(t.inUseByPlan=null,t.fenceId===null)){let r=this.pools.get(t.sizeClass)??[];r.push(e),this.pools.set(t.sizeClass,r)}}getInfo(e){return this.bufferInfo.get(e)}stats(){let e=0,t=0;for(let i of this.pools.values()){e+=i.length;for(let a of i)t+=this.bufferInfo.get(a)?.sizeBytes??0}let r=0,s=0,n=0;for(let i of this.bufferInfo.values())n+=i.sizeBytes,i.inUseByPlan!==null&&r++,i.fenceId!==null&&s++;return{totalBuffers:this.bufferInfo.size,pooledBuffers:e,inUseBuffers:r,pendingFenceBuffers:s,totalBytes:n,pooledBytes:t,memoryLimitBytes:this.memoryLimitBytes,memoryUsagePercent:this.currentAllocatedBytes/this.memoryLimitBytes*100}}clear(){this.pools.clear(),this.bufferInfo.clear(),this.nextBufferId=1,this.nextFenceId=1,this.currentAllocatedBytes=0}},Ad=class{plans=new Map;nextPlanId=1;bufferPool;constructor(e){this.bufferPool=e}registerPlan(e,t,r){let s=this.nextPlanId++,n={id:s,inputBuffers:e.slice(),outputBuffers:t.slice(),intermediateBuffers:r.slice(),startedAt:Date.now(),completedAt:null,fenceId:null};this.plans.set(s,n);for(let i of[...e,...t,...r])this.bufferPool.markInUse(i,s);return s}completePlan(e,t){let r=this.plans.get(e);if(!r)return;r.completedAt=Date.now(),r.fenceId=t??null;for(let n of r.intermediateBuffers)t===void 0?this.bufferPool.release(n):this.bufferPool.markPendingFence(n,t);let s=new Set(r.outputBuffers);for(let n of r.inputBuffers)s.has(n)||(t===void 0?this.bufferPool.release(n):this.bufferPool.markPendingFence(n,t))}signalFence(e){this.bufferPool.signalFence(e)}getPlan(e){return this.plans.get(e)}getActivePlans(){return Array.from(this.plans.values()).filter(e=>e.completedAt===null)}isBufferInUse(e){for(let t of this.plans.values())if(t.completedAt===null&&(t.inputBuffers.includes(e)||t.outputBuffers.includes(e)||t.intermediateBuffers.includes(e)))return!0;return!1}cleanup(e=6e4){let t=Date.now(),r=0;for(let[s,n]of this.plans)n.completedAt!==null&&t-n.completedAt>=e&&(this.plans.delete(s),r++);return r}stats(){let e=0,t=0;for(let r of this.plans.values())r.completedAt===null?e++:t++;return{totalPlans:this.plans.size,activePlans:e,completedPlans:t}}},Ed=class{bufferPool;planManager;constructor(e){this.bufferPool=new xd({memoryLimitBytes:e?.memoryLimitBytes}),this.planManager=new Ad(this.bufferPool)}getMemoryLimit(){return this.bufferPool.getMemoryLimit()}setMemoryLimit(e){this.bufferPool.setMemoryLimit(e)}getCurrentAllocatedBytes(){return this.bufferPool.getCurrentAllocatedBytes()}planExecution(e,t,r,s,n){let i=new Map;for(let h of e){let f=s.get(h)??[1],w=n.get(h)??"f32";i.set(h,di(f,w))}let a=hi(e,ci(e,t,new Set(r),i),i),o=new Map,u=0,l=0,d=0,c=0;for(let h of e){let f=s.get(h)??[1],w=n.get(h)??"f32",m=i.get(h)??0,p=a.get(h);if(p!==void 0){let b=o.get(p);if(b!==void 0){o.set(h,b),l+=m,c++;continue}}let g=this.bufferPool.allocate(m,w,f);o.set(h,g.id),u+=g.sizeBytes,d++}return{allocations:o,donations:a,totalAllocatedBytes:u,reusedBytes:l,newAllocations:d,reusedAllocations:c}}registerExecution(e,t){let r=Array.from(new Set(e.allocations.values())),s=t.map(i=>e.allocations.get(i)).filter(i=>i!==void 0),n=r.filter(i=>!s.includes(i));return this.planManager.registerPlan([],s,n)}completeExecution(e,t){this.planManager.completePlan(e,t)}signalFence(e){this.planManager.signalFence(e)}getBufferPool(){return this.bufferPool}getPlanManager(){return this.planManager}stats(){return{bufferPool:this.bufferPool.stats(),planManager:this.planManager.stats()}}clear(){this.bufferPool.clear()}};let Zr=null;function Id(e,t){Zr=e}function $d(e,t){return t!=="webgpu"||Zr===null?null:Zr(e)}let Jt=null,pi=10*1024*1024*1024;function zd(e){if(e<=0)throw Error("Memory limit must be positive");pi=e,Jt&&Jt.setMemoryLimit(e)}function ks(){return Jt||=new Ed({memoryLimitBytes:pi}),Jt}function fi(e){let t=[],r=new Map,s=new Map,n=new Map;for(let i of e.nodes){t.push(i.id),s.set(i.id,i.shape),n.set(i.id,i.dtype);let a=[];for(let o of i.inputs)o.kind==="pending"&&a.push(o.node.id);r.set(i.id,a)}return{nodeOrder:t,nodeInputs:r,nodeShapes:s,nodeDtypes:n,outputNodeId:e.nodes[e.nodes.length-1].id}}function Cd(e){let t=ks(),{nodeOrder:r,nodeInputs:s,nodeShapes:n,nodeDtypes:i,outputNodeId:a}=fi(e),o=t.planExecution(r,s,[a],n,i),u=new Map;for(let d of r){let c=n.get(d)??[1],h=i.get(d)??"f32";u.set(d,di(c,h))}let l=ci(r,s,new Set([a]),u);return{memoryPlan:o,lifetimes:l,donations:hi(r,l,u)}}function Td(e){if(e.kind==="materialized")return e.storage;if(e.node.result)return e.node.result;throw Error("Input not ready")}async function Bd(e,t,r){let s=r?.enableDonation??!0;if(e.nodes.length===0)throw Error("Cannot execute empty plan");let n=ks(),{memoryPlan:i,donations:a}=Cd(e),{outputNodeId:o}=fi(e),u=n.registerExecution(i,[o]),l=new Map,d=new Set;for(let f of e.nodes){let w=f.inputs.map(Td),m=w.map(y=>y.backendTensor),p=We(f.device)??t,g,b=null;if(s){let y=a.get(f.id);if(y!==void 0&&!d.has(y)){let x=l.get(y);x&&(b=$d(x.backendTensor,f.device),b&&d.add(y))}}let v=b?{outBuffer:b}:void 0;switch(f.op){case"tensorFromArray":{let y=f.payload;if(!y?.values)throw Error("tensorFromArray requires values in payload");g=p.ops.tensorFromArray(y.values,f.shape);break}case"add":g=p.ops.add(m[0],m[1],v);break;case"sub":{let y=f.payload;g=p.ops.sub(m[0],m[1],{...y,...v});break}case"mul":g=p.ops.mul(m[0],m[1],v);break;case"div":{let y=f.payload;g=p.ops.div(m[0],m[1],{...y,...v});break}case"matmul":g=p.ops.matmul(m[0],m[1],v);break;case"sqrt":g=p.ops.sqrt(m[0],v);break;case"relu":g=p.ops.relu(m[0],v);break;case"exp":if(!p.ops.exp)throw Error("exp not supported by backend");g=p.ops.exp(m[0],v);break;case"log":if(!p.ops.log)throw Error("log not supported by backend");g=p.ops.log(m[0],v);break;case"neg":if(!p.ops.neg)throw Error("neg not supported by backend");g=p.ops.neg(m[0],v);break;case"abs":if(!p.ops.abs)throw Error("abs not supported by backend");g=p.ops.abs(m[0],v);break;case"tanh":if(!p.ops.tanh)throw Error("tanh not supported by backend");g=p.ops.tanh(m[0],v);break;case"sigmoid":if(!p.ops.sigmoid)throw Error("sigmoid not supported by backend");g=p.ops.sigmoid(m[0],v);break;case"gelu":if(!p.ops.gelu)throw Error("gelu not supported by backend");g=p.ops.gelu(m[0],v);break;case"silu":if(!p.ops.silu)throw Error("silu not supported by backend");g=p.ops.silu(m[0],v);break;case"reshape":{let y=f.payload?.targetShape??f.shape;g=p.ops.reshape(m[0],y);break}case"expand":g=p.ops.expand(m[0],f.shape);break;case"transpose":{let y=f.payload;if(!y)throw Error("transpose requires dim0 and dim1 in payload");g=p.ops.transpose(m[0],y);break}case"permute":{let y=f.payload;if(!y)throw Error("permute requires dims in payload");g=p.ops.permute(m[0],y.dims);break}case"contiguous":g=p.ops.contiguous(m[0]);break;case"cast":{let y=f.payload;if(!y)throw Error("cast requires dtype in payload");if(!p.ops.cast)throw Error("cast not supported by backend");g=p.ops.cast(m[0],y.dtype);break}case"gather":{let y=f.payload;if(!y)throw Error("gather requires dim in payload");g=p.ops.gather(m[0],m[1],y);break}case"scatterAdd":{let y=f.payload;if(!y)throw Error("scatterAdd requires dim in payload");g=p.ops.scatterAdd(m[0],m[1],m[2],y);break}case"sum":{let y=f.payload;g=p.ops.sum(m[0],y);break}case"max":{let y=f.payload;g=p.ops.max(m[0],y);break}case"mean":{let y=f.payload;g=p.ops.mean(m[0],y);break}case"argmax":{let y=f.payload;if(!p.ops.argmax)throw Error("argmax not supported by backend");g=p.ops.argmax(m[0],y);break}case"argmin":{let y=f.payload;if(!p.ops.argmin)throw Error("argmin not supported by backend");g=p.ops.argmin(m[0],y);break}case"gt":if(!p.ops.gt)throw Error("gt not supported by backend");g=p.ops.gt(m[0],m[1],v);break;case"lt":if(!p.ops.lt)throw Error("lt not supported by backend");g=p.ops.lt(m[0],m[1],v);break;case"ge":if(!p.ops.ge)throw Error("ge not supported by backend");g=p.ops.ge(m[0],m[1],v);break;case"le":if(!p.ops.le)throw Error("le not supported by backend");g=p.ops.le(m[0],m[1],v);break;case"eq":if(!p.ops.eq)throw Error("eq not supported by backend");g=p.ops.eq(m[0],m[1],v);break;case"ne":if(!p.ops.ne)throw Error("ne not supported by backend");g=p.ops.ne(m[0],m[1],v);break;case"where":g=p.ops.where(m[0],m[1],m[2],v);break;case"stridedScatterCopy":{let y=f.payload;if(!y)throw Error("stridedScatterCopy requires options in payload");g=p.ops.stridedScatterCopy(m[0],m[1],y);break}case"stridedScatterAdd":{let y=f.payload;if(!y)throw Error("stridedScatterAdd requires options in payload");g=p.ops.stridedScatterAdd(m[0],m[1],y);break}case"transfer":{let y=w[0],x=f.device,z=y.device;if(z===x)g=y.backendTensor;else{let M=We(x);if(!M)throw Error(`Transfer failed: backend not available for ${x}`);let D=We(z);if(!D)throw Error(`Transfer failed: backend not available for ${z}`);let B=await D.ops.read(y.backendTensor);g=M.ops.tensorFromArray(B,f.shape)}break}default:throw Error(`Unknown op: ${f.op}`)}let k=ar(f.device,g);f.result=k,l.set(f.id,k)}n.completeExecution(u);let c=e.nodes[e.nodes.length-1];if(!c.result)throw Error("Execution failed: no result for last node");l.clear();let h={totalNodes:e.nodes.length,totalAllocatedBytes:i.totalAllocatedBytes,reusedBytes:i.reusedBytes,newAllocations:i.newAllocations,reusedAllocations:i.reusedAllocations,donationCount:d.size};return{result:c.result,stats:h,planId:u}}function Md(){return ks().stats()}const Dd={tileM:32,tileN:32,tileK:16,threadTileM:4,threadTileN:4,useSubgroups:!1,vectorWidth:1};function Rd(e,t){return!e&&!t?"NN":!e&&t?"NT":e&&!t?"TN":"TT"}function Pd(e,t,r,s){if(e===1||t===1)return"gemv";if(s>1&&e*t<512*512)return"batched_small";if(e/Math.max(r,t)>4)return"tall_skinny";if(t/Math.max(r,e)>4)return"short_wide";let n=Math.max(e,t,r);return n<512?"square_small":n<2048?"square_medium":"square_large"}function Fd(e){let{tileM:t,tileN:r,tileK:s,threadTileM:n,threadTileN:i}=e,a=t/n*(r/i);if(a>256)throw Error(`Invalid config: workgroup size ${a} exceeds 256`);if(t%n!==0)throw Error(`tileM (${t}) must be divisible by threadTileM (${n})`);if(r%i!==0)throw Error(`tileN (${r}) must be divisible by threadTileN (${i})`);let o=(t*s+s*r)*4;if(o>16384)throw Error(`Config requires ${o} bytes of shared memory, exceeds 16KB limit`)}function mi(e){return{x:e.tileN/e.threadTileN,y:e.tileM/e.threadTileM}}function Ld(e){return e==="f16"?"f16":"f32"}function Nd(){return"f32"}function qd(e,t,r,s,n="0u"){return e==="TN"||e==="TT"?`a[${n} + ${r} * ${s} + ${t}]`:`a[${n} + ${t} * ${s} + ${r}]`}function Gd(e,t,r,s,n="0u"){return e==="NT"||e==="TT"?`b[${n} + ${r} * ${s} + ${t}]`:`b[${n} + ${t} * ${s} + ${r}]`}function Ud(e,t,r){if(!e||e.ops.length===0)return`out[${r}] = ${t};`;let s=[],n=t;for(let i of e.ops)switch(i.kind){case"none":break;case"bias":s.push(`let biasVal${i.inputIndex} = epilogue_in${i.inputIndex}[${r} % arrayLength(&epilogue_in${i.inputIndex})];`),n=`(${n} + biasVal${i.inputIndex})`;break;case"add":s.push(`let addVal${i.inputIndex} = epilogue_in${i.inputIndex}[${r}];`),n=`(${n} + addVal${i.inputIndex})`;break;case"mul":s.push(`let mulVal${i.inputIndex} = epilogue_in${i.inputIndex}[${r}];`),n=`(${n} * mulVal${i.inputIndex})`;break;case"relu":n=`select(0.0, ${n}, ${n} > 0.0)`;break;case"gelu":{let a=n;s.push(`let gelu_x = ${a};`),s.push("let gelu_inner = 0.7978845608 * (gelu_x + 0.044715 * gelu_x * gelu_x * gelu_x);"),n="(0.5 * gelu_x * (1.0 + tanh(gelu_inner)))";break}case"silu":s.push(`let silu_x = ${n};`),n="(silu_x / (1.0 + exp(-silu_x)))";break;case"cast":i.toDtype==="f16"&&(n=`f16(${n})`);break}return e.outputDtype,e.outputDtype==="f16"&&!e.ops.some(i=>i.kind==="cast")&&(n=`f16(${n})`),s.push(`out[${r}] = ${n};`),s.join(`
      `)}function Od(e,t){if(!e||e.additionalInputCount===0)return"";let r=[];for(let s=0;s<e.additionalInputCount;s++)r.push(`@group(0) @binding(${t+s}) var<storage, read> epilogue_in${s}: array<f32>;`);return r.join(`
`)}function Vd(e){let{config:t,transposeMode:r,dtype:s,epilogue:n,batched:i}=e,{tileM:a,tileN:o,tileK:u,threadTileM:l,threadTileN:d}=t,c=mi(t),h=c.x,f=c.y,w=h*f,m=Ld(s),p=Nd(),g=Math.ceil(a*u/w),b=Math.ceil(u*o/w),v=Od(n,4),k=n?.outputDtype??s;return`
// Tiled Matrix Multiplication Kernel
// Config: TILE_M=${a}, TILE_N=${o}, TILE_K=${u}
// Thread tile: ${l}x${d}, Workgroup: ${h}x${f}
// Transpose mode: ${r}
// Dtype: ${s}, Output: ${k}
${s==="f16"||k==="f16"?`
enable f16;
`:""}
struct Params {
  m: u32,
  n: u32,
  k: u32,
  lda: u32,
  ldb: u32,
  ldc: u32,
  alpha: f32,
  batchSize: u32,
  batchStrideA: u32,
  batchStrideB: u32,
  batchStrideC: u32,
}

@group(0) @binding(0) var<storage, read> a: array<${m}>;
@group(0) @binding(1) var<storage, read> b: array<${m}>;
@group(0) @binding(2) var<storage, read_write> out: array<${n?.outputDtype==="f16"?"f16":m}>;
@group(0) @binding(3) var<uniform> params: Params;
${v}

// Shared memory tiles
var<workgroup> tileA: array<${p}, ${a*u}>;
var<workgroup> tileB: array<${p}, ${u*o}>;

const TILE_M: u32 = ${a}u;
const TILE_N: u32 = ${o}u;
const TILE_K: u32 = ${u}u;
const THREAD_TILE_M: u32 = ${l}u;
const THREAD_TILE_N: u32 = ${d}u;
const WG_SIZE_X: u32 = ${h}u;
const WG_SIZE_Y: u32 = ${f}u;
const ELEMS_PER_THREAD_A: u32 = ${g}u;
const ELEMS_PER_THREAD_B: u32 = ${b}u;

@compute @workgroup_size(${h}, ${f})
fn main(
  @builtin(workgroup_id) wg_id: vec3<u32>,
  @builtin(local_invocation_id) local_id: vec3<u32>,
  @builtin(local_invocation_index) local_idx: u32,
) {
  let m = params.m;
  let n = params.n;
  let k = params.k;
  let lda = params.lda;
  let ldb = params.ldb;
  let ldc = params.ldc;
  let alpha = params.alpha;

  // Batch offset (for batched matmul)
  // Using stride-based indexing for proper broadcast support
  // Stride of 0 means broadcast (same data for all batches)
  ${i?"let batch_idx = wg_id.z;":"let batch_idx = 0u;"}
  let batch_offset_a = batch_idx * params.batchStrideA;
  let batch_offset_b = batch_idx * params.batchStrideB;
  let batch_offset_c = batch_idx * params.batchStrideC;

  // Workgroup tile position in output matrix
  let wg_row = wg_id.y * TILE_M;
  let wg_col = wg_id.x * TILE_N;

  // Thread position within workgroup
  let thread_row = local_id.y;
  let thread_col = local_id.x;

  // Register accumulator array (THREAD_TILE_M x THREAD_TILE_N)
  var acc: array<${p}, ${l*d}>;
  for (var i = 0u; i < ${l*d}u; i = i + 1u) {
    acc[i] = 0.0;
  }

  // Number of K tiles
  let num_k_tiles = (k + TILE_K - 1u) / TILE_K;

  // Loop over K tiles
  for (var k_tile = 0u; k_tile < num_k_tiles; k_tile = k_tile + 1u) {
    let k_offset = k_tile * TILE_K;

    // Cooperative load of A tile into shared memory
    for (var i = 0u; i < ELEMS_PER_THREAD_A; i = i + 1u) {
      let flat_idx = local_idx * ELEMS_PER_THREAD_A + i;
      if (flat_idx < TILE_M * TILE_K) {
        let tile_row = flat_idx / TILE_K;
        let tile_col = flat_idx % TILE_K;
        let global_row = wg_row + tile_row;
        let global_col = k_offset + tile_col;
        if (global_row < m && global_col < k) {
          tileA[flat_idx] = ${p}(${qd(r,"global_row","global_col","lda","batch_offset_a")});
        } else {
          tileA[flat_idx] = 0.0;
        }
      }
    }

    // Cooperative load of B tile into shared memory
    for (var i = 0u; i < ELEMS_PER_THREAD_B; i = i + 1u) {
      let flat_idx = local_idx * ELEMS_PER_THREAD_B + i;
      if (flat_idx < TILE_K * TILE_N) {
        let tile_row = flat_idx / TILE_N;
        let tile_col = flat_idx % TILE_N;
        let global_row = k_offset + tile_row;
        let global_col = wg_col + tile_col;
        if (global_row < k && global_col < n) {
          tileB[flat_idx] = ${p}(${Gd(r,"global_row","global_col","ldb","batch_offset_b")});
        } else {
          tileB[flat_idx] = 0.0;
        }
      }
    }

    workgroupBarrier();

    // Compute partial products from shared memory
    // Each thread computes a THREAD_TILE_M x THREAD_TILE_N block
    for (var kk = 0u; kk < TILE_K; kk = kk + 1u) {
      // Load thread's column of A values from shared memory
      var a_vals: array<${p}, ${l}>;
      for (var tm = 0u; tm < THREAD_TILE_M; tm = tm + 1u) {
        let a_row = thread_row * THREAD_TILE_M + tm;
        a_vals[tm] = tileA[a_row * TILE_K + kk];
      }

      // Load thread's row of B values from shared memory
      var b_vals: array<${p}, ${d}>;
      for (var tn = 0u; tn < THREAD_TILE_N; tn = tn + 1u) {
        let b_col = thread_col * THREAD_TILE_N + tn;
        b_vals[tn] = tileB[kk * TILE_N + b_col];
      }

      // Outer product accumulation
      for (var tm = 0u; tm < THREAD_TILE_M; tm = tm + 1u) {
        for (var tn = 0u; tn < THREAD_TILE_N; tn = tn + 1u) {
          acc[tm * THREAD_TILE_N + tn] = acc[tm * THREAD_TILE_N + tn] + a_vals[tm] * b_vals[tn];
        }
      }
    }

    workgroupBarrier();
  }

  // Write results to global memory with bounds checking
  for (var tm = 0u; tm < THREAD_TILE_M; tm = tm + 1u) {
    for (var tn = 0u; tn < THREAD_TILE_N; tn = tn + 1u) {
      let out_row = wg_row + thread_row * THREAD_TILE_M + tm;
      let out_col = wg_col + thread_col * THREAD_TILE_N + tn;
      if (out_row < m && out_col < n) {
        let out_idx = batch_offset_c + out_row * ldc + out_col;
        let result = acc[tm * THREAD_TILE_N + tn] * alpha;
        ${Ud(n,"result","out_idx")}
      }
    }
  }
}
`}function jd(e){let{config:t,transposeMode:r,dtype:s,epilogue:n,batched:i}=e,a=n?`${n.ops.map(o=>o.kind).join(",")}_${n.outputDtype}`:"none";return["tiled",`${t.tileM}x${t.tileN}x${t.tileK}`,`t${t.threadTileM}x${t.threadTileN}`,`v${t.vectorWidth}`,t.useSubgroups?"sg":"nosg",r,s,i?"batch":"nobatch",a].join("_")}const Ks={MAP_READ:1,COPY_SRC:4,COPY_DST:8,UNIFORM:64,STORAGE:128},Ys=new Map,Wd=new Map;function Hd(e,t){return`${e}_${t}`}function Kd(e,t){let r=Hd(e,t);return Wd.get(r)||Dd}function Yd(e,t){let r=jd(t),s=Ys.get(r);if(s)return s;let n=Vd(t),i=e.createShaderModule({code:n}),a=e.createComputePipeline({layout:"auto",compute:{module:i,entryPoint:"main"}});return Ys.set(r,a),a}function Qd(e,t,r,s,n,i,a,o,u,l,d,c){Ie.trackAllocation(null,48);let h;try{h=e.createBuffer({size:48,usage:Ks.UNIFORM|Ks.COPY_DST}),Ie.trackDeallocation(null),Ie.trackAllocation(h,48)}catch(p){throw Ie.trackDeallocation(null),p}let f=new ArrayBuffer(48),w=new Uint32Array(f),m=new Float32Array(f);return w[0]=t,w[1]=r,w[2]=s,w[3]=n,w[4]=i,w[5]=a,m[6]=o,w[7]=u,w[8]=l,w[9]=d,w[10]=c,e.queue.writeBuffer(h,0,new Uint8Array(f)),h}function Zd(e){let{device:t,queue:r,a:s,b:n,out:i,m:a,n:o,k:u,batchSize:l=1,transA:d=!1,transB:c=!1,alpha:h=1,dtype:f="f32",epilogue:w,epilogueInputs:m=[]}=e,p=Pd(a,o,u,l),g=e.config??Kd(p,f);Fd(g);let b=Rd(d,c),v=d?a:u,k=c?u:o,y=o,x=e.batchStrideA??a*u,z=e.batchStrideB??u*o,M=e.batchStrideC??a*o,D=Yd(t,{config:g,transposeMode:b,dtype:f,epilogue:w,batched:l>1}),B=Qd(t,a,o,u,v,k,y,h,l,x,z,M),R=[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:i}},{binding:3,resource:{buffer:B}}];for(let j=0;j<m.length;j++)R.push({binding:4+j,resource:{buffer:m[j]}});let L=t.createBindGroup({layout:D.getBindGroupLayout(0),entries:R});mi(g);let q=Math.ceil(o/g.tileN),_=Math.ceil(a/g.tileM),T=l,$=t.createCommandEncoder(),P=$.beginComputePass();P.setPipeline(D),P.setBindGroup(0,L),P.dispatchWorkgroups(q,_,T),P.end(),r.submit([$.finish()])}function Xd(e,t,r,s){if(e.length<2||t.length<2)throw Error("matmul requires at least 2D tensors");let n=e.length,i=t.length,a,o,u,l;if(r?(o=e[n-2],a=e[n-1]):(a=e[n-2],o=e[n-1]),s?(l=t[i-2],u=t[i-1]):(u=t[i-2],l=t[i-1]),o!==u)throw Error(`matmul shape mismatch: k dimensions ${o} vs ${u}`);let d=e.slice(0,-2),c=t.slice(0,-2),h=Math.max(d.length,c.length),f=[];for(let w=0;w<h;w++){let m=d[d.length-1-w]??1,p=c[c.length-1-w]??1;if(m!==p&&m!==1&&p!==1)throw Error(`batch dimensions not broadcastable: ${m} vs ${p}`);f.unshift(Math.max(m,p))}return[...f,a,l]}function jt(e){return e.reduce((t,r)=>t*r,1)}function Jd(e,t,r,s,n,i){let a=e.slice(0,-2),o=t.slice(0,-2);return jt(r)<=1?{strideA:0,strideB:0,strideC:0}:{strideA:jt(a)===1?0:s*i,strideB:jt(o)===1?0:i*n,strideC:s*n}}const pt=new class{pool=new Map;pooledBytes=0;pooledBufferSet=new Set;reuseCount=0;allocCount=0;enabled=!0;pendingRelease=[];queue=null;fencePromise=null;setQueue(e){this.queue=e}acquire(e){if(!this.enabled)return null;let t=it(e),r=this.pool.get(t);if(r&&r.length>0){let s=r.pop(),n=at(t);return this.pooledBytes-=n,this.reuseCount++,this.pooledBufferSet.add(s),s}return null}release(e,t,r){if(!this.enabled||r!==140)return!1;let s=it(t),n=at(s);this.pooledBufferSet.delete(e);let i=this.pool.get(s)??[],a=this.pendingRelease.filter(o=>o.sizeClass===s).length;return i.length+a>=8?!1:(this.pendingRelease.push({buffer:e,sizeClass:s,size:n}),this.scheduleFence(),!0)}scheduleFence(){if(!(this.fencePromise||this.pendingRelease.length===0)){if(!this.queue||typeof this.queue.onSubmittedWorkDone!="function"){this.flushPending();return}this.fencePromise=this.queue.onSubmittedWorkDone().then(()=>{this.flushPending(),this.fencePromise=null,this.pendingRelease.length>0&&this.scheduleFence()})}}flushPending(){for(let{buffer:e,sizeClass:t,size:r}of this.pendingRelease){let s=this.pool.get(t);s||(s=[],this.pool.set(t,s)),s.push(e),this.pooledBytes+=r}this.pendingRelease=[]}trackAllocation(e,t){this.allocCount++}isFromPool(e){return this.pooledBufferSet.has(e)}markAsFromPool(e){this.pooledBufferSet.add(e)}stats(){let e=0;for(let r of this.pool.values())e+=r.length;let t=this.reuseCount+this.allocCount;return{pooledBuffers:e,pendingBuffers:this.pendingRelease.length,pooledBytes:this.pooledBytes,reuseCount:this.reuseCount,allocCount:this.allocCount,reuseRate:t>0?this.reuseCount/t:0}}clear(){for(let e of this.pool.values())for(let t of e)t.destroy();this.pool.clear(),this.pooledBytes=0,this.pooledBufferSet.clear();for(let{buffer:e}of this.pendingRelease)e.destroy();this.pendingRelease=[]}setEnabled(e){this.enabled=e,e||this.clear()}isEnabled(){return this.enabled}};function ec(e){let t=e;return!t.ownsBuffer||(t.buffer.usage??0)!==140?null:(t.ownsBuffer=!1,t.buffer)}const N={MAP_READ:1,COPY_SRC:4,COPY_DST:8,UNIFORM:64,STORAGE:128},tc={READ:1};let Tt=null,Ge=null;function gi(){return typeof navigator<"u"&&navigator.gpu!==void 0}async function rc(){if(gi())return null;try{return await Ft(()=>import("./_9UqjFoi.js"),[],import.meta.url)}catch{return null}}function sc(){if(typeof process>"u")return[];let e=(_d.TORCHLETTE_WEBGPU_OPTS??"").split(",").map(t=>t.trim()).filter(t=>t.length>0);return process.platform==="darwin"&&!e.some(t=>t.startsWith("backend="))&&e.unshift("backend=metal"),e}function nc(){return Ge}function ic(e){let t=e>>>15&1,r=e>>>10&31,s=e&1023,n;return n=r===0?s===0?t?-0:0:(t?-1:1)*2**-14*(s/1024):r===31?s===0?t?-1/0:1/0:NaN:(t?-1:1)*2**(r-15)*(1+s/1024),n}function ac(e){let t=Array(e.length);for(let r=0;r<e.length;r++)t[r]=ic(e[r]);return t}async function oc(){if(Tt)return!0;Ge=null;let e=null,t;if(gi()){let o=navigator.gpu;t=o;try{e=await o.requestAdapter()}catch(u){return Ge=`WebGPU requestAdapter failed: ${u instanceof Error?u.message:"Unknown error"}`,!1}}else{let o=await rc();if(!o)return Ge="webgpu module not available",!1;Object.assign(globalThis,o.globals);let u=sc(),l=o.create(u);if(!l)return Ge="webgpu create() returned no provider",!1;t=l;try{e=await l.requestAdapter()}catch(d){return Ge=`WebGPU requestAdapter failed: ${d instanceof Error?d.message:"Unknown error"}`,!1}if(!e)return Ge="No WebGPU adapter found"+(u.length>0?` (options: ${u.join(", ")})`:""),!1}if(!e)return Ge="No WebGPU adapter found",!1;let r=uc(e),s=e.features?.has("shader-f16")??!1,n,i=s,a={maxStorageBufferBindingSize:e.limits?.maxStorageBufferBindingSize??1024*1024*1024};try{let o=[];r.supported&&o.push("subgroups"),s&&o.push("shader-f16"),n=await e.requestDevice({requiredFeatures:o.length>0?o:void 0,requiredLimits:a})}catch{try{let o=[];r.supported&&o.push("subgroups"),n=await e.requestDevice({requiredFeatures:o.length>0?o:void 0,requiredLimits:a}),i=!1}catch{try{n=await e.requestDevice({requiredLimits:a}),i=!1}catch(o){return Ge=`WebGPU requestDevice failed: ${o instanceof Error?o.message:"Unknown error"}`,!1}}}return Tt={provider:t,device:n,queue:n.queue,pipelines:new Map,f16Supported:i},pt.setQueue(n.queue),Id(ec),ed(ih),!0}function uc(e){return e.features?.has("subgroups")?{supported:!0,subgroupSize:32}:{supported:!1}}function be(){if(!Tt)throw Error("WebGPU backend not initialized; call initWebGPU()");return Tt}function Pe(e){return e.reduce((t,r)=>t*r,1)}function wi(e,t){let r=Math.max(e.length,t.length),s=Array(r);for(let n=0;n<r;n+=1){let i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw Error("webgpu shapes are not broadcastable");s[r-1-n]=Math.max(i,a)}return s}function yi(e){return e.length===0?[1]:e}function Ss(e){let t=Array(e.length),r=1;for(let s=e.length-1;s>=0;--s)t[s]=r,r*=e[s];return t}function nt(e,t){let r=e.shape,s=e.strides;if(r.length>t.length)throw Error("webgpu broadcast target has fewer dimensions than input");let n=t.length-r.length,i=Array(t.length);for(let a=0;a<t.length;a+=1){let o=a-n;if(o<0){i[a]=0;continue}let u=r[o];if(u===t[a])i[a]=s[o];else if(u===1)i[a]=0;else throw Error("webgpu broadcast target shape is incompatible")}return i}function Qs(e){return e.map(t=>`${t}u`).join(", ")}function xs(e,t){let r=e.length,s=`const OUT_SHAPE: array<u32, ${r}> = array<u32, ${r}>(${Qs(e)});`,n=t.map((o,u)=>`const IN${u}_STRIDES: array<u32, ${r}> = array<u32, ${r}>(${Qs(o)});`),i=`
  var remaining = idx;
  var coords: array<u32, ${r}>;
  for (var axis = 0u; axis < ${r}u; axis = axis + 1u) {
    let rev = ${r}u - 1u - axis;
    let dim = OUT_SHAPE[rev];
    let coord = remaining % dim;
    coords[rev] = coord;
    remaining = remaining / dim;
  }
`,a=t.map((o,u)=>`  let offset${u} = ${e.map((l,d)=>`coords[${d}u] * IN${u}_STRIDES[${d}u]`).join(" + ")};`);return{declarations:[s,...n].join(`
`),compute:i,offsets:a}}function lc(){throw Error("Use cpu() to read back WebGPU tensors")}function me(e,t,r,s=0,n="f32",i=!0){let a=r??Ss(e),o=r===void 0||dc(e,a),u=!1,l=t.size??Pe(e)*Et(n),d=t.usage??0,c=at(it(l)),h=d===140&&l===c;return{shape:e.slice(),size:Pe(e),buffer:t,strides:a,offset:s,isContiguous:o,dtype:n,ownsBuffer:i,toArray:lc,destroy(){u||(u=!0,i&&(Ie.trackDeallocation(t),h&&pt.release(t,l,d)||t.destroy()))}}}function dc(e,t){let r=Ss(e);for(let s=0;s<e.length;s++)if(!(e[s]<=1)&&t[s]!==r[s])return!1;return!0}function Et(e){switch(e){case"f16":return 2;case"f32":return 4;case"i32":return 4;case"u32":return 4;case"bool":return 1;default:return 4}}function ot(e){return Math.ceil(e/4)*4}function Bt(e){switch(e){case"f16":return"f16";case"f32":return"f32";case"i32":return"i32";case"u32":return"u32";case"bool":return"bool";default:return"f32"}}function de(e,t){let r=ot(t.size),s=t.usage===140;if(s&&!t.mappedAtCreation){let i=pt.acquire(r);if(i){let a=at(it(r));return Ie.trackAllocation(i,a),i}}let n=s&&!t.mappedAtCreation?at(it(r)):r;Ie.trackAllocation(null,n);try{let i=e.createBuffer({...t,size:n});return Ie.trackDeallocation(null),Ie.trackAllocation(i,n),s&&!t.mappedAtCreation&&(pt.trackAllocation(i,n),pt.markAsFromPool(i)),i}catch(i){throw Ie.trackDeallocation(null),i}}function cc(e,t,r){if(t.byteLength===0)throw Error("webgpu tensors cannot be empty yet");let s=ot(t.byteLength),n=N.STORAGE|N.COPY_DST|N.COPY_SRC,i=at(it(s)),a=pt.acquire(i);if(a&&r)return Ie.trackAllocation(a,i),r.writeBuffer(a,0,t),a;let o=de(e,{size:s,usage:n,mappedAtCreation:!0});return t instanceof Int32Array?new Int32Array(o.getMappedRange()).set(t):t instanceof Uint32Array?new Uint32Array(o.getMappedRange()).set(t):t instanceof Uint16Array?new Uint16Array(o.getMappedRange()).set(t):new Float32Array(o.getMappedRange()).set(t),o.unmap(),o}function Ke(e,t){let r=de(e,{size:4,usage:N.UNIFORM|N.COPY_DST});return e.queue.writeBuffer(r,0,new Uint32Array([t])),r}function hc(e,t,r,s,n,i,a="f32"){let o=xs(t,[r,s]),u=Bt(a);return`${a==="f16"?`enable f16;
`:""}
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> a: array<${u}>;
@group(0) @binding(1) var<storage, read> b: array<${u}>;
@group(0) @binding(2) var<storage, read_write> out: array<${u}>;
@group(0) @binding(3) var<uniform> params: Params;

${o.declarations}
const A_OFFSET: u32 = ${n}u;
const B_OFFSET: u32 = ${i}u;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
${o.compute}
${o.offsets.join(`
`)}
  out[idx] = a[offset0 + A_OFFSET] ${e} b[offset1 + B_OFFSET];
}
`}function pc(e,t,r,s,n="f32"){let i=t.length,a=Bt(n),o=n==="f16"?`enable f16;
`:"";return i===0?`${o}
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> a: array<${a}>;
@group(0) @binding(1) var<storage, read_write> out: array<${a}>;
@group(0) @binding(2) var<uniform> params: Params;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
  let x = a[${s}u];
  out[idx] = ${e};
}
`:`${o}
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> a: array<${a}>;
@group(0) @binding(1) var<storage, read_write> out: array<${a}>;
@group(0) @binding(2) var<uniform> params: Params;

const RANK: u32 = ${i}u;
const SHAPE = ${`array<u32, ${i}>(${t.map(u=>`${u}u`).join(", ")})`};
const STRIDES = ${`array<u32, ${i}>(${r.map(u=>`${u}u`).join(", ")})`};
const OFFSET: u32 = ${s}u;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }

  // Convert flat index to strided offset
  var remaining = idx;
  var inputOffset = OFFSET;
  for (var d = 0u; d < RANK; d = d + 1u) {
    var dimSize = 1u;
    for (var j = d + 1u; j < RANK; j = j + 1u) {
      dimSize = dimSize * SHAPE[j];
    }
    let coord = remaining / dimSize;
    remaining = remaining % dimSize;
    inputOffset = inputOffset + coord * STRIDES[d];
  }

  let x = a[inputOffset];
  out[idx] = ${e};
}
`}function ke(e,t,r){let s=e.pipelines.get(t);if(s)return s;let n=e.device.createShaderModule({code:r}),i=e.device.createComputePipeline({layout:"auto",compute:{module:n,entryPoint:"main"}});return e.pipelines.set(t,i),i}function or(e,t,r,s){let n=wi(t.shape,r.shape),i=yi(n),a=Pe(n);if(a===0)throw Error("webgpu ops do not support empty tensors yet");let o=be(),u=t.dtype;if(r.dtype!==u)throw Error(`webgpu binary op: mismatched dtypes ${t.dtype} and ${r.dtype}`);let l=nt(t,i),d=nt(r,i),c=hc(e,i,l,d,t.offset,r.offset,u),h=ke(o,`binary:${e}:${i.join("x")}:${l.join(",")}:${d.join(",")}:${t.offset}:${r.offset}:${u}`,c),f=Et(u),w=s?.outBuffer??de(o.device,{size:ot(a*f),usage:N.STORAGE|N.COPY_SRC|N.COPY_DST}),m=Ke(o.device,a),p=o.device.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:r.buffer}},{binding:2,resource:{buffer:w}},{binding:3,resource:{buffer:m}}]}),g=o.device.createCommandEncoder(),b=g.beginComputePass();return b.setPipeline(h),b.setBindGroup(0,p),b.dispatchWorkgroups(Math.ceil(a/256)),b.end(),o.queue.submit([g.finish()]),me(n,w,void 0,0,u,s?.outBuffer===void 0)}function ze(e,t,r,s){let n=be(),i=r.dtype,a=pc(t,r.shape,r.strides,r.offset,i),o=ke(n,`unary:${e}:${r.shape.join("x")}:${r.strides.join(",")}:${r.offset}:${i}`,a),u=Et(i),l=s?.outBuffer??de(n.device,{size:ot(r.size*u),usage:N.STORAGE|N.COPY_SRC|N.COPY_DST}),d=Ke(n.device,r.size),c=n.device.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r.buffer}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:d}}]}),h=n.device.createCommandEncoder(),f=h.beginComputePass();f.setPipeline(o),f.setBindGroup(0,c),f.dispatchWorkgroups(Math.ceil(r.size/256)),f.end(),n.queue.submit([h.finish()]);let w=s?.outBuffer===void 0;return me(r.shape,l,void 0,0,i,w)}function fc(e,t,r=!1,s=!1,n){let i=be(),a=Xd(e.shape,t.shape,r,s),o=e.shape.length,u=t.shape.length,l,d,c;r?(d=e.shape[o-2],l=e.shape[o-1]):(l=e.shape[o-2],d=e.shape[o-1]),c=s?t.shape[u-2]:t.shape[u-1];let h=a.slice(0,-2),f=jt(h),{strideA:w,strideB:m,strideC:p}=Jd(e.shape,t.shape,h,l,c,d),g=a.reduce((v,k)=>v*k,1)*4,b=n&&n.size>=g?n:de(i.device,{size:g,usage:N.STORAGE|N.COPY_SRC});return Zd({device:i.device,queue:i.queue,a:e.buffer,b:t.buffer,out:b,m:l,n:c,k:d,batchSize:f,batchStrideA:w,batchStrideB:m,batchStrideC:p,transA:r,transB:s,dtype:"f32"}),me(a,b,void 0,0,"f32",!0)}function mc(e,t){let r=be();if(Pe(t)!==e.length)throw Error("Tensor data length does not match shape");return me(t,cc(r.device,Float32Array.from(e),r.queue),void 0,0,"f32")}function gc(e,t,r){return or("+",e,t,r)}function wc(e,t,r){return or("-",e,t,r)}function yc(e,t,r){return or("/",e,t,r)}function bc(e,t,r){return or("*",e,t,r)}function vc(e,t){return ze("sqrt","sqrt(x)",e,t)}function _c(e,t){return ze("relu","select(0.0, x, x > 0.0)",e,t)}function kc(e,t){return ze("exp","exp(x)",e,t)}function Sc(e,t){return ze("log","log(x)",e,t)}function xc(e,t){return ze("neg","-x",e,t)}function Ac(e,t){return ze("abs","abs(x)",e,t)}function Ec(e,t){return ze("tanh","tanh(x)",e,t)}function Ic(e,t){return ze("sigmoid","(1.0 / (1.0 + exp(-x)))",e,t)}function $c(e,t){return(t?.approximate??"tanh")==="tanh"?ze("gelu_tanh","(x * 0.5 * (1.0 + tanh(clamp(0.7978845608 * (x + 0.044715 * x * x * x), -10.0, 10.0))))",e,{outBuffer:t?.outBuffer}):ze("gelu_erf","(x * 0.5 * (1.0 + sign(x) * (1.0 - (((((1.061405429 * (1.0 / (1.0 + 0.3275911 * abs(x * 0.7071067811865476))) + -1.453152027) * (1.0 / (1.0 + 0.3275911 * abs(x * 0.7071067811865476))) + 1.421413741) * (1.0 / (1.0 + 0.3275911 * abs(x * 0.7071067811865476))) + -0.284496736) * (1.0 / (1.0 + 0.3275911 * abs(x * 0.7071067811865476))) + 0.254829592) * (1.0 / (1.0 + 0.3275911 * abs(x * 0.7071067811865476))) * exp(-x * x * 0.5)))))",e,{outBuffer:t?.outBuffer})}function zc(e,t){return ze("silu","(x / (1.0 + exp(-x)))",e,t)}function Cc(e,t){return ze("isfinite","select(0.0, 1.0, x == x && x * 0.0 == 0.0)",e,t)}function Tc(e,t,r,s,n){let i=r.length,a=Bt(e),o=Bt(t),u=e==="f16"||t==="f16"?`enable f16;
`:"",l;return l=e===t?"x":t==="f32"?"f32(x)":t==="f16"?"f16(x)":t==="i32"?"i32(x)":t==="u32"?"u32(x)":`${o}(x)`,i===0?`${u}
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> a: array<${a}>;
@group(0) @binding(1) var<storage, read_write> out: array<${o}>;
@group(0) @binding(2) var<uniform> params: Params;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
  let x = a[${n}u];
  out[idx] = ${l};
}
`:`${u}
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> a: array<${a}>;
@group(0) @binding(1) var<storage, read_write> out: array<${o}>;
@group(0) @binding(2) var<uniform> params: Params;

const RANK: u32 = ${i}u;
const SHAPE = ${`array<u32, ${i}>(${r.map(d=>`${d}u`).join(", ")})`};
const STRIDES = ${`array<u32, ${i}>(${s.map(d=>`${d}u`).join(", ")})`};
const OFFSET: u32 = ${n}u;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }

  // Convert flat index to strided offset
  var remaining = idx;
  var inputOffset = OFFSET;
  for (var d = 0u; d < RANK; d = d + 1u) {
    var dimSize = 1u;
    for (var j = d + 1u; j < RANK; j = j + 1u) {
      dimSize = dimSize * SHAPE[j];
    }
    let coord = remaining / dimSize;
    remaining = remaining % dimSize;
    inputOffset = inputOffset + coord * STRIDES[d];
  }

  let x = a[inputOffset];
  out[idx] = ${l};
}
`}function Bc(e,t){let r=e,s=be();if(r.dtype===t)return r;if(t==="f16"&&!s.f16Supported)throw Error("f16 dtype requires shader-f16 device feature which is not available");let n=Tc(r.dtype,t,r.shape,r.strides,r.offset),i=ke(s,`cast:${r.dtype}->${t}:${r.shape.join("x")}:${r.strides.join(",")}:${r.offset}`,n),a=Et(t),o=de(s.device,{size:ot(r.size*a),usage:N.STORAGE|N.COPY_SRC}),u=Ke(s.device,r.size),l=s.device.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r.buffer}},{binding:1,resource:{buffer:o}},{binding:2,resource:{buffer:u}}]}),d=s.device.createCommandEncoder(),c=d.beginComputePass();return c.setPipeline(i),c.setBindGroup(0,l),c.dispatchWorkgroups(Math.ceil(r.size/256)),c.end(),s.queue.submit([d.finish()]),me(r.shape,o,void 0,0,t)}function Mc(e,t){let r=e;if(Pe(t)!==r.size)throw Error("View shape does not match tensor size");return me(t,r.buffer,void 0,r.offset,r.dtype,!1)}function Dc(e,t){let r=e,s=r.shape,n=r.strides;if(t.length<s.length)throw Error("expand: target shape must have at least as many dimensions as input");let i=[],a=t.length-s.length;for(let o=0;o<t.length;o++)if(o<a)i.push(0);else{let u=o-a,l=s[u],d=t[o];if(l===1&&d>1)i.push(0);else if(l===d)i.push(n[u]);else throw Error(`expand: incompatible shapes at dimension ${o} (input ${l} vs output ${d})`)}return me(t,r.buffer,i,r.offset,r.dtype,!1)}function bi(e){let t=e;if(t.isContiguous)return t;let r=be(),s=t.shape,n=s.length,i=Pe(s),a=t.dtype,o=Bt(a),u=Et(a);if(i===0)throw Error("contiguous: empty tensors not supported");let l=de(r.device,{size:ot(i*u),usage:N.STORAGE|N.COPY_SRC}),d=`array<u32, ${n}>(${s.map(v=>`${v}u`).join(", ")})`,c=`array<u32, ${n}>(${t.strides.map(v=>`${v}u`).join(", ")})`,h=`array<u32, ${n}>(${Ss(s).map(v=>`${v}u`).join(", ")})`,f=`${a==="f16"?`enable f16;
`:""}
struct Params {
  size: u32,
  offset: u32,
};

@group(0) @binding(0) var<storage, read> input: array<${o}>;
@group(0) @binding(1) var<storage, read_write> out: array<${o}>;
@group(0) @binding(2) var<uniform> params: Params;

const RANK: u32 = ${n}u;
const shape = ${d};
const inputStrides = ${c};
const outStrides = ${h};

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }

  // Convert output flat index to coordinates
  var coords: array<u32, ${n}>;
  var remaining = idx;
  for (var d = 0u; d < RANK; d = d + 1u) {
    coords[d] = remaining / outStrides[d];
    remaining = remaining % outStrides[d];
  }

  // Compute input offset using strides
  var inputOffset = params.offset;
  for (var d = 0u; d < RANK; d = d + 1u) {
    inputOffset = inputOffset + coords[d] * inputStrides[d];
  }

  out[idx] = input[inputOffset];
}
`,w=ke(r,`contiguous:${s.join(",")}:${t.strides.join(",")}:${t.offset}:${a}`,f),m=de(r.device,{size:8,usage:N.UNIFORM|N.COPY_DST});r.queue.writeBuffer(m,0,new Uint32Array([i,t.offset]));let p=r.device.createBindGroup({layout:w.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:m}}]}),g=r.device.createCommandEncoder(),b=g.beginComputePass();return b.setPipeline(w),b.setBindGroup(0,p),b.dispatchWorkgroups(Math.ceil(i/256)),b.end(),r.queue.submit([g.finish()]),me(s,l,void 0,0,a)}function As(e){return e.isContiguous?e:bi(e)}function Rc(e,t){let r=e,{dim0:s,dim1:n}=t,i=r.shape,a=i.length;if(s<0||s>=a||n<0||n>=a)throw Error("transpose: dimension out of range");let o=i.slice();o[s]=i[n],o[n]=i[s];let u=r.strides.slice();return u[s]=r.strides[n],u[n]=r.strides[s],me(o,r.buffer,u,r.offset,r.dtype,!1)}function Pc(e,t){let r=e,s=r.shape,n=s.length;if(t.length!==n)throw Error(`permute: dims length ${t.length} doesn't match tensor rank ${n}`);let i=new Set;for(let u of t){if(u<0||u>=n)throw Error(`permute: dimension ${u} out of range for rank ${n}`);if(i.has(u))throw Error(`permute: duplicate dimension ${u}`);i.add(u)}let a=t.map(u=>s[u]),o=t.map(u=>r.strides[u]);return me(a,r.buffer,o,r.offset,r.dtype,!1)}function Fc(e,t,r){return fc(e,t,!1,!1,r?.outBuffer)}function Lc(e,t,r){let s=be(),n=e,i=t,{dim:a}=r,o=n.shape,u=i.shape,l=o.length;if(a<0||a>=l)throw Error("gather: dimension out of range");let d=u.slice(),c=d.reduce((y,x)=>y*x,1),h=de(s.device,{size:c*4,usage:N.STORAGE|N.COPY_SRC}),f=[];for(let y=0;y<l;y++){let x=1;for(let z=y+1;z<l;z++)x*=o[z];f.push(x)}let w=[];for(let y=0;y<u.length;y++){let x=1;for(let z=y+1;z<u.length;z++)x*=u[z];w.push(x)}let m=`
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read> indices: array<f32>;
@group(0) @binding(2) var<storage, read_write> out: array<f32>;
@group(0) @binding(3) var<uniform> params: Params;

const RANK: u32 = ${l}u;
const DIM: u32 = ${a}u;
const inputStrides = ${`array<u32, ${l}>(${f.map(y=>`${y}u`).join(", ")})`};
const indexShape = ${`array<u32, ${l}>(${u.map(y=>`${y}u`).join(", ")})`};
const indexStrides = ${`array<u32, ${l}>(${w.map(y=>`${y}u`).join(", ")})`};

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }

  // Convert flat index to coordinates in index tensor
  var coords: array<u32, ${l}>;
  var remaining = idx;
  for (var d = 0u; d < RANK; d = d + 1u) {
    coords[d] = remaining / indexStrides[d];
    remaining = remaining % indexStrides[d];
  }

  // Get the gather index for the specified dimension
  let gatherIdx = u32(indices[idx]);

  // Compute input offset using coords, but replace dim with gatherIdx
  var inputOffset = 0u;
  for (var d = 0u; d < RANK; d = d + 1u) {
    if (d == DIM) {
      inputOffset = inputOffset + gatherIdx * inputStrides[d];
    } else {
      inputOffset = inputOffset + coords[d] * inputStrides[d];
    }
  }

  out[idx] = input[inputOffset];
}
`,p=ke(s,`gather:${o.join(",")}:${u.join(",")}:${a}`,m),g=Ke(s.device,c),b=s.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:i.buffer}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:g}}]}),v=s.device.createCommandEncoder(),k=v.beginComputePass();return k.setPipeline(p),k.setBindGroup(0,b),k.dispatchWorkgroups(Math.ceil(c/256)),k.end(),s.queue.submit([v.finish()]),me(d,h)}function Nc(e,t,r,s){let n=be(),i=e,a=t,o=r,{dim:u}=s,l=i.shape,d=l.length;if(u<0||u>=d)throw Error("scatterAdd: dimension out of range");let c=l.slice(),h=c.reduce((M,D)=>M*D,1),f=o.shape.reduce((M,D)=>M*D,1),w=de(n.device,{size:h*4,usage:N.STORAGE|N.COPY_SRC|N.COPY_DST}),m=n.device.createCommandEncoder();m.copyBufferToBuffer(i.buffer,0,w,0,h*4),n.queue.submit([m.finish()]);let p=[];for(let M=0;M<d;M++){let D=1;for(let B=M+1;B<d;B++)D*=c[B];p.push(D)}let g=[];for(let M=0;M<o.shape.length;M++){let D=1;for(let B=M+1;B<o.shape.length;B++)D*=o.shape[B];g.push(D)}let b=`
struct Params {
  srcSize: u32,
};

@group(0) @binding(0) var<storage, read> indices: array<f32>;
@group(0) @binding(1) var<storage, read> src: array<f32>;
@group(0) @binding(2) var<storage, read_write> out: array<f32>;
@group(0) @binding(3) var<uniform> params: Params;

const RANK: u32 = ${d}u;
const DIM: u32 = ${u}u;
const outStrides = ${`array<u32, ${d}>(${p.map(M=>`${M}u`).join(", ")})`};
const srcShape = ${`array<u32, ${d}>(${o.shape.map(M=>`${M}u`).join(", ")})`};
const srcStrides = ${`array<u32, ${d}>(${g.map(M=>`${M}u`).join(", ")})`};

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let srcIdx = gid.x;
  if (srcIdx >= params.srcSize) {
    return;
  }

  // Convert src flat index to coordinates
  var coords: array<u32, ${d}>;
  var remaining = srcIdx;
  for (var d = 0u; d < RANK; d = d + 1u) {
    coords[d] = remaining / srcStrides[d];
    remaining = remaining % srcStrides[d];
  }

  // Get the scatter index for the specified dimension
  let scatterIdx = u32(indices[srcIdx]);

  // Compute output offset using coords, but replace dim with scatterIdx
  var outOffset = 0u;
  for (var d = 0u; d < RANK; d = d + 1u) {
    if (d == DIM) {
      outOffset = outOffset + scatterIdx * outStrides[d];
    } else {
      outOffset = outOffset + coords[d] * outStrides[d];
    }
  }

  // Atomic add would be ideal here, but f32 atomics aren't widely supported
  // For now, we accept potential race conditions for overlapping indices
  out[outOffset] = out[outOffset] + src[srcIdx];
}
`,v=ke(n,`scatterAdd:${l.join(",")}:${o.shape.join(",")}:${u}`,b),k=Ke(n.device,f),y=n.device.createBindGroup({layout:v.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:a.buffer}},{binding:1,resource:{buffer:o.buffer}},{binding:2,resource:{buffer:w}},{binding:3,resource:{buffer:k}}]}),x=n.device.createCommandEncoder(),z=x.beginComputePass();return z.setPipeline(v),z.setBindGroup(0,y),z.dispatchWorkgroups(Math.ceil(f/256)),z.end(),n.queue.submit([x.finish()]),me(c,w)}function vi(e,t){let r=be(),s=e,n=s.shape,i=t?.dim,a=t?.keepdim??!1;if(i==null)return Zs(r,s);let o=Array.isArray(i)?i:[i],u=n.length,l=o.map(_=>_<0?_+u:_);for(let _ of l)if(_<0||_>=u)throw Error(`sum: dimension ${_} out of range`);let d=[];for(let _=0;_<u;_++)l.includes(_)?a&&d.push(1):d.push(n[_]);if(d.length===0)return Zs(r,s);let c=d.reduce((_,T)=>_*T,1),h=de(r.device,{size:c*4,usage:N.STORAGE|N.COPY_SRC}),f=[];for(let _=0;_<u;_++){let T=1;for(let $=_+1;$<u;$++)T*=n[$];f.push(T)}let w=[];for(let _=0;_<d.length;_++){let T=1;for(let $=_+1;$<d.length;$++)T*=d[$];w.push(T)}let m=1;for(let _ of l)m*=n[_];let p=[],g=0;for(let _=0;_<u;_++)l.includes(_)?a?(p.push(g),g++):p.push(-1):(p.push(g),g++);let b=`array<u32, ${u}>(${n.map(_=>`${_}u`).join(", ")})`,v=`array<u32, ${u}>(${f.map(_=>`${_}u`).join(", ")})`,k=d.length>0?`array<u32, ${d.length}>(${d.map(_=>`${_}u`).join(", ")})`:"",y=w.length>0?`array<u32, ${w.length}>(${w.map(_=>`${_}u`).join(", ")})`:"",x=`array<u32, ${l.length}>(${l.map(_=>`${_}u`).join(", ")})`,z=`array<i32, ${u}>(${p.map(_=>`${_}i`).join(", ")})`,M=`
struct Params {
  outSize: u32,
  reductionSize: u32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> out: array<f32>;
@group(0) @binding(2) var<uniform> params: Params;

const INPUT_RANK: u32 = ${u}u;
const OUT_RANK: u32 = ${d.length}u;
const NUM_REDUCE_DIMS: u32 = ${l.length}u;
const inputShape = ${b};
const inputStrides = ${v};
${d.length>0?`const outShape = ${k};`:""}
${w.length>0?`const outStrides = ${y};`:""}
const reduceDims = ${x};
const inputToOutDim = ${z};

fn isReduceDim(d: u32) -> bool {
  for (var i = 0u; i < NUM_REDUCE_DIMS; i = i + 1u) {
    if (reduceDims[i] == d) {
      return true;
    }
  }
  return false;
}

fn getReduceDimIndex(d: u32) -> u32 {
  for (var i = 0u; i < NUM_REDUCE_DIMS; i = i + 1u) {
    if (reduceDims[i] == d) {
      return i;
    }
  }
  return 0u;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let outIdx = gid.x;
  if (outIdx >= params.outSize) {
    return;
  }

  // Convert output index to output coordinates
  var outCoords: array<u32, ${Math.max(d.length,1)}>;
  ${d.length>0?`
  var remaining = outIdx;
  for (var d = 0u; d < OUT_RANK; d = d + 1u) {
    outCoords[d] = remaining / outStrides[d];
    remaining = remaining % outStrides[d];
  }
  `:""}

  // Sum over all reduction indices
  var total = 0.0;
  for (var reduceIdx = 0u; reduceIdx < params.reductionSize; reduceIdx = reduceIdx + 1u) {
    // Convert reduceIdx to coordinates in reduced dimensions
    var reduceCoords: array<u32, ${Math.max(l.length,1)}>;
    var rRemaining = reduceIdx;
    ${l.length>0?l.map((_,T)=>`
    {
      var rDimSize = 1u;
      for (var j = ${T+1}u; j < NUM_REDUCE_DIMS; j = j + 1u) {
        rDimSize = rDimSize * inputShape[reduceDims[j]];
      }
      reduceCoords[${T}u] = rRemaining / rDimSize;
      rRemaining = rRemaining % rDimSize;
    }
    `).join(""):""}

    // Build full input coordinates
    var inputOffset = 0u;
    for (var d = 0u; d < INPUT_RANK; d = d + 1u) {
      var coord = 0u;
      if (isReduceDim(d)) {
        // Use the reduce coordinate
        let rIdx = getReduceDimIndex(d);
        coord = reduceCoords[rIdx];
      } else {
        // Use the output coordinate - find which output dim this maps to
        let outD = inputToOutDim[d];
        if (outD >= 0i) {
          coord = outCoords[u32(outD)];
        }
      }
      inputOffset = inputOffset + coord * inputStrides[d];
    }

    total = total + input[inputOffset];
  }

  out[outIdx] = total;
}
`,D=ke(r,`sum:${n.join(",")}:${l.join(",")}:${a}`,M),B=de(r.device,{size:8,usage:N.UNIFORM|N.COPY_DST});r.queue.writeBuffer(B,0,new Uint32Array([c,m]));let R=r.device.createBindGroup({layout:D.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s.buffer}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:B}}]}),L=r.device.createCommandEncoder(),q=L.beginComputePass();return q.setPipeline(D),q.setBindGroup(0,R),q.dispatchWorkgroups(Math.ceil(c/256)),q.end(),r.queue.submit([L.finish()]),me(d,h)}function Zs(e,t){let r=t.size,s=de(e.device,{size:4,usage:N.STORAGE|N.COPY_SRC}),n=ke(e,`sumFullSeq:${r}`,`
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> out: array<f32>;
@group(0) @binding(2) var<uniform> params: Params;

@compute @workgroup_size(1)
fn main() {
  var sum = 0.0;
  for (var i = 0u; i < params.size; i = i + 1u) {
    sum = sum + input[i];
  }
  out[0] = sum;
}
`),i=Ke(e.device,r),a=e.device.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:i}}]}),o=e.device.createCommandEncoder(),u=o.beginComputePass();return u.setPipeline(n),u.setBindGroup(0,a),u.dispatchWorkgroups(1),u.end(),e.queue.submit([o.finish()]),me([],s)}function Xs(e,t){let r=t.size,s=de(e.device,{size:4,usage:N.STORAGE|N.COPY_SRC}),n=ke(e,`maxFullSeq:${r}`,`
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> out: array<f32>;
@group(0) @binding(2) var<uniform> params: Params;

@compute @workgroup_size(1)
fn main() {
  var maxVal = input[0];
  for (var i = 1u; i < params.size; i = i + 1u) {
    maxVal = max(maxVal, input[i]);
  }
  out[0] = maxVal;
}
`),i=Ke(e.device,r),a=e.device.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:i}}]}),o=e.device.createCommandEncoder(),u=o.beginComputePass();return u.setPipeline(n),u.setBindGroup(0,a),u.dispatchWorkgroups(1),u.end(),e.queue.submit([o.finish()]),me([],s)}function qc(e,t){let r=be(),s=e,n=s.shape,i=t?.dim,a=t?.keepdim??!1;if(i==null)return Xs(r,s);let o=Array.isArray(i)?i:[i],u=n.length,l=o.map(_=>_<0?_+u:_);for(let _ of l)if(_<0||_>=u)throw Error(`max: dimension ${_} out of range`);let d=[];for(let _=0;_<u;_++)l.includes(_)?a&&d.push(1):d.push(n[_]);if(d.length===0)return Xs(r,s);let c=d.reduce((_,T)=>_*T,1),h=de(r.device,{size:c*4,usage:N.STORAGE|N.COPY_SRC}),f=[];for(let _=0;_<u;_++){let T=1;for(let $=_+1;$<u;$++)T*=n[$];f.push(T)}let w=[];for(let _=0;_<d.length;_++){let T=1;for(let $=_+1;$<d.length;$++)T*=d[$];w.push(T)}let m=1;for(let _ of l)m*=n[_];let p=[],g=0;for(let _=0;_<u;_++)l.includes(_)?a?(p.push(g),g++):p.push(-1):(p.push(g),g++);let b=`array<u32, ${u}>(${n.map(_=>`${_}u`).join(", ")})`,v=`array<u32, ${u}>(${f.map(_=>`${_}u`).join(", ")})`,k=d.length>0?`array<u32, ${d.length}>(${d.map(_=>`${_}u`).join(", ")})`:"",y=w.length>0?`array<u32, ${w.length}>(${w.map(_=>`${_}u`).join(", ")})`:"",x=`array<u32, ${l.length}>(${l.map(_=>`${_}u`).join(", ")})`,z=`array<i32, ${u}>(${p.map(_=>`${_}i`).join(", ")})`,M=`
struct Params {
  outSize: u32,
  reductionSize: u32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> out: array<f32>;
@group(0) @binding(2) var<uniform> params: Params;

const INPUT_RANK: u32 = ${u}u;
const OUT_RANK: u32 = ${d.length}u;
const NUM_REDUCE_DIMS: u32 = ${l.length}u;
const inputShape = ${b};
const inputStrides = ${v};
${d.length>0?`const outShape = ${k};`:""}
${w.length>0?`const outStrides = ${y};`:""}
const reduceDims = ${x};
const inputToOutDim = ${z};

fn isReduceDim(d: u32) -> bool {
  for (var i = 0u; i < NUM_REDUCE_DIMS; i = i + 1u) {
    if (reduceDims[i] == d) {
      return true;
    }
  }
  return false;
}

fn getReduceDimIndex(d: u32) -> u32 {
  for (var i = 0u; i < NUM_REDUCE_DIMS; i = i + 1u) {
    if (reduceDims[i] == d) {
      return i;
    }
  }
  return 0u;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let outIdx = gid.x;
  if (outIdx >= params.outSize) {
    return;
  }

  var outCoords: array<u32, ${Math.max(d.length,1)}>;
  ${d.length>0?`
  var remaining = outIdx;
  for (var d = 0u; d < OUT_RANK; d = d + 1u) {
    outCoords[d] = remaining / outStrides[d];
    remaining = remaining % outStrides[d];
  }
  `:""}

  // Find max over all reduction indices
  var maxVal = -3.402823466e+38; // -FLT_MAX
  for (var reduceIdx = 0u; reduceIdx < params.reductionSize; reduceIdx = reduceIdx + 1u) {
    var reduceCoords: array<u32, ${Math.max(l.length,1)}>;
    var rRemaining = reduceIdx;
    ${l.length>0?l.map((_,T)=>`
    {
      var rDimSize = 1u;
      for (var j = ${T+1}u; j < NUM_REDUCE_DIMS; j = j + 1u) {
        rDimSize = rDimSize * inputShape[reduceDims[j]];
      }
      reduceCoords[${T}u] = rRemaining / rDimSize;
      rRemaining = rRemaining % rDimSize;
    }
    `).join(""):""}

    var inputOffset = 0u;
    for (var d = 0u; d < INPUT_RANK; d = d + 1u) {
      var coord = 0u;
      if (isReduceDim(d)) {
        let rIdx = getReduceDimIndex(d);
        coord = reduceCoords[rIdx];
      } else {
        let outD = inputToOutDim[d];
        if (outD >= 0i) {
          coord = outCoords[u32(outD)];
        }
      }
      inputOffset = inputOffset + coord * inputStrides[d];
    }

    maxVal = max(maxVal, input[inputOffset]);
  }

  out[outIdx] = maxVal;
}
`,D=ke(r,`max:${n.join(",")}:${l.join(",")}:${a}`,M),B=de(r.device,{size:8,usage:N.UNIFORM|N.COPY_DST});r.queue.writeBuffer(B,0,new Uint32Array([c,m]));let R=r.device.createBindGroup({layout:D.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s.buffer}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:B}}]}),L=r.device.createCommandEncoder(),q=L.beginComputePass();return q.setPipeline(D),q.setBindGroup(0,R),q.dispatchWorkgroups(Math.ceil(c/256)),q.end(),r.queue.submit([L.finish()]),me(d,h)}function Gc(e,t){let r=e,s=r.shape,n=t?.dim,i;if(n==null)i=r.size;else{let p=Array.isArray(n)?n:[n],g=s.length;i=p.reduce((b,v)=>b*s[v<0?v+g:v],1)}let a=vi(e,t),o=be(),u=a.size,l=de(o.device,{size:u*4,usage:N.STORAGE|N.COPY_SRC}),d=ke(o,`meanDiv:${u}:${i}`,`
struct Params {
  size: u32,
  count: f32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> out: array<f32>;
@group(0) @binding(2) var<uniform> params: Params;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
  out[idx] = input[idx] / params.count;
}
`),c=de(o.device,{size:8,usage:N.UNIFORM|N.COPY_DST}),h=new ArrayBuffer(8);new Uint32Array(h,0,1)[0]=u,new Float32Array(h,4,1)[0]=i,o.queue.writeBuffer(c,0,new Uint8Array(h));let f=o.device.createBindGroup({layout:d.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:a.buffer}},{binding:1,resource:{buffer:l}},{binding:2,resource:{buffer:c}}]}),w=o.device.createCommandEncoder(),m=w.beginComputePass();return m.setPipeline(d),m.setBindGroup(0,f),m.dispatchWorkgroups(Math.ceil(u/256)),m.end(),o.queue.submit([w.finish()]),me(a.shape,l)}function It(e,t,r,s,n){let i=be(),a=r,o=s,u=wi(a.shape,o.shape),l=u.reduce((y,x)=>y*x,1),d=nt(a,u),c=nt(o,u),h=l*4,f=n?.outBuffer&&n.outBuffer.size>=h?n.outBuffer:de(i.device,{size:h,usage:N.STORAGE|N.COPY_SRC}),w=xs(u,[d,c]),m=`
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> a: array<f32>;
@group(0) @binding(1) var<storage, read> b: array<f32>;
@group(0) @binding(2) var<storage, read_write> out: array<f32>;
@group(0) @binding(3) var<uniform> params: Params;

${w.declarations}
const A_OFFSET: u32 = ${a.offset}u;
const B_OFFSET: u32 = ${o.offset}u;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
${w.compute}
${w.offsets.join(`
`)}
  let aVal = a[offset0 + A_OFFSET];
  let bVal = b[offset1 + B_OFFSET];
  out[idx] = select(0.0, 1.0, aVal ${t} bVal);
}
`,p=ke(i,`${e}:${a.shape.join(",")}:${o.shape.join(",")}`,m),g=Ke(i.device,l),b=i.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:a.buffer}},{binding:1,resource:{buffer:o.buffer}},{binding:2,resource:{buffer:f}},{binding:3,resource:{buffer:g}}]}),v=i.device.createCommandEncoder(),k=v.beginComputePass();return k.setPipeline(p),k.setBindGroup(0,b),k.dispatchWorkgroups(Math.ceil(l/256)),k.end(),i.queue.submit([v.finish()]),me(u,f)}function Uc(e,t,r){return It("gt",">",e,t,r)}function Oc(e,t,r){return It("lt","<",e,t,r)}function Vc(e,t,r){return It("ge",">=",e,t,r)}function jc(e,t,r){return It("le","<=",e,t,r)}function Wc(e,t,r){return It("eq","==",e,t,r)}function Hc(e,t,r){return It("ne","!=",e,t,r)}function Kc(e,t){return _i("argmax",">",e,t)}function Yc(e,t){return _i("argmin","<",e,t)}function _i(e,t,r,s){let n=be(),i=r,a=i.shape,o=a.length,u=s.dim<0?s.dim+o:s.dim;if(u<0||u>=o)throw Error(`${e}: dim ${s.dim} out of range for tensor of rank ${o}`);let l=s.keepdim??!1,d=[];for(let T=0;T<o;T++)T===u?l&&d.push(1):d.push(a[T]);let c=d.reduce((T,$)=>T*$,1)||1,h=de(n.device,{size:c*4,usage:N.STORAGE|N.COPY_SRC}),f=[];for(let T=0;T<o;T++){let $=1;for(let P=T+1;P<o;P++)$*=a[P];f.push($)}let w=[];for(let T=0;T<d.length;T++){let $=1;for(let P=T+1;P<d.length;P++)$*=d[P];w.push($)}let m=a[u],p=f[u],g=[],b=0;for(let T=0;T<o;T++)T===u?l?(g.push(b),b++):g.push(-1):(g.push(b),b++);let v=`array<u32, ${o}>(${a.map(T=>`${T}u`).join(", ")})`,k=`array<u32, ${o}>(${f.map(T=>`${T}u`).join(", ")})`,y=d.length>0?`array<u32, ${d.length}>(${d.map(T=>`${T}u`).join(", ")})`:"",x=w.length>0?`array<u32, ${w.length}>(${w.map(T=>`${T}u`).join(", ")})`:"",z=`array<i32, ${o}>(${g.map(T=>`${T}i`).join(", ")})`,M=t===">"?"-3.402823466e+38":"3.402823466e+38",D=`
struct Params {
  outSize: u32,
  dimSize: u32,
  dimStride: u32,
};

@group(0) @binding(0) var<storage, read> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> out: array<f32>;
@group(0) @binding(2) var<uniform> params: Params;

const INPUT_RANK: u32 = ${o}u;
const OUT_RANK: u32 = ${d.length}u;
const REDUCE_DIM: u32 = ${u}u;
const inputShape = ${v};
const inputStrides = ${k};
${d.length>0?`const outShape = ${y};`:""}
${w.length>0?`const outStrides = ${x};`:""}
const inputToOutDim = ${z};

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let outIdx = gid.x;
  if (outIdx >= params.outSize) {
    return;
  }

  var outCoords: array<u32, ${Math.max(d.length,1)}>;
  ${d.length>0?`
  var remaining = outIdx;
  for (var d = 0u; d < OUT_RANK; d = d + 1u) {
    outCoords[d] = remaining / outStrides[d];
    remaining = remaining % outStrides[d];
  }
  `:""}

  // Compute base offset in input (with reduce dim = 0)
  var baseOffset = 0u;
  for (var d = 0u; d < INPUT_RANK; d = d + 1u) {
    if (d != REDUCE_DIM) {
      let outD = inputToOutDim[d];
      if (outD >= 0i) {
        baseOffset = baseOffset + outCoords[u32(outD)] * inputStrides[d];
      }
    }
  }

  // Find argmax/argmin along the reduce dimension
  var bestVal = ${M};
  var bestIdx = 0u;
  for (var i = 0u; i < params.dimSize; i = i + 1u) {
    let val = input[baseOffset + i * params.dimStride];
    if (val ${t} bestVal) {
      bestVal = val;
      bestIdx = i;
    }
  }

  out[outIdx] = f32(bestIdx);
}
`,B=ke(n,`${e}:${a.join(",")}:${u}:${l}`,D),R=de(n.device,{size:12,usage:N.UNIFORM|N.COPY_DST});n.queue.writeBuffer(R,0,new Uint32Array([c,m,p]));let L=n.device.createBindGroup({layout:B.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:i.buffer}},{binding:1,resource:{buffer:h}},{binding:2,resource:{buffer:R}}]}),q=n.device.createCommandEncoder(),_=q.beginComputePass();return _.setPipeline(B),_.setBindGroup(0,L),_.dispatchWorkgroups(Math.ceil(c/256)),_.end(),n.queue.submit([q.finish()]),me(d,h)}function Qc(e,t,r,s,n,i,a){let o=xs(e,[t,r,s]);return`
struct Params {
  size: u32,
};

@group(0) @binding(0) var<storage, read> cond: array<f32>;
@group(0) @binding(1) var<storage, read> x: array<f32>;
@group(0) @binding(2) var<storage, read> y: array<f32>;
@group(0) @binding(3) var<storage, read_write> out: array<f32>;
@group(0) @binding(4) var<uniform> params: Params;

${o.declarations}
const COND_OFFSET: u32 = ${n}u;
const X_OFFSET: u32 = ${i}u;
const Y_OFFSET: u32 = ${a}u;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
${o.compute}
${o.offsets.join(`
`)}
  let condVal = cond[offset0 + COND_OFFSET];
  let xVal = x[offset1 + X_OFFSET];
  let yVal = y[offset2 + Y_OFFSET];
  out[idx] = select(yVal, xVal, condVal != 0.0);
}
`}function Zc(e,t,r){let s=Math.max(e.length,t.length,r.length),n=Array(s);for(let i=0;i<s;i+=1){let a=e[e.length-1-i]??1,o=t[t.length-1-i]??1,u=r[r.length-1-i]??1;if(a!==o&&a!==1&&o!==1||a!==u&&a!==1&&u!==1||o!==u&&o!==1&&u!==1)throw Error("webgpu shapes are not broadcastable");n[s-1-i]=Math.max(a,o,u)}return n}function Xc(e,t,r,s){let n=e,i=t,a=r,o=Zc(n.shape,i.shape,a.shape),u=yi(o),l=Pe(o);if(l===0)throw Error("webgpu where does not support empty tensors yet");let d=be(),c=nt(n,u),h=nt(i,u),f=nt(a,u),w=Qc(u,c,h,f,n.offset,i.offset,a.offset),m=ke(d,`where:${u.join("x")}:${c.join(",")}:${h.join(",")}:${f.join(",")}:${n.offset}:${i.offset}:${a.offset}`,w),p=l*4,g=s?.outBuffer&&s.outBuffer.size>=p?s.outBuffer:de(d.device,{size:p,usage:N.STORAGE|N.COPY_SRC}),b=Ke(d.device,l),v=d.device.createBindGroup({layout:m.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:i.buffer}},{binding:2,resource:{buffer:a.buffer}},{binding:3,resource:{buffer:g}},{binding:4,resource:{buffer:b}}]}),k=d.device.createCommandEncoder(),y=k.beginComputePass();return y.setPipeline(m),y.setBindGroup(0,v),y.dispatchWorkgroups(Math.ceil(l/256)),y.end(),d.queue.submit([k.finish()]),me(o,g)}function Jc(e,t,r,s,n,i){let a=t.length;t.reduce((d,c)=>d*c,1);let o="",u=`var baseOffset: u32 = ${s}u;
`,l=`var srcOffset: u32 = ${i}u;
`;for(let d=0;d<a;d++){let c=t.slice(d+1).reduce((h,f)=>h*f,1);o+=`    let coord${d} = (remainder / ${c}u) % ${t[d]}u;
`,d<a-1&&(o+=`    remainder = remainder % ${c}u;
`),u+=`    baseOffset += coord${d} * ${r[d]}u;
`,l+=`    srcOffset += coord${d} * ${n[d]}u;
`}return`
struct Params {
  baseSize: u32,
  viewSize: u32,
};

@group(0) @binding(0) var<storage, read> base: array<f32>;
@group(0) @binding(1) var<storage, read> src: array<f32>;
@group(0) @binding(2) var<storage, read_write> out: array<f32>;
@group(0) @binding(3) var<uniform> params: Params;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;

  // First pass: copy base to output (all threads that fit in baseSize)
  if (idx < params.baseSize) {
    out[idx] = base[idx];
  }

  workgroupBarrier();

  // Second pass: scatter src values into output at view positions
  if (idx < params.viewSize) {
    var remainder = idx;
${o}
${u}
${l}
    out[baseOffset] = src[srcOffset];
  }
}
`}function eh(e,t,r){let s=e,n=t,{offset:i,viewShape:a,viewStrides:o}=r,u=Pe(s.shape),l=Pe(a);if(u===0)throw Error("stridedScatterCopy: empty base tensor");let d=be(),c=s.isContiguous?s:As(s),h=n.strides,f=n.offset,w=Jc(u,a,o,i,h,f),m=ke(d,`stridedScatterCopy:${u}:${a.join("x")}:${o.join(",")}:${i}:${h.join(",")}:${f}`,w),p=de(d.device,{size:u*4,usage:N.STORAGE|N.COPY_SRC}),g=de(d.device,{size:8,usage:N.UNIFORM|N.COPY_DST});d.queue.writeBuffer(g,0,new Uint32Array([u,l]));let b=d.device.createBindGroup({layout:m.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c.buffer}},{binding:1,resource:{buffer:n.buffer}},{binding:2,resource:{buffer:p}},{binding:3,resource:{buffer:g}}]}),v=d.device.createCommandEncoder(),k=v.beginComputePass();k.setPipeline(m),k.setBindGroup(0,b);let y=Math.max(u,l);return k.dispatchWorkgroups(Math.ceil(y/256)),k.end(),d.queue.submit([v.finish()]),me(s.shape,p)}function th(e,t,r,s,n,i){let a=t.length;t.reduce((d,c)=>d*c,1);let o="",u=`var baseOffset: u32 = ${s}u;
`,l=`var srcOffset: u32 = ${i}u;
`;for(let d=0;d<a;d++){let c=t.slice(d+1).reduce((h,f)=>h*f,1);o+=`    let coord${d} = (remainder / ${c}u) % ${t[d]}u;
`,d<a-1&&(o+=`    remainder = remainder % ${c}u;
`),u+=`    baseOffset += coord${d} * ${r[d]}u;
`,l+=`    srcOffset += coord${d} * ${n[d]}u;
`}return`
struct Params {
  baseSize: u32,
  viewSize: u32,
};

@group(0) @binding(0) var<storage, read> base: array<f32>;
@group(0) @binding(1) var<storage, read> src: array<f32>;
@group(0) @binding(2) var<storage, read_write> out: array<f32>;
@group(0) @binding(3) var<uniform> params: Params;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;

  // First pass: copy base to output
  if (idx < params.baseSize) {
    out[idx] = base[idx];
  }

  workgroupBarrier();

  // Second pass: add src values into output at view positions
  if (idx < params.viewSize) {
    var remainder = idx;
${o}
${u}
${l}
    out[baseOffset] = out[baseOffset] + src[srcOffset];
  }
}
`}function rh(e,t,r){let s=e,n=t,{offset:i,viewShape:a,viewStrides:o}=r,u=Pe(s.shape),l=Pe(a);if(u===0)throw Error("stridedScatterAdd: empty base tensor");let d=be(),c=s.isContiguous?s:As(s),h=n.strides,f=n.offset,w=th(u,a,o,i,h,f),m=ke(d,`stridedScatterAdd:${u}:${a.join("x")}:${o.join(",")}:${i}:${h.join(",")}:${f}`,w),p=de(d.device,{size:u*4,usage:N.STORAGE|N.COPY_SRC}),g=de(d.device,{size:8,usage:N.UNIFORM|N.COPY_DST});d.queue.writeBuffer(g,0,new Uint32Array([u,l]));let b=d.device.createBindGroup({layout:m.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:c.buffer}},{binding:1,resource:{buffer:n.buffer}},{binding:2,resource:{buffer:p}},{binding:3,resource:{buffer:g}}]}),v=d.device.createCommandEncoder(),k=v.beginComputePass();k.setPipeline(m),k.setBindGroup(0,b);let y=Math.max(u,l);return k.dispatchWorkgroups(Math.ceil(y/256)),k.end(),d.queue.submit([v.finish()]),me(s.shape,p)}async function sh(e){let t=be(),r=e;if(r.size===0)return[];r.isContiguous||(r=As(r));let s=Et(r.dtype),n=r.size*s,i=ot(n),a=de(t.device,{size:i,usage:N.COPY_DST|N.MAP_READ}),o=t.device.createCommandEncoder();o.copyBufferToBuffer(r.buffer,0,a,0,i),t.queue.submit([o.finish()]),typeof t.queue.onSubmittedWorkDone=="function"&&await t.queue.onSubmittedWorkDone(),await a.mapAsync(tc.READ);let u=a.getMappedRange(),l;switch(r.dtype){case"i32":l=Array.from(new Int32Array(u.slice(0,n)));break;case"u32":l=Array.from(new Uint32Array(u.slice(0,n)));break;case"f16":l=ac(new Uint16Array(u.slice(0,n)));break;case"f32":default:l=Array.from(new Float32Array(u.slice(0,n)));break}return a.unmap(),l}async function ki(){let e=Tt;e&&typeof e.queue.onSubmittedWorkDone=="function"&&await e.queue.onSubmittedWorkDone()}function nh(e,t){let r=be(),s=e,n=s.size,i=r.device.createBuffer({size:16,usage:N.UNIFORM|N.COPY_DST}),a=new ArrayBuffer(16),o=new DataView(a);o.setFloat32(0,t,!0),o.setUint32(4,n,!0),r.queue.writeBuffer(i,0,a);let u=ke(r,`mul_scalar_inplace:${n}`,`
struct Params {
  scalar: f32,
  size: u32,
};

@group(0) @binding(0) var<storage, read_write> data: array<f32>;
@group(0) @binding(1) var<uniform> params: Params;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= params.size) {
    return;
  }
  data[idx] = data[idx] * params.scalar;
}
`),l=r.device.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s.buffer}},{binding:1,resource:{buffer:i}}]}),d=r.device.createCommandEncoder(),c=d.beginComputePass();c.setPipeline(u),c.setBindGroup(0,l),c.dispatchWorkgroups(Math.ceil(n/256)),c.end(),r.queue.submit([d.finish()]),i.destroy()}const ih={name:"webgpu",waitForGPU:ki,ops:{tensorFromArray:mc,add:gc,sub:wc,div:yc,mul:bc,matmul:Fc,sqrt:vc,relu:_c,exp:kc,log:Sc,neg:xc,abs:Ac,tanh:Ec,sigmoid:Ic,gelu:$c,silu:zc,isfinite:Cc,expand:Dc,reshape:Mc,transpose:Rc,permute:Pc,contiguous:bi,cast:Bc,gather:Lc,scatterAdd:Nc,sum:vi,max:qc,mean:Gc,argmax:Kc,argmin:Yc,gt:Uc,lt:Oc,ge:Vc,le:jc,eq:Wc,ne:Hc,where:Xc,stridedScatterCopy:eh,stridedScatterAdd:rh,read:sh},mulScalarInPlace:nh};function Js(e){if(e.length===0)return[];let t=Array(e.length),r=1;for(let s=e.length-1;s>=0;s--)t[s]=r,r*=e[s];return t}var Si=class{defaultDevice=null;memoryPlanningEnabled=!1;donationEnabled=!0;trackStats=!1;lastStats=null;fusionEnabled=!1;vectorizationEnabled=!0;lastFusionStats=null;constructor(e,t){e&&(this.defaultDevice=e),t?.enableMemoryPlanning&&(this.memoryPlanningEnabled=!0),t?.enableDonation!==void 0&&(this.donationEnabled=t.enableDonation),t?.trackStats&&(this.trackStats=!0),t?.enableFusion!==void 0&&(this.fusionEnabled=t.enableFusion),t?.enableVectorization!==void 0&&(this.vectorizationEnabled=t.enableVectorization)}setMemoryPlanning(e){this.memoryPlanningEnabled=e}isMemoryPlanningEnabled(){return this.memoryPlanningEnabled}getLastMemoryStats(){return this.lastStats}getMemoryPlannerStats(){return Md()}setFusionEnabled(e){this.fusionEnabled=e}isFusionEnabled(){return this.fusionEnabled}setVectorizationEnabled(e){this.vectorizationEnabled=e}isVectorizationEnabled(){return this.vectorizationEnabled}getLastFusionStats(){return this.lastFusionStats}setBackend(e){let t=We(e);if(!t)throw Error(`Unknown backend: ${e}`);return this.defaultDevice=e,t}get currentDefaultDevice(){return this.defaultDevice??Er().name}getBackend(e){let t=e??this.defaultDevice??Er().name,r=We(t);if(!r)throw Error(`Unknown backend: ${t}`);return r}getDevice(e){return e??this.defaultDevice??Er().name}assertSameDevice(...e){let t=e[0]?.device;if(!t)throw Error("Missing tensor device");for(let r of e)if(r.device!==t)throw Error("Tensors must be on the same device");return t}ensureSameDevice(...e){if(e.length===0)return{tensors:[],device:this.getDevice()};let t=e[0].device;for(let s of e)if(s.device==="webgpu"){t="webgpu";break}let r=[];for(let s of e)s.device===t?r.push(s):r.push(this.transfer(s,t));return{tensors:r,device:t}}async force(e){if(e.isMaterialized())return;let t=e.lazyRef;if(t.kind!=="pending")return;let r=od(t.node),s=this.getBackend(e.device),n;if(this.memoryPlanningEnabled){let i=await Bd(r,s,{enableDonation:this.donationEnabled,trackStats:this.trackStats});n=i.result,this.lastStats=i.stats}else if(this.fusionEnabled){let i=await dd(r,s,{enableFusion:!0,enableVectorization:this.vectorizationEnabled});n=i.result,this.lastFusionStats=i.stats}else n=await ui(r,s);for(let i of r.nodes)i.result&&md(i.id,i.result);e.isMaterialized()||e._materialize(n)}async forceAll(...e){let t=[],r=new Map;for(let s of e){if(s.isMaterialized())continue;let n=s.lazyRef;n.kind==="pending"&&(t.push(n.node),r.set(s,n.node))}if(t.length!==0)for(let s of e)await this.force(s)}async forceAllPending(){let{getAllPendingTensors:e}=await Ft(async()=>{const{getAllPendingTensors:r}=await Promise.resolve().then(()=>Kp);return{getAllPendingTensors:r}},void 0,import.meta.url),t=e();if(t.length!==0)for(let r of t)await this.force(r)}tensorFromArray(e,t,r){let s=this.getDevice(r),n=J(ee("tensorFromArray",[],t,"f32",s,{values:e.slice()}));return new re(ae(),n,t,s)}add(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("add",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}sub(e,t,r){let s=this.assertSameDevice(e,t),n=Be(e.shape,t.shape),i=ee("sub",[e.lazyRef,t.lazyRef],n,"f32",s,r);return new re(ae(),J(i),n,s)}div(e,t,r){let s=this.assertSameDevice(e,t),n=Be(e.shape,t.shape),i=ee("div",[e.lazyRef,t.lazyRef],n,"f32",s,r);return new re(ae(),J(i),n,s)}mul(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("mul",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}view(e,t){let r=ee("reshape",[e.lazyRef],t,"f32",e.device,{targetShape:t});return new re(e.baseId,J(r),t,e.device)}reshape(e,t){let r=ee("reshape",[e.lazyRef],t,"f32",e.device,{targetShape:t});return new re(e.baseId,J(r),t,e.device)}matmul(e,t){let r=this.assertSameDevice(e,t),s=ah(e.shape,t.shape),n=ee("matmul",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}sqrt(e){let t=ee("sqrt",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}relu(e){let t=ee("relu",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}exp(e){let t=ee("exp",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}log(e){let t=ee("log",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}neg(e){let t=ee("neg",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}abs(e){let t=ee("abs",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}tanh(e){let t=ee("tanh",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}sigmoid(e){let t=ee("sigmoid",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}gelu(e,t){let r=ee("gelu",[e.lazyRef],e.shape.slice(),"f32",e.device,t);return new re(ae(),J(r),e.shape.slice(),e.device)}silu(e){let t=ee("silu",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}isfinite(e){let t=ee("isfinite",[e.lazyRef],e.shape.slice(),"f32",e.device);return new re(ae(),J(t),e.shape.slice(),e.device)}expand(e,t){let r=ee("expand",[e.lazyRef],t,"f32",e.device,{targetShape:t});return new re(e.baseId,J(r),t,e.device)}transpose(e,t){let r=oh(e.shape,t),s=ee("transpose",[e.lazyRef],r,"f32",e.device,t);return new re(e.baseId,J(s),r,e.device)}permute(e,t){let r=e.shape.length;if(t.length!==r)throw Error(`permute: dims length ${t.length} doesn't match tensor rank ${r}`);let s=new Set;for(let o of t){let u=o<0?o+r:o;if(u<0||u>=r)throw Error(`permute: dimension ${o} out of range for rank ${r}`);if(s.has(u))throw Error(`permute: duplicate dimension ${o}`);s.add(u)}let n=t.map(o=>o<0?o+r:o),i=n.map(o=>e.shape[o]),a=ee("permute",[e.lazyRef],i,"f32",e.device,{dims:n});return new re(e.baseId,J(a),i,e.device)}contiguous(e){let t=ee("contiguous",[e.lazyRef],e.shape,"f32",e.device,void 0);return new re(ae(),J(t),e.shape,e.device)}cast(e,t){let r=ee("cast",[e.lazyRef],e.shape,t,e.device,{dtype:t});return new re(ae(),J(r),e.shape,e.device)}gather(e,t,r){let s=this.assertSameDevice(e,t),n=t.shape.slice(),i=ee("gather",[e.lazyRef,t.lazyRef],n,"f32",s,r);return new re(ae(),J(i),n,s)}scatterAdd(e,t,r,s){let n=this.assertSameDevice(e,t,r),i=e.shape.slice(),a=ee("scatterAdd",[e.lazyRef,t.lazyRef,r.lazyRef],i,"f32",n,s);return new re(ae(),J(a),i,n)}sum(e,t){let r=Tr(e.shape,t?.dim,t?.keepdim??!1),s=ee("sum",[e.lazyRef],r,"f32",e.device,t);return new re(ae(),J(s),r,e.device)}max(e,t){let r=Tr(e.shape,t?.dim,t?.keepdim??!1),s=ee("max",[e.lazyRef],r,"f32",e.device,t);return new re(ae(),J(s),r,e.device)}mean(e,t){let r=Tr(e.shape,t?.dim,t?.keepdim??!1),s=ee("mean",[e.lazyRef],r,"f32",e.device,t);return new re(ae(),J(s),r,e.device)}argmax(e,t){let r=t.dim<0?e.shape.length+t.dim:t.dim,s=t.keepdim?e.shape.map((i,a)=>a===r?1:i):e.shape.filter((i,a)=>a!==r),n=ee("argmax",[e.lazyRef],s,"f32",e.device,{dim:r,keepdim:t.keepdim});return new re(ae(),J(n),s,e.device)}argmin(e,t){let r=t.dim<0?e.shape.length+t.dim:t.dim,s=t.keepdim?e.shape.map((i,a)=>a===r?1:i):e.shape.filter((i,a)=>a!==r),n=ee("argmin",[e.lazyRef],s,"f32",e.device,{dim:r,keepdim:t.keepdim});return new re(ae(),J(n),s,e.device)}gt(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("gt",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}lt(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("lt",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}ge(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("ge",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}le(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("le",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}eq(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("eq",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}ne(e,t){let r=this.assertSameDevice(e,t),s=Be(e.shape,t.shape),n=ee("ne",[e.lazyRef,t.lazyRef],s,"f32",r);return new re(ae(),J(n),s,r)}where(e,t,r){let s=this.assertSameDevice(e,t,r),n=uh(e.shape,t.shape,r.shape),i=ee("where",[e.lazyRef,t.lazyRef,r.lazyRef],n,"f32",s);return new re(ae(),J(i),n,s)}async cpu(e){return await this.force(e),this.getBackend(e.device).ops.read(e.backendTensor)}async item(e){let t=await this.cpu(e);if(t.length!==1)throw Error("item() requires a single-element tensor");return t[0]}transfer(e,t){if(e.device===t)return e;let r=ee("transfer",[e.lazyRef],e.shape.slice(),"f32",t,{sourceDevice:e.device});return new re(ae(),J(r),e.shape.slice(),t)}async transferNow(e,t){if(e.device===t)return e;let r=this.transfer(e,t);return await this.force(r),r}copy_(e,t){if(this.assertSameDevice(e,t),e.shape.length!==t.shape.length)throw Error(`copy_: shape mismatch - dst has rank ${e.shape.length}, src has rank ${t.shape.length}`);for(let i=0;i<e.shape.length;i++)if(e.shape[i]!==t.shape[i])throw Error(`copy_: shape mismatch at dim ${i} - dst has ${e.shape[i]}, src has ${t.shape[i]}`);let r=Js(e.shape),s={offset:0,viewShape:e.shape.slice(),viewStrides:r},n=ee("stridedScatterCopy",[e.lazyRef,t.lazyRef],e.shape,"f32",e.device,s);return e._updateLazyRef(J(n)),e}add_(e,t){if(this.assertSameDevice(e,t),e.shape.length!==t.shape.length)throw Error(`add_: shape mismatch - dst has rank ${e.shape.length}, src has rank ${t.shape.length}`);for(let i=0;i<e.shape.length;i++)if(e.shape[i]!==t.shape[i])throw Error(`add_: shape mismatch at dim ${i} - dst has ${e.shape[i]}, src has ${t.shape[i]}`);let r=Js(e.shape),s={offset:0,viewShape:e.shape.slice(),viewStrides:r},n=ee("stridedScatterAdd",[e.lazyRef,t.lazyRef],e.shape,"f32",e.device,s);return e._updateLazyRef(J(n)),e}zero_(e){let t=e.shape.reduce((n,i)=>n*i,1),r=Array(t).fill(0),s=this.tensorFromArray(r,e.shape,e.device);return this.copy_(e,s)}fill_(e,t){let r=e.shape.reduce((i,a)=>i*a,1),s=Array(r).fill(t),n=this.tensorFromArray(s,e.shape,e.device);return this.copy_(e,n)}mul_(e,t){let r=this.mul(e,this.tensorFromArray([t],[],e.device));return this.copy_(e,r)}};new Si;function Be(e,t){let r=Math.max(e.length,t.length),s=Array(r);for(let n=0;n<r;n++){let i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw Error(`Cannot broadcast shapes [${e}] and [${t}]`);s[r-1-n]=Math.max(i,a)}return s}function ah(e,t){if(e.length<1||t.length<1)throw Error("matmul requires at least 1D tensors");if(e.length===1&&t.length===1)return[];if(e.length===1)return[...t.slice(0,-2),t[t.length-1]];if(t.length===1)return e.slice(0,-1);let r=e[e.length-2],s=t[t.length-1];return[...Be(e.slice(0,-2),t.slice(0,-2)),r,s]}function oh(e,t){let{dim0:r,dim1:s}=t,n=e.slice(),i=n[r];return n[r]=n[s],n[s]=i,n}function Tr(e,t,r){if(t==null)return r?e.map(()=>1):[];let s=(Array.isArray(t)?t:[t]).map(n=>n<0?e.length+n:n);return r?e.map((n,i)=>s.includes(i)?1:n):e.filter((n,i)=>!s.includes(i))}function uh(e,t,r){let s=Math.max(e.length,t.length,r.length),n=Array(s);for(let i=0;i<s;i++){let a=e[e.length-1-i]??1,o=t[t.length-1-i]??1,u=r[r.length-1-i]??1;if(a!==o&&a!==1&&o!==1||a!==u&&a!==1&&u!==1||o!==u&&o!==1&&u!==1)throw Error(`Cannot broadcast shapes [${e}], [${t}], and [${r}]`);n[s-1-i]=Math.max(a,o,u)}return n}function lh(e){let t=new Map;for(let s=0;s<e.nodes.length;s++)t.set(e.nodes[s].id,s);let r=[];for(let s of e.nodes){let n=s.inputs.map(u=>{let l=t.get(u);return l===void 0?`ext${u}`:`n${l}`}),i=s.shape?s.shape.join("x"):"?",a=s.dtype??"?",o=`${s.op}[${n.join(",")}](${i},${a})`;r.push(o)}for(let s of e.fusionGroups){let n=s.nodeIds.map(i=>t.get(i)??-1);r.push(`fuse:${s.kind}[${n.join(",")}]`)}return dh(r.join("|"))}function dh(e){let t=5381;for(let r=0;r<e.length;r++)t=t*33^e.charCodeAt(r);return(t>>>0).toString(16).padStart(8,"0")}function ch(e){let t=new Set(e.nodes.map(s=>s.id)),r=[];for(let s of e.nodes){let n=s.inputs.some(i=>!t.has(i));r.push({shape:s.shape?.slice()??[],dtype:s.dtype??"f32",isInput:n||s.inputs.length===0})}return r}function hh(e){return{irHash:lh(e),inputSignatures:ch(e)}}function Br(e){let t=e.inputSignatures.map(r=>`${r.shape.join("x")}:${r.dtype}:${r.isInput?"i":"c"}`);return`${e.irHash}|${t.join(";")}`}var ph=class{cache=new Map;maxSize;constructor(e=64){this.maxSize=e}get(e){let t=Br(e),r=this.cache.get(t);return r&&(r.hitCount++,this.cache.delete(t),this.cache.set(t,r)),r}set(e,t){let r=Br(e);for(;this.cache.size>=this.maxSize;){let n=this.cache.keys().next().value;n&&this.cache.delete(n)}let s={key:e,graph:t,createdAt:Date.now(),hitCount:0};return this.cache.set(r,s),s}has(e){return this.cache.has(Br(e))}get size(){return this.cache.size}clear(){this.cache.clear()}stats(){let e=Array.from(this.cache.entries()).map(([t,r])=>({key:t,hitCount:r.hitCount}));return{size:this.cache.size,entries:e}}};const xi=new Set(["matmul","linear","conv1d","conv2d","conv3d","bmm","addmm"]),Ai=new Set(["sum","mean","softmax","log_softmax","layer_norm","batch_norm","group_norm","exp","log","pow","loss","cross_entropy","mse_loss"]),Xr={enabled:!0,computeDtype:"f16",accumulateDtype:"f32",memoryDtype:"f32",reductionDtype:"f32"},Ei={enabled:!1,computeDtype:"f32",accumulateDtype:"f32",memoryDtype:"f32",reductionDtype:"f32"};function fh(){return{configStack:[],current:{enabled:!1,policy:Ei,deviceType:"cpu"}}}function en(e,t){let r={enabled:t.enabled??!0,policy:t.policy??Xr,deviceType:t.deviceType??e.current.deviceType};e.configStack.push(r),e.current=r}function tn(e){e.configStack.pop(),e.current=e.configStack.length>0?e.configStack[e.configStack.length-1]:{enabled:!1,policy:Ei,deviceType:"cpu"}}function mh(e,t,r){if(!r.current.enabled)return{outputDtype:t[0]??"f32",needsCast:!1,isGated:!1};let s=r.current.policy;if(Ai.has(e)){let a=t.some(o=>o==="f16");return{outputDtype:"f32",needsCast:a,sourceDtype:a?"f16":void 0,isGated:!0}}if(xi.has(e)){let a=t.some(o=>o==="f32");return{outputDtype:s.computeDtype,needsCast:a&&s.computeDtype==="f16",sourceDtype:a?"f32":void 0,isGated:!0}}let n=t.some(a=>a==="f16"),i=t.some(a=>a==="f32");return n&&i?{outputDtype:s.memoryDtype,needsCast:!0,sourceDtype:s.memoryDtype==="f32"?"f16":"f32",isGated:!0}:{outputDtype:t[0]??"f32",needsCast:!1,isGated:r.current.enabled}}function gh(e){return e.enabled?`${e.computeDtype}:${e.accumulateDtype}:${e.memoryDtype}`:"disabled"}function wh(e,t){if(!t.current.enabled)return{graph:e,castsInserted:0,nodeIdMap:new Map,modified:!1};let r=t.current.policy,s=[],n=new Map,i=Math.max(...e.nodes.map(l=>l.id))+1,a=0,o=new Map;for(let l of e.nodes)if(l.inputs.length>0){let d=yh(l,l.inputs.map(c=>e.nodes.find(h=>h.id===c)?.dtype??"f32"),r);d.length>0&&o.set(l.id,d)}let u=new Map;for(let l of e.nodes){let d=o.get(l.id);if(d)for(let m of d){let p={id:i++,op:"cast",epoch:l.epoch,kind:"lazy_op",inputs:[m.inputNodeId],shape:m.shape.slice(),dtype:m.toDtype};s.push(p),u.set(m.inputNodeId,p.id),a++}let c=l.inputs.map(m=>u.get(m)??m),h=c.map(m=>{let p=s.find(g=>g.id===m);return p?p.dtype??"f32":e.nodes.find(g=>g.id===m)?.dtype??"f32"}),f=mh(l.op,h,t),w={...l,inputs:c,dtype:f.outputDtype};s.push(w),n.set(l.id,w.id);for(let m of d??[])u.delete(m.inputNodeId)}return{graph:{...e,nodes:s},castsInserted:a,nodeIdMap:n,modified:a>0}}function yh(e,t,r){if(!r.enabled)return[];let s=[],n=e.op;if(xi.has(n)&&r.computeDtype==="f16"){for(let i=0;i<e.inputs.length;i++)if(t[i]==="f32"){let a=e.shape?.slice()??[];s.push({inputNodeId:e.inputs[i],fromDtype:"f32",toDtype:"f16",shape:a})}}if(Ai.has(n)){for(let i=0;i<e.inputs.length;i++)if(t[i]==="f16"){let a=e.shape?.slice()??[];s.push({inputNodeId:e.inputs[i],fromDtype:"f16",toDtype:"f32",shape:a})}}return s}const bh=new Set(["add","sub","mul","div","neg","abs","exp","log","relu","sqrt"]);function rn(e){return bh.has(e)}function vh(e,t){let r=Math.max(e.length,t.length),s=Array(r);for(let n=0;n<r;n+=1){let i=e[e.length-1-n]??1,a=t[t.length-1-n]??1;if(i!==a&&i!==1&&a!==1)throw Error("compile ir shape mismatch: not broadcastable");s[r-1-n]=Math.max(i,a)}return s}function _h(e,t){if(t.length===0)throw Error(`compile ir cannot infer shape for op ${e}`);let r=t[0].shape;if(!r)throw Error(`compile ir missing input shape for op ${e}`);if(t.length===1)return r.slice();let s=r.slice();for(let n=1;n<t.length;n+=1){let i=t[n].shape;if(!i)throw Error(`compile ir missing input shape for op ${e}`);s=vh(s,i)}return s}function kh(e,t){if(t.length===0)throw Error(`compile ir cannot infer dtype for op ${e}`);let r=t[0].dtype;if(!r)throw Error(`compile ir missing input dtype for op ${e}`);for(let s of t){if(!s.dtype)throw Error(`compile ir missing input dtype for op ${e}`);if(s.dtype!==r)throw Error(`compile ir dtype mismatch for op ${e}`)}return r}function Sh(e,t){let r=[],s=new Map;for(let a of e){if(a.type!=="lazy_op"||a.epoch!==t)continue;let o={id:a.traceId,op:a.op,epoch:a.epoch,kind:"lazy_op",inputs:a.inputs?a.inputs.slice():[],shape:a.shape?a.shape.slice():void 0,dtype:a.dtype};r.push(o),s.set(o.id,o)}for(let a of r){if(!rn(a.op)||a.inputs.length===0)continue;let o=a.inputs.map(u=>{let l=s.get(u);if(!l)throw Error(`compile ir missing input node ${u}`);return l});a.shape||=_h(a.op,o),a.dtype||=kh(a.op,o)}let n=[],i=[];for(let a of r){if(rn(a.op)){i.push(a.id);continue}i.length>1&&n.push({id:n.length,kind:"elementwise",nodeIds:i}),i=[]}return i.length>1&&n.push({id:n.length,kind:"elementwise",nodeIds:i}),{epoch:t,nodes:r,fusionGroups:n}}function xh(e,t){return e.graphInstanceId===t.graphInstanceId?e.callInstanceId===t.callInstanceId?e.planInstanceId===t.planInstanceId?e.opNonce===t.opNonce?e.drawNonce===t.drawNonce?e.mutId===t.mutId?e.kind<t.kind?-1:e.kind>t.kind?1:0:e.mutId-t.mutId:e.drawNonce-t.drawNonce:e.opNonce-t.opNonce:e.planInstanceId-t.planInstanceId:e.callInstanceId-t.callInstanceId:e.graphInstanceId-t.graphInstanceId}function Mr(e){let t=e.slice().sort((r,s)=>xh(r.key,s.key));return{orderedEvents:t,eventKeys:t.map(r=>r.key)}}function Ah(e){return e.subevents.map(t=>({name:t.kind,key:{graphInstanceId:e.graphInstanceId,callInstanceId:e.callInstanceId,planInstanceId:e.callInstanceId,opNonce:t.opNonce,drawNonce:t.drawNonce??0,mutId:t.mutId??0,kind:t.kind},payload:t.payload}))}function sn(e){let t=Array.from(new Set(e));return t.sort((r,s)=>r-s),t}function nn(e){return e.join(",")}var Eh=class{nextId=1;joinCache=new Map;root;constructor(){this.root=this.makeToken("root",[0],0),this.nextId=1}createEffectToken(){let e=this.nextId++;return this.makeToken("effect",[e],e)}createTokenOnlyToken(){let e=this.nextId++;return this.makeToken("token_only",[e],e)}createDebugToken(){return this.createEffectToken()}afterAll(e){if(e.length===0)throw Error("afterAll requires at least one token");let t=sn(e.flatMap(i=>i.roots)),r=nn(t);for(let i of e)if(i.key===r)return{token:i,roots:t};let s=this.joinCache.get(r);if(s)return{token:s,roots:t};let n=this.makeToken("join",t,this.nextId++);return this.joinCache.set(r,n),{token:n,roots:t}}makeToken(e,t,r){let s=sn(t);return{id:r,kind:e,roots:s,key:nn(s)}}},Ih=class{events=[];record(e){this.events.push(e)}snapshot(){return this.events.slice()}},Ii=class{id;baseId;origin;escapes=!1;disposed=!1;onDispose;constructor(e,t,r){this.id=e,this.baseId=t,this.origin=r}},$h=class{tokenStore;tokGlobal;tokLoc=new Map;locState=new Map;baseState=new Map;baseBindings=new Map;finalizeQueue=[];execLock={held:!1,ownerId:0,depth:0};nextOwnerId=1;poisoned=!1;recomputeMode=!1;stagingActive=!1;currentEpoch=0;currentStagingIds=new Set;traceTensorStatus=new Map;lastCompiledGraph=null;lastCacheKey=null;lastCacheHit=!1;compiledCache=new ph;nextTraceTensorId=1;nextSavedTensorId=1;backwardActive=!1;nextTensorId=1;nextBaseId=1;nextScopeId=1;nextMutIdValue=1;tidyScopes=[];basePinCount=new Map;rngBasis={algorithmId:0,seed:0};rngDrawNonce=0;rngCheckpointMode=null;rngCheckpointDraws=[];rngCheckpointIndex=0;nextCheckpointPackId=1;checkpointReachableBases=null;activeCheckpointPackId=null;autocastContext=null;trace;constructor(e=new Ih){this.trace=e,this.tokenStore=new Eh,this.tokGlobal=this.tokenStore.root}setAutocastContext(e){this.autocastContext=e}getAutocastContext(){return this.autocastContext}afterAll(...e){let{token:t,roots:r}=this.tokenStore.afterAll(e),s=Array.from(new Set(e.map(n=>n.id))).sort((n,i)=>n-i);return this.trace.record({type:"after_all",inputs:s,output:t.id,outputKey:r.join(",")}),t}orderedAccess(e,t="access",r=[]){this.ensureNotPoisoned();let s=this.tokLoc.get(e),n=this.afterAll(this.tokGlobal,s??this.tokGlobal,...r),i=this.tokenStore.createEffectToken();return this.trace.record({type:"effect",op:`ordered_${t}`,input:n.id,output:i.id,locId:e}),this.tokGlobal=i,this.tokLoc.set(e,i),this.trace.record({type:"set_token",target:"global",token:i.id}),this.trace.record({type:"set_token",target:"loc",locId:e,token:i.id}),i}emitEffect(e){return this.ensureNotPoisoned(),this.emitEffectFrom(this.tokGlobal,e)}_debug_publishSave(e){let t=this.emitEffect("publish_save");return this.trace.record({type:"publish_save"}),t}_debug_emitCompiledCall(e,t){this.trace.record({type:"compiled_call",graphInstanceId:e,callInstanceId:t})}_debug_setRngBasis(e){this.rngBasis={...e},this.rngDrawNonce=0,this.trace.record({type:"rng_basis",algorithmId:e.algorithmId,seed:e.seed})}_debug_getRngDrawNonce(){return this.rngDrawNonce}_debug_startCheckpointRecord(){if(this.rngCheckpointMode)throw Error("Checkpoint RNG already active");this.rngCheckpointMode="record",this.rngCheckpointDraws=[],this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_record_start"})}_debug_finishCheckpointRecord(){if(this.rngCheckpointMode!=="record")throw Error("Checkpoint RNG record not active");let e=this.rngCheckpointDraws.slice();return this.rngCheckpointMode=null,this.rngCheckpointDraws=[],this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_record_finish",count:e.length}),e}_debug_startCheckpointReplay(e){if(this.rngCheckpointMode)throw Error("Checkpoint RNG already active");this.rngCheckpointMode="replay",this.rngCheckpointDraws=e.slice(),this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_replay_start",count:e.length})}_debug_finishCheckpointReplay(){if(this.rngCheckpointMode!=="replay")throw Error("Checkpoint RNG replay not active");let e=this.rngCheckpointDraws.length;this.rngCheckpointMode=null,this.rngCheckpointDraws=[],this.rngCheckpointIndex=0,this.trace.record({type:"rng_checkpoint_replay_finish",count:e})}_debug_random(e,t){if(this.rngCheckpointMode==="replay"){let n=this.rngCheckpointDraws[this.rngCheckpointIndex];if(!n)throw new Ph("RNG replay exhausted");if(n.opNonce!==e)throw new on("RNG replay opNonce mismatch");if(t!==void 0&&t!==n.drawNonce)throw new on("RNG replay drawNonce mismatch");return this.rngCheckpointIndex+=1,this.trace.record({type:"rng_draw",opNonce:n.opNonce,drawNonce:n.drawNonce,value:n.value}),{drawNonce:n.drawNonce,value:n.value}}let r=t??this.nextRngDrawNonce();t!==void 0&&t>this.rngDrawNonce&&(this.rngDrawNonce=t);let s=Nh(this.rngBasis,e,r);return this.rngCheckpointMode==="record"&&this.rngCheckpointDraws.push({opNonce:e,drawNonce:r,value:s}),this.trace.record({type:"rng_draw",opNonce:e,drawNonce:r,value:s}),{drawNonce:r,value:s}}_debug_backward(e){if(this.backwardActive)throw new Mh("Backward is already running");this.backwardActive=!0,this.emitEffect("backward_root");try{return e()}finally{this.backwardActive=!1}}_debug_saveForBackward(e){let t=this.getOrCreateBaseState(e);return{id:this.nextSavedTensorId++,baseId:e,baseCommitVersionAtSave:t.baseCommitVersion}}_debug_useSavedTensor(e){if(this.getOrCreateBaseState(e.baseId).baseCommitVersion!==e.baseCommitVersionAtSave)throw new Bh(`Saved tensor modified for baseId ${e.baseId}`)}compile(e){return(...t)=>{if(this.stagingActive)throw Error("Compile already active");this.stagingActive=!0,this.currentEpoch+=1,this.currentStagingIds=new Set;let r;try{r=e(...t)}catch(s){throw this.finishStaging(void 0),s}if(Fh(r))throw this.finishStaging(void 0),new Ch("Async work is not allowed in compile");return this.finishStaging(r),r}}_debug_hostRead(){if(this.stagingActive)throw new zh("Host reads are forbidden during compile")}_debug_makeTraceTensor(e){if(!this.stagingActive)throw Error("Trace tensors may only be created during compile");let t={id:this.nextTraceTensorId++,epoch:this.currentEpoch,label:e};return this.currentStagingIds.add(t.id),this.traceTensorStatus.set(t.id,"staging"),t}_debug_emitLazyOp(e,t){let r=t?.inputs??[];for(let n of r){if(n.epoch!==this.currentEpoch)throw Error("Trace tensor belongs to a different epoch");this._debug_useTraceTensor(n)}let s=this._debug_makeTraceTensor(e);return this.trace.record({type:"lazy_op",op:e,traceId:s.id,epoch:s.epoch,inputs:r.length>0?r.map(n=>n.id):void 0,shape:t?.shape?t.shape.slice():void 0,dtype:t?.dtype}),s}_debug_getLastCompiledGraph(){return this.lastCompiledGraph}_debug_getLastCacheKey(){return this.lastCacheKey}_debug_wasLastCompileCacheHit(){return this.lastCacheHit}_debug_getCompiledCacheStats(){return this.compiledCache.stats()}_debug_clearCompiledCache(){this.compiledCache.clear()}_debug_useTraceTensor(e){let t=this.traceTensorStatus.get(e.id);if(!t)throw Error(`Unknown trace tensor ${e.id}`);if(t==="stale")throw new Th("Trace tensor is stale")}_debug_bindPendingLoc(e,t){this.getOrCreateLocState(t),this.baseBindings.set(e,{kind:"pending_loc",locId:t})}_debug_setLocRole(e,t){let r=this.getOrCreateLocState(e);r.role=t}_debug_setRecomputeMode(e){this.recomputeMode=e,e||(this.checkpointReachableBases=null)}_debug_ensureInitialized(e,t={}){let r=this.getBaseBinding(e);if(r.kind!=="pending_loc"||r.locId===void 0)throw Error("ensureInitialized requires a pending_loc binding");if(r.initTok)return r.initTok;if(this.recomputeMode)throw new Ot("Cannot initialize loc during recompute");this.getOrCreateLocState(r.locId);let s=t.subsumedByStore?this.tokenStore.createTokenOnlyToken():this.tokenStore.createEffectToken(),n=t.subsumedByStore?"init_loc_token_only":"init_loc_store";return this.trace.record({type:"effect",op:n,input:this.tokGlobal.id,output:s.id,locId:r.locId}),this.tokGlobal=s,this.trace.record({type:"set_token",target:"global",token:s.id}),r.initTok=s,s}_debug_orderedAccessBase(e,t){let r=this.getBaseBinding(e);if(r.kind==="pending_loc"&&r.locId!==void 0){let s=this._debug_ensureInitialized(e);return this.orderedAccess(r.locId,t,[s])}if(r.kind==="loc"&&r.locId!==void 0)return this.orderedAccess(r.locId,t);throw Error("orderedAccessBase requires a loc-backed binding")}_debug_recomputeLocStore(e){let t=this.getOrCreateLocState(e);if(this.recomputeMode&&t.role==="persistent")throw new Ot("Cannot store to persistent loc during recompute");this._debug_commitLocStore(e)}_debug_writeSavedState(){if(this.recomputeMode)throw new Ot("Cannot create saved_state during recompute")}_debug_recomputeMutateBase(e,t){if(this.recomputeMode&&this.checkpointReachableBases?.has(e))throw new Ot(`Cannot mutate base ${e} during recompute`);this._debug_baseCommit(e,t)}_debug_checkpointPack(e){let t=Array.from(new Set(e)).sort((s,n)=>s-n),r={id:this.nextCheckpointPackId++,reachableBases:t};return this.trace.record({type:"checkpoint_pack",packId:r.id,reachableBases:r.reachableBases.slice()}),r}_debug_startCheckpointRecompute(e){this.recomputeMode=!0,this.checkpointReachableBases=new Set(e.reachableBases),this.activeCheckpointPackId=e.id,this.trace.record({type:"checkpoint_recompute_start",packId:e.id,reachableBases:e.reachableBases.slice()})}_debug_finishCheckpointRecompute(){this.recomputeMode=!1,this.checkpointReachableBases=null,this.trace.record({type:"checkpoint_recompute_finish",packId:this.activeCheckpointPackId}),this.activeCheckpointPackId=null}_debug_enqueueFinalize(e){this.finalizeQueue.push(e),this.trace.record({type:"finalize_enqueue",recordId:e.id})}_debug_drainFinalizeQueueCleanupOnly(){let e=this.finalizeQueue.splice(0);return this.trace.record({type:"finalize_drain",count:e.length}),e}createTensor(e){let t=e??this.nextBaseId++;t>=this.nextBaseId&&(this.nextBaseId=t+1);let r=this.tidyScopes.length>0?{kind:"tidy",scopeId:this.tidyScopes[this.tidyScopes.length-1].id}:{kind:"global"},s=new Ii(this.nextTensorId++,t,r);return this.registerTensor(s),s}forceRead(e){this._debug_hostRead(),this.finalizePendingLocBindings();let t=this.collectForcePlanTokens(e),r=Array.from(new Set(t.map(n=>n.id))).sort((n,i)=>n-i);this.trace.record({type:"force_plan",baseId:e,tokenIds:r});let s=this.afterAll(t);this.emitEffectFrom(s,`host_read:${e}`)}tidy(e){let t={id:this.nextScopeId++,tensors:new Set};this.tidyScopes.push(t);let r,s=!1;try{r=e(),s=!0}finally{let n=s?Rh(r):[];for(let a of n)a.escapes=!0;let i=Array.from(t.tensors);for(let a of i)a.escapes||this.dispose(a);this.tidyScopes.pop()}return r}keep(e){e.disposed||(e.escapes=!0)}dispose(e){if(e.disposed)return;e.disposed=!0,e.onDispose&&e.onDispose();let t=this.basePinCount.get(e.baseId)??0;t<=1?this.basePinCount.delete(e.baseId):this.basePinCount.set(e.baseId,t-1);for(let r of this.tidyScopes)r.tensors.delete(e)}async markStep(){this._debug_runEntryPoint(()=>{this.trace.record({type:"mark_step_begin"}),this.emitEffect("mark_step");let e=this.finalizePendingLocBindings();this.trace.record({type:"mark_step_finalize_bindings",count:e}),this.trace.record({type:"mark_step_retain"}),this.trace.record({type:"mark_step_gc"}),this._debug_drainFinalizeQueueCleanupOnly(),this.tokGlobal=this.tokenStore.root,this.tokLoc.clear(),this.trace.record({type:"set_token",target:"global",token:this.tokGlobal.id}),this.trace.record({type:"mark_step_end"})})}_debug_runEntryPoint(e){if(this.execLock.held)throw new an("Engine is busy");let t=this.nextOwnerId++;this.execLock.held=!0,this.execLock.ownerId=t,this.execLock.depth=1,this._debug_drainFinalizeQueueCleanupOnly();try{return this.ensureNotPoisoned(),e()}finally{this._debug_drainFinalizeQueueCleanupOnly(),this.execLock.held=!1,this.execLock.ownerId=0,this.execLock.depth=0}}async runEntryPoint(e){if(this.execLock.held)throw new an("Engine is busy");let t=this.nextOwnerId++;this.execLock.held=!0,this.execLock.ownerId=t,this.execLock.depth=1,this._debug_drainFinalizeQueueCleanupOnly();try{return this.ensureNotPoisoned(),await e()}finally{this._debug_drainFinalizeQueueCleanupOnly(),this.execLock.held=!1,this.execLock.ownerId=0,this.execLock.depth=0}}_debug_poison(){this.poisoned=!0}_debug_getBasePinCount(e){return this.basePinCount.get(e)??0}_debugSnapshot(){let e=Array.from(this.tokLoc.entries()).sort(([u],[l])=>u-l),t={};for(let[u,l]of e)t[u.toString()]=this.snapshotToken(l);let r=Array.from(this.locState.entries()).sort(([u],[l])=>u-l),s={};for(let[u,l]of r)s[u.toString()]={locLogicalVersion:l.locLogicalVersion,locVersion:l.locVersion,role:l.role,hasValue:l.hasValue};let n=Array.from(this.baseState.entries()).sort(([u],[l])=>u-l),i={};for(let[u,l]of n)i[u.toString()]={baseCommitVersion:l.baseCommitVersion,committedMutations:Array.from(l.committed).sort((d,c)=>d-c)};let a=Array.from(this.baseBindings.entries()).sort(([u],[l])=>u-l),o={};for(let[u,l]of a)o[u.toString()]={kind:l.kind,locId:l.locId,initTokId:l.initTok?.id,initTokKind:l.initTok?.kind};return{tokGlobal:this.snapshotToken(this.tokGlobal),tokLoc:t,locs:s,bases:i,bindings:o}}_debugCreateToken(){return this.tokenStore.createDebugToken()}_debug_buildPlan(e){return{rootTokenIds:e.map(t=>t.id)}}_debug_buildPlanLinearOrder(e){return Mr(e)}_debug_buildPlanFromTrace(e=this.trace.snapshot()){let t=0,r=[];for(let s of e)s.type==="rng_basis"&&(t+=1,r.push({name:"rng_basis",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"rng_basis"},payload:{algorithmId:s.algorithmId,seed:s.seed}})),(s.type==="rng_checkpoint_record_start"||s.type==="rng_checkpoint_record_finish"||s.type==="rng_checkpoint_replay_start"||s.type==="rng_checkpoint_replay_finish")&&(t+=1,r.push({name:s.type,key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:s.type}})),s.type==="publish_save"&&(t+=1,r.push({name:"publish_save",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"publish_save"}})),s.type==="rng_draw"&&(t=Math.max(t,s.opNonce),r.push({name:"rng_draw",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:s.opNonce,drawNonce:s.drawNonce,mutId:0,kind:"rng_draw"},payload:{drawNonce:s.drawNonce,opNonce:s.opNonce}})),s.type==="loc_schedule"&&(t+=1,r.push({name:"loc_schedule",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"loc_schedule"},payload:{locId:s.locId}})),s.type==="loc_commit"&&(t+=1,r.push({name:"loc_commit",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:0,kind:"loc_commit"},payload:{locId:s.locId}})),s.type==="base_commit"&&(t+=1,r.push({name:"base_commit",key:{graphInstanceId:0,callInstanceId:0,planInstanceId:0,opNonce:t,drawNonce:0,mutId:s.mutId,kind:"base_commit"},payload:{baseId:s.baseId,mutId:s.mutId}}));return Mr(r)}_debug_buildPlanFromSchedules(e,t=this.trace.snapshot()){let r=this._debug_buildPlanFromTrace(t),s=e.flatMap(n=>Ah(n));return Mr([...r.orderedEvents,...s])}_debug_buildPlanWithCompiledCalls(e,t=this.trace.snapshot()){let r=[];for(let s of t)if(s.type==="compiled_call"){let n=e[s.callInstanceId];if(!n)throw Error(`Missing schedule for compiled call ${s.callInstanceId}`);r.push(n)}return this._debug_buildPlanFromSchedules(r,t)}_debug_simulateCommitPlan(e){let t={},r={},s={},n={},i=0;for(let a of e.orderedEvents){if(a.key.kind==="loc_schedule"){let o=a.payload?.locId;if(o!==void 0){let u=o.toString();t[u]=(t[u]??0)+1}}if(a.key.kind==="loc_commit"){let o=a.payload?.locId;if(o!==void 0){let u=o.toString();r[u]=(r[u]??0)+1}}if(a.key.kind==="base_commit"){let o=a.payload?.baseId;if(o!==void 0){let u=o.toString();s[u]=(s[u]??0)+1;let l=a.payload?.mutId??a.key.mutId;n[u]||(n[u]=[]),n[u].push(l)}}a.key.kind==="publish_save"&&(i+=1)}return{locLogicalVersions:t,locVersions:r,baseCommitVersions:s,baseCommittedMutations:n,publishSaveCount:i}}_debug_scheduleLocAccess(e){let t=this.getOrCreateLocState(e);return t.locLogicalVersion+=1,this.trace.record({type:"loc_schedule",locId:e,locLogicalVersion:t.locLogicalVersion}),{...t}}_debug_commitLocStore(e){let t=this.getOrCreateLocState(e);return t.locVersion+=1,t.hasValue=!0,this.trace.record({type:"loc_commit",locId:e,locVersion:t.locVersion}),{...t}}nextMutId(){return this.nextMutIdValue++}_debug_baseCommit(e,t){let r=this.getOrCreateBaseState(e);if(r.committed.has(t))throw Error(`base_commit already recorded for mutId ${t}`);return r.committed.add(t),r.baseCommitVersion+=1,this.trace.record({type:"base_commit",baseId:e,mutId:t,baseCommitVersion:r.baseCommitVersion}),{baseCommitVersion:r.baseCommitVersion,committedMutations:Array.from(r.committed).sort((s,n)=>s-n)}}_debug_simulateCommit(e){let t=this._debugSnapshot(),r={};for(let[s,n]of Object.entries(t.tokLoc))r[s]=n.id;return{tokGlobalId:t.tokGlobal.id,tokLocIds:r}}snapshotToken(e){return{id:e.id,key:e.key,kind:e.kind,roots:e.roots.slice()}}getOrCreateLocState(e){let t=this.locState.get(e);if(t)return t;let r={locLogicalVersion:0,locVersion:0,role:"ephemeral",hasValue:!1};return this.locState.set(e,r),r}getOrCreateBaseState(e){let t=this.baseState.get(e);if(t)return t;let r={baseCommitVersion:0,committed:new Set};return this.baseState.set(e,r),r}getBaseBinding(e){let t=this.baseBindings.get(e);if(!t)throw Error(`No binding for baseId ${e}`);return t}ensureNotPoisoned(){if(this.poisoned)throw new Dh("Engine is poisoned")}nextRngDrawNonce(){return this.rngDrawNonce+=1,this.rngDrawNonce}finishStaging(e){let t=new Set($i(e));for(let n of this.currentStagingIds)t.has(n)?this.traceTensorStatus.set(n,"live"):this.traceTensorStatus.set(n,"stale");let r=Sh(this.trace.snapshot(),this.currentEpoch),s="disabled";if(this.autocastContext?.current.enabled){let n=wh(r,this.autocastContext);n.modified&&(r=n.graph),s=gh(this.autocastContext.current.policy)}if(r.nodes.length>0){let n=hh(r),i={...n,irHash:`${n.irHash}:amp=${s}`},a=this.compiledCache.get(i);a?(this.lastCacheHit=!0,this.lastCacheKey=i,this.lastCompiledGraph=a.graph):(this.compiledCache.set(i,r),this.lastCacheHit=!1,this.lastCacheKey=i,this.lastCompiledGraph=r)}else this.lastCompiledGraph=null,this.lastCacheKey=null,this.lastCacheHit=!1;this.currentStagingIds.clear(),this.stagingActive=!1}registerTensor(e){let t=this.basePinCount.get(e.baseId)??0;this.basePinCount.set(e.baseId,t+1);for(let r of this.tidyScopes)r.tensors.add(e)}finalizePendingLocBindings(){let e=0;for(let[t,r]of this.baseBindings.entries()){if(r.kind!=="pending_loc"||r.locId===void 0)continue;let s=this.locState.get(r.locId);!s||!s.hasValue||(this.baseBindings.set(t,{kind:"loc",locId:r.locId}),e+=1)}return e}collectForcePlanTokens(e){let t=[],r=this.baseBindings.get(e);if(r&&(r.initTok&&t.push(r.initTok),(r.kind==="pending_loc"||r.kind==="loc")&&r.locId!==void 0)){let s=this.tokLoc.get(r.locId);s&&t.push(s)}return t.length===0&&t.push(this.tokGlobal),t}emitEffectFrom(e,t){let r=this.tokenStore.createEffectToken();return this.trace.record({type:"effect",op:t,input:e.id,output:r.id}),this.tokGlobal=r,this.trace.record({type:"set_token",target:"global",token:r.id}),r}},an=class extends Error{name="EngineBusyError"},Ot=class extends Error{name="CheckpointImpureRegionError"},zh=class extends Error{name="HostReadInCompileError"},Ch=class extends Error{name="AsyncInCompileError"},Th=class extends Error{name="InvalidTraceTensorEscapeError"},Bh=class extends Error{name="SavedTensorModifiedError"},Mh=class extends Error{name="NonReentrantBackwardError"},Dh=class extends Error{name="PoisonedEngineError"};function Rh(e){let t=[],r=new Set,s=n=>{if(n!=null){if(n instanceof Ii){t.push(n);return}if(typeof n=="object"&&!r.has(n)){if(r.add(n),Array.isArray(n)){for(let i of n)s(i);return}for(let i of Object.values(n))s(i)}}};return s(e),t}var Ph=class extends Error{name="RngReplayExhaustedError"},on=class extends Error{name="RngReplayMismatchError"};function Fh(e){return e?typeof e.then=="function":!1}function $i(e){return e?Array.isArray(e)?e.flatMap(t=>$i(t)):Lh(e)?[e.id]:[]:[]}function Lh(e){if(!e||typeof e!="object")return!1;let t=e;return typeof t.id=="number"&&typeof t.epoch=="number"}function Nh(e,t,r){let s=e.seed>>>0,n=e.algorithmId>>>0,i=t>>>0,a=r>>>0,o=s^Math.imul(n,2654435769)^i^Math.imul(a,2246822507);return o=qh(o),(o>>>0)/2**32}function qh(e){let t=e>>>0;return t^=t>>>16,t=Math.imul(t,2146121005),t^=t>>>15,t=Math.imul(t,2221713035),t^=t>>>16,t>>>0}var Gh=class extends Error{name="DisposedTensorError"},zi=class{engine;inner;engineTensor;requiresGradValue;gradNode=null;gradValue=null;constructor(e,t,r,s){this.engine=e,this.inner=t,this.engineTensor=r,this.requiresGradValue=s?.requiresGrad??!1,r.onDispose=()=>{t.dispose()}}get baseId(){return this.inner.baseId}get requiresGrad(){return this.requiresGradValue}get grad(){return this.gradValue}get shape(){return this.inner.shape.slice()}get device(){return this.inner.device}zeroGrad(){this.ensureNotDisposed(),this.gradValue&&this.gradValue.dispose(),this.gradValue=null}toArray(){return this.ensureNotDisposed(),this.inner.toArray()}async cpu(){return this.engine.cpu(this)}async item(){return this.engine.item(this)}backward(e){return this.engine.backward(this,e)}keep(){this.engine.keep(this)}dispose(){this.engine.dispose(this)}[Symbol.toPrimitive](){throw this.ensureNotDisposed(),Error("Tensor cannot be implicitly converted to a primitive")}valueOf(){throw this.ensureNotDisposed(),Error("Tensor cannot be implicitly converted to a primitive")}toString(){return this.ensureNotDisposed(),`Tensor(shape=[${this.shape.join(", ")}], device=${this.device}, baseId=${this.baseId})`}view(e){return this.engine.view(this,e)}reshape(e){return this.engine.reshape(this,e)}add(e){return this.engine.add(this,e)}sub(e,t){return this.engine.sub(this,e,t)}mul(e){return this.engine.mul(this,e)}div(e){return this.engine.div(this,e)}matmul(e){return this.engine.matmul(this,e)}sqrt(){return this.engine.sqrt(this)}relu(){return this.engine.relu(this)}exp(){return this.engine.exp(this)}log(){return this.engine.log(this)}neg(){return this.engine.neg(this)}abs(){return this.engine.abs(this)}tanh(){return this.engine.tanh(this)}sigmoid(){return this.engine.sigmoid(this)}gelu(e){return this.engine.gelu(this,e)}silu(){return this.engine.silu(this)}isfinite(){return this.engine.isfinite(this)}expand(e){return this.engine.expand(this,e)}transpose(e){return this.engine.transpose(this,e)}permute(e){return this.engine.permute(this,e)}contiguous(){return this.engine.contiguous(this)}toDtype(e){return this.engine.toDtype(this,e)}half(){return this.toDtype("f16")}float(){return this.toDtype("f32")}int(){return this.toDtype("i32")}to(e){return this.engine.to(this,e)}async toNow(e){return this.engine.toNow(this,e)}sum(e){return this.engine.sum(this,e)}max(e){return this.engine.max(this,e)}mean(e){return this.engine.mean(this,e)}argmax(e){return this.engine.argmax(this,e)}argmin(e){return this.engine.argmin(this,e)}gt(e){return this.engine.gt(this,e)}lt(e){return this.engine.lt(this,e)}ge(e){return this.engine.ge(this,e)}le(e){return this.engine.le(this,e)}eq(e){return this.engine.eq(this,e)}ne(e){return this.engine.ne(this,e)}softmax(e){return this.engine.softmax(this,e)}layernorm(e,t,r=1e-5){return this.engine.layernorm(this,e,t,r)}gather(e,t){return this.engine.gather(this,e,t)}scatterAdd(e,t,r){return this.engine.scatterAdd(this,e,t,r)}detach(){return this.engine.detach(this)}copy_(e){return this.engine.copy_(this,e)}add_(e){return this.engine.add_(this,e)}zero_(){return this.engine.zero_(this)}fill_(e){return this.engine.fill_(this,e)}mul_(e){return this.engine.mul_(this,e)}_unwrap(){return this.inner}_engine(){return this.engine}_engineTensor(){return this.engineTensor}_runtimeTensor(){return this.inner}_gradNode(){return this.gradNode}_setGradNode(e){this.gradNode=e}_setGrad(e){this.gradValue&&this.gradValue!==e&&this.gradValue.dispose(),this.gradValue=e}_ensureNotDisposed(){this.ensureNotDisposed()}ensureNotDisposed(){if(this.engineTensor.disposed)throw new Gh("Tensor has been disposed")}},Ci=class{engine;runtime;autocastContext;inCompileRegion=!1;memoryPlanningAvailable;savedTensorHooksStack=[];constructor(e,t){this.engine=new $h,t?.memoryLimitBytes!==void 0&&(zd(t.memoryLimitBytes),Hs(t.memoryLimitBytes)),this.memoryPlanningAvailable=t?.enableMemoryPlanning??!1,this.runtime=new Si(e,{enableFusion:t?.enableFusion??!1,enableMemoryPlanning:!1}),this.autocastContext=fh()}static getGPUMemoryLimit(){return bd()}static setGPUMemoryLimit(e){Hs(e)}static getGPUMemoryStats(){return vd()}setFusionEnabled(e){this.runtime.setFusionEnabled(e)}isFusionEnabled(){return this.runtime.isFusionEnabled()}compile(e){let t=this.engine.compile((...r)=>{});return(...r)=>{this.inCompileRegion=!0;let s=this.runtime.isFusionEnabled(),n=this.runtime.isMemoryPlanningEnabled();this.runtime.setFusionEnabled(!0),this.memoryPlanningAvailable&&this.runtime.setMemoryPlanning(!0);try{return t(),this.tidy(()=>e(...r))}finally{this.runtime.setFusionEnabled(s),this.runtime.setMemoryPlanning(n),this.inCompileRegion=!1}}}get isAutocastEnabled(){return this.autocastContext.current.enabled}get currentAutocastConfig(){return{...this.autocastContext.current}}setBackend(e){this.runtime.setBackend(e)}setDevice(e){this.runtime.setBackend(e)}autocast(e,t){let r=t?.deviceType??(this.runtime.currentDefaultDevice==="webgpu"?"webgpu":"cpu");en(this.autocastContext,{enabled:t?.enabled??!0,policy:t?.policy??Xr,deviceType:r}),this.engine.setAutocastContext(this.autocastContext);try{return e()}finally{tn(this.autocastContext),this.engine.setAutocastContext(this.autocastContext.configStack.length>0?this.autocastContext:null)}}async autocastAsync(e,t){let r=t?.deviceType??(this.runtime.currentDefaultDevice==="webgpu"?"webgpu":"cpu");en(this.autocastContext,{enabled:t?.enabled??!0,policy:t?.policy??Xr,deviceType:r}),this.engine.setAutocastContext(this.autocastContext);try{return await e()}finally{tn(this.autocastContext),this.engine.setAutocastContext(this.autocastContext.configStack.length>0?this.autocastContext:null)}}saved_tensors_hooks(e,t,r){this.savedTensorHooksStack.push({packHook:e,unpackHook:t});try{return r()}finally{this.savedTensorHooksStack.pop()}}_getSavedTensorHooks(){return this.savedTensorHooksStack.length>0?this.savedTensorHooksStack[this.savedTensorHooksStack.length-1]:null}_getAutocastContext(){return this.autocastContext}tensorFromArray(e,t,r){return this.wrap(this.runtime.tensorFromArray(e,t,r?.device),r?.requiresGrad??!1)}rand(e,t){let r=e.reduce((n,i)=>n*i,1),s=Array(r);for(let n=0;n<r;n++)s[n]=Math.random();return this.tensorFromArray(s,e,t)}randn(e,t){let r=e.reduce((n,i)=>n*i,1),s=Array(r);for(let n=0;n<r;n+=2){let i=Math.random(),a=Math.random(),o=Math.sqrt(-2*Math.log(i||1e-10)),u=2*Math.PI*a;s[n]=o*Math.cos(u),n+1<r&&(s[n+1]=o*Math.sin(u))}return this.tensorFromArray(s,e,t)}bernoulli(e,t=.5,r){if(t<0||t>1)throw Error(`Bernoulli probability must be between 0 and 1, got ${t}`);let s=e.reduce((i,a)=>i*a,1),n=Array(s);for(let i=0;i<s;i++)n[i]=Math.random()<t?1:0;return this.tensorFromArray(n,e,r)}zeros(e,t){let r=e.reduce((n,i)=>n*i,1),s=Array(r).fill(0);return this.tensorFromArray(s,e,t)}ones(e,t){let r=e.reduce((n,i)=>n*i,1),s=Array(r).fill(1);return this.tensorFromArray(s,e,t)}full(e,t,r){let s=e.reduce((i,a)=>i*a,1),n=Array(s).fill(t);return this.tensorFromArray(n,e,r)}add(e,t){this.assertUsable(e,t);let r=this.runtime.add(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape;return this.wrapWithGrad(r,[e,t],(i,a)=>[this.sumToShape(i,s),this.sumToShape(i,n)])}sub(e,t,r){this.assertUsable(e,t);let s=this.runtime.sub(e._unwrap(),t._unwrap(),r),n=e.shape,i=t.shape,a=e.device;return this.wrapWithGrad(s,[e,t],(o,u)=>{let l=r?.alpha??1,d=this.sumToShape(o,n),c=this.runtime.mul(o,this.runtime.tensorFromArray([-l],[],a));return[d,this.sumToShape(c,i)]})}mul(e,t){this.assertUsable(e,t);let r=this.runtime.mul(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape,i=e.requiresGrad||t.requiresGrad?[e,t]:[];return this.wrapWithGrad(r,[e,t],(a,o)=>{let u=o(0),l=o(1);return[this.sumToShape(this.runtime.mul(a,l._unwrap()),s),this.sumToShape(this.runtime.mul(a,u._unwrap()),n)]},i)}div(e,t){this.assertUsable(e,t);let r=this.runtime.div(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape,i=e.requiresGrad||t.requiresGrad?[e,t]:[];return this.wrapWithGrad(r,[e,t],(a,o)=>{let u=o(0),l=o(1),d=this.sumToShape(this.runtime.div(a,l._unwrap()),s),c=this.runtime.mul(l._unwrap(),l._unwrap()),h=this.runtime.neg(u._unwrap());return[d,this.sumToShape(this.runtime.mul(a,this.runtime.div(h,c)),n)]},i)}matmul(e,t){this.assertUsable(e,t);let r=this.runtime.matmul(e._unwrap(),t._unwrap()),s=e.shape,n=t.shape,i=e.requiresGrad||t.requiresGrad?[e,t]:[];return this.wrapWithGrad(r,[e,t],(a,o)=>{if(s.length<2||n.length<2)throw Error("matmul backward requires rank >= 2");let u=o(0),l=o(1),d=this.runtime.contiguous(this.runtime.transpose(u._unwrap(),{dim0:s.length-2,dim1:s.length-1})),c=this.runtime.contiguous(this.runtime.transpose(l._unwrap(),{dim0:n.length-2,dim1:n.length-1})),h=this.runtime.contiguous(a),f=this.runtime.matmul(h,c),w=this.runtime.matmul(d,h);return[this.sumToShape(f,s),this.sumToShape(w,n)]},i)}sqrt(e){this.assertUsable(e);let t=this.runtime.sqrt(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{let a=i(0),o=this.runtime.sqrt(a._unwrap()),u=this.runtime.tensorFromArray([1e-8],[],r),l=this.runtime.tensorFromArray([.5],[],r),d=this.runtime.add(o,u),c=this.runtime.div(l,d);return[this.runtime.mul(n,c)]},s)}relu(e){this.assertUsable(e);let t=this.runtime.relu(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{let a=i(0),o=this.runtime.tensorFromArray([0],[],r),u=this.runtime.gt(a._unwrap(),o);return[this.runtime.mul(n,u)]},s)}exp(e){this.assertUsable(e);let t=this.runtime.exp(e._unwrap()),r=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(s,n)=>{let i=n(0),a=this.runtime.exp(i._unwrap());return[this.runtime.mul(s,a)]},r)}log(e){this.assertUsable(e);let t=this.runtime.log(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{let a=i(0),o=this.runtime.tensorFromArray([1e-8],[],r),u=this.runtime.add(a._unwrap(),o);return[this.runtime.div(n,u)]},s)}neg(e){this.assertUsable(e);let t=this.runtime.neg(e._unwrap());return this.wrapWithGrad(t,[e],(r,s)=>[this.runtime.neg(r)])}abs(e){this.assertUsable(e);let t=this.runtime.abs(e._unwrap()),r=e.shape,s=e.device,n=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(i,a)=>{let o=a(0)._unwrap().toArray(),u=i.toArray().map((l,d)=>o[d]>=0?l:-l);return[this.runtime.tensorFromArray(u,r,s)]},n)}tanh(e){this.assertUsable(e);let t=this.runtime.tanh(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{let a=i(0),o=this.runtime.tanh(a._unwrap()),u=this.runtime.mul(o,o),l=this.runtime.tensorFromArray([1],[],r),d=this.runtime.sub(this.runtime.expand(l,u.shape),u);return[this.runtime.mul(d,n)]},s)}sigmoid(e){this.assertUsable(e);let t=this.runtime.sigmoid(e._unwrap()),r=e.device,s=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(n,i)=>{let a=i(0),o=this.runtime.sigmoid(a._unwrap()),u=this.runtime.tensorFromArray([1],[],r),l=this.runtime.sub(this.runtime.expand(u,o.shape),o),d=this.runtime.mul(o,l);return[this.runtime.mul(d,n)]},s)}gelu(e,t){this.assertUsable(e);let r=t?.approximate??"tanh",s=this.runtime.gelu(e._unwrap(),t),n=e.device,i=e.requiresGrad?[e]:[];return r==="tanh"?this.wrapWithGrad(s,[e],(a,o)=>{let u=o(0)._unwrap(),l=this.runtime.tensorFromArray([.7978845608],[],n),d=this.runtime.tensorFromArray([.5],[],n),c=this.runtime.tensorFromArray([1],[],n),h=this.runtime.tensorFromArray([.044715],[],n),f=this.runtime.tensorFromArray([.134145],[],n),w=this.runtime.mul(u,u),m=this.runtime.mul(w,u),p=this.runtime.add(u,this.runtime.mul(h,m)),g=this.runtime.mul(l,p),b=this.runtime.tanh(g),v=this.runtime.mul(d,this.runtime.add(c,b)),k=this.runtime.mul(b,b),y=this.runtime.sub(c,k),x=this.runtime.add(c,this.runtime.mul(f,w)),z=this.runtime.mul(this.runtime.mul(l,x),y),M=this.runtime.mul(this.runtime.mul(u,z),d),D=this.runtime.add(v,M);return[this.runtime.mul(a,D)]},i):this.wrapWithGrad(s,[e],(a,o)=>{let u=o(0)._unwrap(),l=this.runtime.tensorFromArray([.5],[],n),d=this.runtime.tensorFromArray([1],[],n),c=this.runtime.tensorFromArray([-.5],[],n),h=this.runtime.tensorFromArray([.7071067811865476],[],n),f=this.runtime.tensorFromArray([.3989422804014327],[],n),w=this.runtime.tensorFromArray([.3275911],[],n),m=this.runtime.tensorFromArray([.254829592],[],n),p=this.runtime.tensorFromArray([-.284496736],[],n),g=this.runtime.tensorFromArray([1.421413741],[],n),b=this.runtime.tensorFromArray([-1.453152027],[],n),v=this.runtime.tensorFromArray([1.061405429],[],n),k=this.runtime.mul(u,h),y=this.runtime.abs(k),x=this.runtime.div(d,this.runtime.add(d,this.runtime.mul(w,y))),z=this.runtime.mul(x,x),M=this.runtime.mul(z,x),D=this.runtime.mul(M,x),B=this.runtime.mul(D,x),R=this.runtime.add(this.runtime.mul(m,x),this.runtime.add(this.runtime.mul(p,z),this.runtime.add(this.runtime.mul(g,M),this.runtime.add(this.runtime.mul(b,D),this.runtime.mul(v,B)))));this.runtime.mul(k,k);let L=this.runtime.mul(c,this.runtime.mul(u,u)),q=this.runtime.exp(L),_=this.runtime.sub(d,this.runtime.mul(R,q)),T=this.runtime.tensorFromArray([0],[],n),$=this.runtime.ge(u,T),P=this.runtime.add(d,_),j=this.runtime.sub(d,_),A=this.runtime.where($,P,j),Q=this.runtime.mul(l,A),he=this.runtime.mul(q,f),pe=this.runtime.mul(u,he),we=this.runtime.add(Q,pe);return[this.runtime.mul(a,we)]},i)}silu(e){this.assertUsable(e);let t=this.runtime.silu(e._unwrap()),r=e.shape,s=e.device,n=e.requiresGrad?[e]:[];return this.wrapWithGrad(t,[e],(i,a)=>{let o=a(0)._unwrap().toArray(),u=i.toArray().map((l,d)=>{let c=o[d],h=1/(1+Math.exp(-c));return l*(h+c*h*(1-h))});return[this.runtime.tensorFromArray(u,r,s)]},n)}isfinite(e){this.assertUsable(e);let t=this.runtime.isfinite(e._unwrap());return this.wrap(t)}expand(e,t){this.assertUsable(e);let r=e.shape,s=this.runtime.expand(e._unwrap(),t);return this.wrapWithGrad(s,[e],(n,i)=>[this.sumToShape(n,r)])}sum(e,t){this.assertUsable(e);let r=this.runtime.sum(e._unwrap(),t);if(typeof r=="number"){if(e.requiresGrad)throw Error("sum with requiresGrad must specify dim");return r}let s=e.shape,n=s.length;return this.wrapWithGrad(r,[e],(i,a)=>{let o=this.normalizeDims(t?.dim??null,n),u=t?.keepdim??!1;return[this.expandGrad(i,s,o,u)]})}max(e,t){this.assertUsable(e);let r=this.runtime.max(e._unwrap(),t);return typeof r=="number"?r:this.wrap(r)}mean(e,t){this.assertUsable(e);let r=this.runtime.mean(e._unwrap(),t);if(typeof r=="number"){if(e.requiresGrad)throw Error("mean with requiresGrad must specify dim");return r}let s=e.shape,n=e.device,i=this.normalizeDims(t?.dim??null,s.length),a=t?.keepdim??!1,o=i.length===0?1:i.reduce((u,l)=>u*s[l],1);return this.wrapWithGrad(r,[e],(u,l)=>{let d=this.expandGrad(u,s,i,a);return[this.runtime.mul(d,this.runtime.tensorFromArray([1/o],[],n))]})}argmax(e,t){this.assertUsable(e);let r=this.runtime.argmax(e._unwrap(),t);return this.wrap(r)}argmin(e,t){this.assertUsable(e);let r=this.runtime.argmin(e._unwrap(),t);return this.wrap(r)}gt(e,t){this.assertUsable(e,t);let r=this.runtime.gt(e._unwrap(),t._unwrap());return this.wrap(r)}lt(e,t){this.assertUsable(e,t);let r=this.runtime.lt(e._unwrap(),t._unwrap());return this.wrap(r)}ge(e,t){this.assertUsable(e,t);let r=this.runtime.ge(e._unwrap(),t._unwrap());return this.wrap(r)}le(e,t){this.assertUsable(e,t);let r=this.runtime.le(e._unwrap(),t._unwrap());return this.wrap(r)}eq(e,t){this.assertUsable(e,t);let r=this.runtime.eq(e._unwrap(),t._unwrap());return this.wrap(r)}ne(e,t){this.assertUsable(e,t);let r=this.runtime.ne(e._unwrap(),t._unwrap());return this.wrap(r)}softmax(e,t){this.assertUsable(e);let r=e.shape.length,s=t<0?t+r:t;if(s<0||s>=r)throw Error(`softmax: dim ${t} out of range for tensor of rank ${r}`);let n=this.runtime.max(e._unwrap(),{dim:s,keepdim:!0});if(typeof n=="number")throw Error("softmax: max with keepdim=true should return tensor");let i=this.runtime.sub(e._unwrap(),n),a=this.runtime.exp(i),o=this.runtime.sum(a,{dim:s,keepdim:!0});if(typeof o=="number")throw Error("softmax: sum with keepdim=true should return tensor");let u=this.runtime.div(a,o),l=e.requiresGrad?[e]:[];return this.wrapWithGrad(u,[e],(d,c)=>{let h=c(0),f=this.runtime.max(h._unwrap(),{dim:s,keepdim:!0});if(typeof f=="number")throw Error("softmax backward: max with keepdim=true should return tensor");let w=this.runtime.sub(h._unwrap(),f),m=this.runtime.exp(w),p=this.runtime.sum(m,{dim:s,keepdim:!0});if(typeof p=="number")throw Error("softmax backward: sum with keepdim=true should return tensor");let g=this.runtime.div(m,p),b=this.runtime.mul(g,d),v=this.runtime.sum(b,{dim:s,keepdim:!0});if(typeof v=="number")throw Error("softmax backward: sum with keepdim=true should return tensor");let k=this.runtime.sub(d,v);return[this.runtime.mul(g,k)]},l)}layernorm(e,t,r,s=1e-5){this.assertUsable(e,t,r);let n=e.shape,i=e.device,a=n.length,o=-1+a,u=n[n.length-1],l=this.runtime.mean(e._unwrap(),{dim:o,keepdim:!0});if(typeof l=="number")throw Error("layernorm: mean with keepdim=true should return tensor");let d=this.runtime.sub(e._unwrap(),l),c=this.runtime.mul(d,d),h=this.runtime.mean(c,{dim:o,keepdim:!0});if(typeof h=="number")throw Error("layernorm: variance mean with keepdim=true should return tensor");let f=this.runtime.tensorFromArray([s],[],i),w=this.runtime.add(h,f),m=this.runtime.sqrt(w),p=this.runtime.div(d,m),g=this.runtime.mul(p,t._unwrap()),b=this.runtime.add(g,r._unwrap()),v=e.requiresGrad||t.requiresGrad||r.requiresGrad?[e,t,r]:[];return this.wrapWithGrad(b,[e,t,r],(k,y)=>{let x=y(0),z=y(1),M=this.runtime.mean(x._unwrap(),{dim:o,keepdim:!0});if(typeof M=="number")throw Error("layernorm backward: mean should return tensor");let D=this.runtime.sub(x._unwrap(),M),B=this.runtime.mul(D,D),R=this.runtime.mean(B,{dim:o,keepdim:!0});if(typeof R=="number")throw Error("layernorm backward: variance mean should return tensor");let L=this.runtime.tensorFromArray([s],[],i),q=this.runtime.add(R,L),_=this.runtime.sqrt(q),T=this.runtime.div(D,_),$=Array.from({length:a-1},(Fe,Se)=>Se),P=k;for(let Fe=$.length-1;Fe>=0;Fe--){let Se=this.runtime.sum(P,{dim:$[Fe],keepdim:!1});if(typeof Se=="number")throw Error("layernorm backward: sum for gradBias should return tensor");P=Se}let j=this.runtime.mul(k,T);for(let Fe=$.length-1;Fe>=0;Fe--){let Se=this.runtime.sum(j,{dim:$[Fe],keepdim:!1});if(typeof Se=="number")throw Error("layernorm backward: sum for gradWeight should return tensor");j=Se}let A=this.runtime.mul(k,z._unwrap()),Q=this.runtime.div(A,_),he=this.runtime.mul(A,D),pe=this.runtime.sum(he,{dim:o,keepdim:!0});if(typeof pe=="number")throw Error("layernorm backward: sum should return tensor");let we=this.runtime.tensorFromArray([-.5],[],i),Ee=this.runtime.mul(q,_),ge=this.runtime.mul(we,this.runtime.div(pe,Ee)),ve=this.runtime.tensorFromArray([2],[],i),_e=this.runtime.tensorFromArray([u],[],i),Ce=this.runtime.div(this.runtime.mul(this.runtime.mul(ve,ge),D),_e),Xe=this.runtime.add(Q,Ce),Je=this.runtime.sum(Xe,{dim:o,keepdim:!0});if(typeof Je=="number")throw Error("layernorm backward: sum should return tensor");let Nt=this.runtime.neg(this.runtime.div(Je,_e));return[this.runtime.add(Xe,Nt),j,P]},v)}async cpu(e){return this.assertUsable(e),this.runEntryPoint(async()=>(this.engine.forceRead(e.baseId),this.runtime.cpu(e._unwrap())))}async item(e){return this.assertUsable(e),this.runEntryPoint(async()=>(this.engine.forceRead(e.baseId),this.runtime.item(e._unwrap())))}to(e,t){if(this.assertUsable(e),e.device===t)return e;let r=this.runtime.transfer(e._unwrap(),t);return this.wrap(r,e.requiresGrad)}async toNow(e,t){return this.assertUsable(e),this.runEntryPoint(async()=>{this.engine.forceRead(e.baseId);let r=await this.runtime.transferNow(e._unwrap(),t);return this.wrap(r,e.requiresGrad)})}copy_(e,t){return this.assertUsable(e,t),this.runtime.copy_(e._unwrap(),t._unwrap()),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}add_(e,t){return this.assertUsable(e,t),this.runtime.add_(e._unwrap(),t._unwrap()),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}zero_(e){return this.assertUsable(e),this.runtime.zero_(e._unwrap()),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}fill_(e,t){return this.assertUsable(e),this.runtime.fill_(e._unwrap(),t),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}mul_(e,t){return this.assertUsable(e),this.runtime.mul_(e._unwrap(),t),this._debug_baseCommit(e.baseId,this.engine.nextMutId()),e}gather(e,t,r){this.assertUsable(e,t);let s=this.runtime.gather(e._unwrap(),t._unwrap(),r),n=e.shape,i=t._unwrap();return this.wrapWithGrad(s,[e],(a,o)=>{let u=this.runtime.tensorFromArray(Array(n.reduce((l,d)=>l*d,1)).fill(0),n);return[this.runtime.scatterAdd(u,i,a,r)]})}scatterAdd(e,t,r,s){this.assertUsable(e,t,r);let n=this.runtime.scatterAdd(e._unwrap(),t._unwrap(),r._unwrap(),s),i=t._unwrap();return this.wrapWithGrad(n,[e,r],(a,o)=>[a,this.runtime.gather(a,i,s)])}where(e,t,r){this.assertUsable(e,t,r);let s=this.runtime.where(e._unwrap(),t._unwrap(),r._unwrap()),n=t.shape,i=r.shape,a=e._unwrap();return this.wrapWithGrad(s,[t,r],(o,u)=>{let l=this.runtime.tensorFromArray(Array(o.shape.reduce((h,f)=>h*f,1)).fill(0),o.shape,o.device),d=this.runtime.where(a,o,l),c=this.runtime.where(a,l,o);return[this.sumToShape(d,n),this.sumToShape(c,i)]})}view(e,t){this.assertUsable(e);let r=e.shape,s=this.runtime.view(e._unwrap(),t);return this.wrapWithGrad(s,[e],(n,i)=>[this.runtime.reshape(this.runtime.contiguous(n),r)])}reshape(e,t){this.assertUsable(e);let r=e.shape,s=this.runtime.reshape(e._unwrap(),t);return this.wrapWithGrad(s,[e],(n,i)=>[this.runtime.reshape(this.runtime.contiguous(n),r)])}transpose(e,t){this.assertUsable(e);let r=this.runtime.transpose(e._unwrap(),t);return this.wrapWithGrad(r,[e],(s,n)=>[this.runtime.transpose(s,t)])}permute(e,t){this.assertUsable(e);let r=this.runtime.permute(e._unwrap(),t),s=Array(t.length);for(let n=0;n<t.length;n++)s[t[n]]=n;return this.wrapWithGrad(r,[e],(n,i)=>[this.runtime.permute(n,s)])}contiguous(e){this.assertUsable(e);let t=this.runtime.contiguous(e._unwrap());return this.wrapWithGrad(t,[e],(r,s)=>[r])}toDtype(e,t){this.assertUsable(e);let r=this.runtime.cast(e._unwrap(),t);return this.wrap(r)}detach(e){return this.assertUsable(e),this.wrap(e._unwrap())}async backward(e,t){if(this.assertUsable(e),t&&(this.assertUsable(t),!Dr(t.shape,e.shape)))throw Error("backward grad shape mismatch");return this.runEntryPoint(async()=>{let r=t?t._unwrap():this.seedGrad(e),s=new Map;s.set(e,r);let n=[],i=new Set,a=l=>{if(!i.has(l)){for(let d of l.inputs){let c=d._gradNode();c&&a(c)}i.add(l),n.push(l)}},o=e._gradNode();o&&a(o);let u=[r];for(let l of n)for(let d of l.inputs)u.push(d._unwrap());await this.runtime.forceAll(...u);for(let l=n.length-1;l>=0;--l){let d=n[l],c=s.get(d.output);if(!c)continue;await this.runtime.force(c);for(let w of d.savedSlots)this.engine._debug_useSavedTensor(w.record);let h=[];for(let w of d.savedSlots){let m=w.unpackHook(w.packed);h.push(m)}h.length>0&&await this.runtime.forceAll(...h.map(w=>w._unwrap()));let f=d.backward(c,w=>{if(w>=h.length)throw Error(`No saved tensor at index ${w}`);return h[w]});for(let w=0;w<d.inputs.length;w+=1){let m=d.inputs[w],p=f[w];if(!p||!m.requiresGrad)continue;let g=s.get(m);g?s.set(m,this.runtime.add(g,p)):s.set(m,p)}}for(let[l,d]of s)l.requiresGrad&&!l._gradNode()&&l._setGrad(this.wrap(d,!1))})}wrap(e,t=!1){let r=this.engine.createTensor(e.baseId);return new zi(this,e,r,{requiresGrad:t})}wrapWithGrad(e,t,r,s=[]){let n=t.some(a=>a.requiresGrad),i=this.wrap(e,n);if(n){let a=[],o=this._getSavedTensorHooks();for(let u of s)if(o){let l=o.packHook(u),d=this.engine._debug_saveForBackward(u.baseId);a.push({packed:l,unpackHook:o.unpackHook,record:d})}else{this.keep(u);let l=this.engine._debug_saveForBackward(u.baseId);a.push({packed:u,unpackHook:d=>d,record:l})}a.length>0&&this.engine._debug_publishSave(i.baseId),i._setGradNode({inputs:t,output:i,backward:r,savedSlots:a})}return i}seedGrad(e){if(Oh(e.shape)!==1)throw Error("backward requires an explicit grad for non-scalars");return this.runtime.tensorFromArray([1],[],e.device)}saveForBackward(e){return this.keep(e),this.engine._debug_saveForBackward(e.baseId)}sumToShape(e,t){if(Dr(e.shape,t))return e;let r=e.shape.length,s=t.length,n=Math.max(0,r-s),i=Array(n).fill(1).concat(t),a=[];for(let u=0;u<r;u+=1){let l=i[u],d=e.shape[u];l===1&&d!==1&&a.push(u)}let o=e;if(a.length>0){let u=this.runtime.sum(o,{dim:a,keepdim:!0});o=typeof u=="number"?this.runtime.tensorFromArray([u],[],e.device):u}return Dr(o.shape,t)||(o=this.runtime.reshape(o,t)),o}expandGrad(e,t,r,s){let n=e;if(!s&&r.length>0){let i=t.length,a=new Set(r),o=Array(i),u=0;for(let l=0;l<i;l+=1)a.has(l)?o[l]=1:(o[l]=e.shape[u],u+=1);n=this.runtime.reshape(n,o)}return this.runtime.expand(n,t)}normalizeDims(e,t){if(e==null)return Array.from({length:t},(n,i)=>i);let r=(Array.isArray(e)?e.slice():[e]).map(n=>n<0?t+n:n),s=new Set;for(let n of r){if(n<0||n>=t)throw Error(`dim out of range: ${n}`);s.has(n)||s.add(n)}return Array.from(s).sort((n,i)=>n-i)}tidy(e){let t;return this.engine.tidy(()=>(t=e(),Uh(t))),t}keep(e){this.assertUsable(e),this.engine.keep(e._engineTensor())}dispose(e){this.assertSameEngine(e),this.engine.dispose(e._engineTensor())}async markStep(){await this.engine.markStep(),await this.runtime.forceAllPending(),this.defaultDevice==="webgpu"&&await ki(),ct.destroyUnreachable()}_debug_baseCommit(e,t){this.engine._debug_baseCommit(e,t)}_runtime(){return this.runtime}_wrapRuntime(e,t){return this.wrap(e,t)}assertUsable(...e){this.assertSameEngine(...e),this.assertSameDevice(...e);for(let t of e)t._ensureNotDisposed()}assertSameEngine(...e){for(let t of e)if(t._engine()!==this)throw Error("Tensor belongs to a different Torchlette instance")}assertSameDevice(...e){if(e.length<=1)return;let t=e[0].device;for(let r of e)if(r.device!==t)throw Error("Tensors must be on the same device")}async runEntryPoint(e){return this.engine.runEntryPoint(e)}};new Ci;function Uh(e){let t=[],r=new Set,s=n=>{if(n!=null){if(n instanceof zi){t.push(n._engineTensor());return}if(typeof n=="object"&&!r.has(n)){if(r.add(n),Array.isArray(n)){for(let i of n)s(i);return}for(let i of Object.values(n))s(i)}}};return s(e),t}function Oh(e){return e.reduce((t,r)=>t*r,1)}function Dr(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r+=1)if(e[r]!==t[r])return!1;return!0}class Vh{api;inFeatures;outFeatures;rank;alpha;scaling;baseWeight;baseBias;loraA;loraB;constructor(t,r,s,n,i){this.api=t,this.inFeatures=r,this.outFeatures=s,this.rank=n.rank,this.alpha=n.alpha,this.scaling=n.alpha/n.rank;const a=i?.device??"webgpu";this.baseWeight=t.zeros([s,r],{device:a,requiresGrad:!1}),this.baseBias=t.zeros([s],{device:a,requiresGrad:!1});const o=Math.sqrt(1/r),u=new Float32Array(n.rank*r);for(let l=0;l<u.length;l++)u[l]=(Math.random()*2-1)*o*Math.sqrt(3);this.loraA=t.tensorFromArray(u,[n.rank,r],{device:a,requiresGrad:!0}),this.loraB=t.zeros([s,n.rank],{device:a,requiresGrad:!0})}loadBaseWeights(t,r){const s=this.api._runtime();s.copy_(this.baseWeight._unwrap(),t._unwrap()),r&&this.baseBias&&s.copy_(this.baseBias._unwrap(),r._unwrap())}forward(t){const r=this.api.matmul(t,this.baseWeight.transpose({dim0:0,dim1:1})),n=(this.baseBias?this.api.add(r,this.baseBias):r).detach(),i=this.api.matmul(this.api.matmul(t,this.loraA.transpose({dim0:0,dim1:1})),this.loraB.transpose({dim0:0,dim1:1})),a=this.api.tensorFromArray([this.scaling],[]),o=this.api.mul(i,a);return this.api.add(n,o)}getLoRAParameters(){return[this.loraA,this.loraB]}parameters(){const t=[this.baseWeight,this.loraA,this.loraB];return this.baseBias&&t.push(this.baseBias),t}}function jh(e=8,t){return{rank:e,alpha:t??e}}const Wh={vocabSize:50257,blockSize:1024,numLayers:12,numHeads:12,embedDim:768,dropoutRate:0};class Jr{api;weight;bias;eps;constructor(t,r,s="webgpu"){this.api=t,this.eps=1e-5,this.weight=t.ones([r],{device:s,requiresGrad:!1}),this.bias=t.zeros([r],{device:s,requiresGrad:!1})}forward(t){const r=t.shape,s=this.api.mean(t,{dim:-1}),n=[...r.slice(0,-1),1],i=s.reshape(n),a=this.api.sub(t,i),u=this.api.mean(this.api.mul(a,a),{dim:-1}).reshape(n),l=this.api.tensorFromArray([this.eps],[]),d=this.api.sqrt(this.api.add(u,l)),c=this.api.div(a,d);return this.api.add(this.api.mul(c,this.weight),this.bias)}loadWeights(t,r){const s=this.api._runtime();s.copy_(this.weight._unwrap(),t._unwrap()),s.copy_(this.bias._unwrap(),r._unwrap())}}class un{api;weight;embeddingDim;constructor(t,r,s,n="webgpu"){this.api=t,this.embeddingDim=s,this.weight=t.zeros([r,s],{device:n,requiresGrad:!1})}forward(t){const r=t.shape,s=r.reduce((u,l)=>u*l,1),i=t.reshape([s]).reshape([s,1]).expand([s,this.embeddingDim]).contiguous(),a=this.weight.gather(i,{dim:0}),o=[...r,this.embeddingDim];return a.reshape(o)}loadWeights(t){this.api._runtime().copy_(this.weight._unwrap(),t._unwrap())}}class es{api;weight;bias;constructor(t,r,s,n={}){this.api=t;const i=n.device??"webgpu";this.weight=t.zeros([s,r],{device:i,requiresGrad:!1}),this.bias=n.bias!==!1?t.zeros([s],{device:i,requiresGrad:!1}):null}forward(t){const r=this.api.matmul(t,this.weight.transpose({dim0:0,dim1:1}));return this.bias?this.api.add(r,this.bias):r}loadWeights(t,r){const s=this.api._runtime();s.copy_(this.weight._unwrap(),t._unwrap()),r&&this.bias&&s.copy_(this.bias._unwrap(),r._unwrap())}}class Hh{api;numHeads;embedDim;headDim;cAttn;cProj;constructor(t,r,s,n="webgpu"){this.api=t,this.numHeads=r.numHeads,this.embedDim=r.embedDim,this.headDim=r.embedDim/r.numHeads,this.cAttn=new Vh(t,r.embedDim,3*r.embedDim,s,{device:n}),this.cProj=new es(t,r.embedDim,r.embedDim,{device:n})}forward(t){const[r,s]=t.shape,l=this.cAttn.forward(t).reshape([r,s,3,this.numHeads,this.headDim]).permute([0,3,1,2,4]).reshape([r*this.numHeads,s,3*this.headDim]).reshape([r*this.numHeads,s,3,this.headDim]).permute([2,0,1,3]),d=this.api.tensorFromArray(Array(r*this.numHeads*s*this.headDim).fill(0),[r*this.numHeads,s,this.headDim]),c=this.api.tensorFromArray(Array(r*this.numHeads*s*this.headDim).fill(1),[r*this.numHeads,s,this.headDim]),h=this.api.tensorFromArray(Array(r*this.numHeads*s*this.headDim).fill(2),[r*this.numHeads,s,this.headDim]),f=this.api.gather(l,d,{dim:0}),w=this.api.gather(l,c,{dim:0}),m=this.api.gather(l,h,{dim:0}),p=w.transpose({dim0:1,dim1:2}),g=this.api.matmul(f,p),b=this.api.tensorFromArray([1/Math.sqrt(this.headDim)],[]),v=this.api.mul(g,b),k=this.createCausalMask(s),x=this.api.add(v,k).softmax(-1),B=this.api.matmul(x,m).reshape([r,this.numHeads,s,this.headDim]).permute([0,2,1,3]).reshape([r,s,this.embedDim]);return this.cProj.forward(B)}createCausalMask(t){const r=new Float32Array(t*t);for(let s=0;s<t;s++)for(let n=0;n<t;n++)r[s*t+n]=n>s?-1e9:0;return this.api.tensorFromArray(r,[t,t])}getLoRAParameters(){return this.cAttn.getLoRAParameters()}}class Kh{api;cFc;cProj;constructor(t,r,s="webgpu"){this.api=t,this.cFc=new es(t,r.embedDim,4*r.embedDim,{device:s}),this.cProj=new es(t,4*r.embedDim,r.embedDim,{device:s})}forward(t){let r=this.cFc.forward(t);return r=r.gelu(),this.cProj.forward(r)}}class Yh{api;ln1;attn;ln2;mlp;constructor(t,r,s,n="webgpu"){this.api=t,this.ln1=new Jr(t,r.embedDim,n),this.attn=new Hh(t,r,s,n),this.ln2=new Jr(t,r.embedDim,n),this.mlp=new Kh(t,r,n)}forward(t){const r=this.attn.forward(this.ln1.forward(t));let s=this.api.add(t,r);const n=this.mlp.forward(this.ln2.forward(s));return s=this.api.add(s,n),s}getLoRAParameters(){return this.attn.getLoRAParameters()}}class Qh{api;config;loraConfig;wte;wpe;h;lnF;training=!1;checkpointingEnabled=!1;constructor(t,r,s,n="webgpu"){this.api=t,this.config=r,this.loraConfig=s,this.wte=new un(t,r.vocabSize,r.embedDim,n),this.wpe=new un(t,r.blockSize,r.embedDim,n),this.h=[];for(let i=0;i<r.numLayers;i++)this.h.push(new Yh(t,r,s,n));this.lnF=new Jr(t,r.embedDim,n)}train(t=!0){this.training=t}eval(){this.training=!1}enableCheckpointing(t){this.checkpointingEnabled=t}forward(t){const[r,s]=t.shape,n=this.wte.forward(t),i=this.api.tensorFromArray(Array.from({length:s},(l,d)=>d),[s]),a=this.wpe.forward(i);let o=this.api.add(n,a);if(this.checkpointingEnabled&&this.training)for(let l=0;l<this.h.length;l++){const d=this.h[l];o=this.checkpointBlock(d,o)}else for(const l of this.h)o=l.forward(o);return o=this.lnF.forward(o),this.api.matmul(o,this.wte.weight.transpose({dim0:0,dim1:1}))}checkpointBlock(t,r){const s=this.h.indexOf(t),n=new Map;return n.set(r.baseId,r),this.api.saved_tensors_hooks(i=>(n.has(i.baseId)||n.set(i.baseId,i),{type:"checkpoint",blockIndex:s,inputBaseId:r.baseId}),i=>{const a=i;if(a.type==="checkpoint"){const o=n.get(a.inputBaseId);if(o)return t.forward(o)}return i},()=>t.forward(r))}forwardWithLoss(t,r){const s=this.forward(t),[n,i,a]=s.shape,o=s.reshape([n*i,a]),u=r.reshape([n*i]),l=this.crossEntropyLoss(o,u);return{logits:s,loss:l}}crossEntropyLoss(t,r){const s=t.softmax(-1),n=r.reshape([r.shape[0],1]),i=this.api.gather(s,n,{dim:1}),a=this.api.log(i),o=this.api.neg(a);return this.api.mean(o)}getLoRAParameters(){const t=[];for(const r of this.h)t.push(...r.getLoRAParameters());return t}loadBaseWeights(t){const r=t.get("wte.weight");if(r){const a=this.api.tensorFromArray(r.data,r.shape);this.wte.loadWeights(a)}const s=t.get("wpe.weight");if(s){const a=this.api.tensorFromArray(s.data,s.shape);this.wpe.loadWeights(a)}const n=t.get("ln_f.weight"),i=t.get("ln_f.bias");if(n&&i){const a=this.api.tensorFromArray(n.data,n.shape),o=this.api.tensorFromArray(i.data,i.shape);this.lnF.loadWeights(a,o)}for(let a=0;a<this.h.length;a++){const o=this.h[a],u=`h.${a}`,l=t.get(`${u}.ln_1.weight`),d=t.get(`${u}.ln_1.bias`);l&&d&&o.ln1.loadWeights(this.api.tensorFromArray(l.data,l.shape),this.api.tensorFromArray(d.data,d.shape));const c=t.get(`${u}.attn.c_attn.weight`),h=t.get(`${u}.attn.c_attn.bias`);if(c&&h){const y=this.transposeWeight(c.data,c.shape),x=this.api.tensorFromArray(y.data,y.shape),z=this.api.tensorFromArray(h.data,h.shape);o.attn.cAttn.loadBaseWeights(x,z)}const f=t.get(`${u}.attn.c_proj.weight`),w=t.get(`${u}.attn.c_proj.bias`);if(f&&w){const y=this.transposeWeight(f.data,f.shape),x=this.api.tensorFromArray(y.data,y.shape),z=this.api.tensorFromArray(w.data,w.shape);o.attn.cProj.loadWeights(x,z)}const m=t.get(`${u}.ln_2.weight`),p=t.get(`${u}.ln_2.bias`);m&&p&&o.ln2.loadWeights(this.api.tensorFromArray(m.data,m.shape),this.api.tensorFromArray(p.data,p.shape));const g=t.get(`${u}.mlp.c_fc.weight`),b=t.get(`${u}.mlp.c_fc.bias`);if(g&&b){const y=this.transposeWeight(g.data,g.shape);o.mlp.cFc.loadWeights(this.api.tensorFromArray(y.data,y.shape),this.api.tensorFromArray(b.data,b.shape))}const v=t.get(`${u}.mlp.c_proj.weight`),k=t.get(`${u}.mlp.c_proj.bias`);if(v&&k){const y=this.transposeWeight(v.data,v.shape);o.mlp.cProj.loadWeights(this.api.tensorFromArray(y.data,y.shape),this.api.tensorFromArray(k.data,k.shape))}}}transposeWeight(t,r){const[s,n]=r,i=new Float32Array(t.length);for(let a=0;a<s;a++)for(let o=0;o<n;o++)i[o*s+a]=t[a*n+o];return{data:i,shape:[n,s]}}}class Zh{encoder=new Map;decoder=new Map;bpeRanks=new Map;cache=new Map;byteEncoder=new Map;byteDecoder=new Map;eosToken=50256;vocabSize=50257;load(t,r){this.encoder=new Map(Object.entries(t));for(const[s,n]of this.encoder)this.decoder.set(n,s);for(let s=0;s<r.length;s++)this.bpeRanks.set(r[s],s);this.buildByteEncoder()}buildByteEncoder(){const t=[];for(let n=33;n<=126;n++)t.push(n);for(let n=161;n<=172;n++)t.push(n);for(let n=174;n<=255;n++)t.push(n);const r=[...t];let s=0;for(let n=0;n<256;n++)t.includes(n)||(t.push(n),r.push(256+s),s++);for(let n=0;n<t.length;n++)this.byteEncoder.set(t[n],String.fromCharCode(r[n])),this.byteDecoder.set(String.fromCharCode(r[n]),t[n])}getPairs(t){const r=new Set;for(let s=0;s<t.length-1;s++)r.add(`${t[s]} ${t[s+1]}`);return r}bpe(t){if(this.cache.has(t))return this.cache.get(t);let r=t.split("");if(r.length===0)return t;let s=this.getPairs(r);for(;s.size>0;){let i=null,a=1/0;for(const c of s){const h=this.bpeRanks.get(c);h!==void 0&&h<a&&(a=h,i=c)}if(i===null)break;const[o,u]=i.split(" "),l=[];let d=0;for(;d<r.length;){const c=r.indexOf(o,d);if(c===-1){l.push(...r.slice(d));break}l.push(...r.slice(d,c)),c<r.length-1&&r[c]===o&&r[c+1]===u?(l.push(o+u),d=c+2):(l.push(r[c]),d=c+1)}if(r=l,r.length===1)break;s=this.getPairs(r)}const n=r.join(" ");return this.cache.set(t,n),n}encode(t){const r=[],s=new TextEncoder;s.encode(t);const n=/('s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+)/gu,i=t.match(n)||[t];for(const a of i){const o=s.encode(a);let u="";for(const d of o)u+=this.byteEncoder.get(d)??String.fromCharCode(d);const l=this.bpe(u).split(" ");for(const d of l){const c=this.encoder.get(d);c!==void 0&&r.push(c)}}return r}decode(t){const r=new TextDecoder("utf-8",{fatal:!1}),s=[];for(const n of t){const i=this.decoder.get(n);if(i!==void 0)for(const a of i){const o=this.byteDecoder.get(a);o!==void 0&&s.push(o)}}return r.decode(new Uint8Array(s))}getEosToken(){return this.eosToken}}let Wt=ne(!1),er=ne(!1),Ne=ne(0),Me=ne(""),tr=ne(null),ts=ne(null),rs=ne(null),rr=ne(null),ss=ne(null),ns=ne(8),is=ne(16);async function Ti(){if(typeof navigator>"u"||!("gpu"in navigator))return!1;try{return await navigator.gpu.requestAdapter()!==null}catch{return!1}}async function Xh(){if(!(S(Wt)||S(er))){C(Wt,!0),C(tr,null),C(Ne,0),C(Me,"Checking WebGPU support...");try{if(C(ts,await Ti(),!0),!S(ts))throw new Error("WebGPU is not supported in this browser. Please use Chrome 113+ or Edge 113+.");if(C(Me,"Initializing WebGPU..."),C(Ne,5),!await oc())throw new Error(nc()||"Failed to initialize WebGPU");C(rs,new Ci("webgpu",{enableFusion:!0,enableMemoryPlanning:!0}),!0),C(Ne,10),C(Me,"Loading tokenizer...");const t=await Xu((n,i,a)=>{C(Me,a,!0)});C(ss,new Zh,!0),S(ss).load(t.vocab,t.merges),C(Ne,15),C(Me,"Downloading model weights (~500MB)...");const r=await Zu((n,i,a)=>{C(Me,a,!0),i>0&&C(Ne,15+Math.round(n/i*75))});C(Ne,90),C(Me,"Initializing model...");const s=jh(S(ns),S(is));C(rr,new Qh(S(rs),Wh,s,"webgpu"),!0),S(rr).loadBaseWeights(r),C(Ne,100),C(Me,"Ready!"),C(er,!0)}catch(e){C(tr,e instanceof Error?e.message:"Unknown error occurred",!0),C(Ne,0),C(Me,"")}finally{C(Wt,!1)}}}function Jh(){C(rr,null),C(er,!1),C(Ne,0),C(Me,""),C(tr,null)}const W={get isLoading(){return S(Wt)},get isLoaded(){return S(er)},get loadProgress(){return S(Ne)},get loadStatus(){return S(Me)},get error(){return S(tr)},get webgpuSupported(){return S(ts)},get api(){return S(rs)},get model(){return S(rr)},get tokenizer(){return S(ss)},get loraRank(){return S(ns)},get loraAlpha(){return S(is)},set loraRank(e){C(ns,e,!0)},set loraAlpha(e){C(is,e,!0)},loadModel:Xh,resetModel:Jh,checkWebGPU:Ti};let He=ne(ys([])),as=ne(50),Mt=ne(1),Dt=ne(32),os=ne(1e-4),us=ne(!0),ls=ne(!0),ft=ne(!1),Ht=ne(0),ds=ne(0),Kt=ne(ys([])),cs=ne(0),hs=ne(null),Rt=ne(null),Rr=ne(null);const Bi=Ct(()=>S(He).reduce((e,t)=>e+t.tokens,0)),Mi=Ct(()=>S(He).length>0&&!S(ft)&&W.isLoaded&&S(Bi)>=S(Mt)*(S(Dt)+1));function ep(e,t){if(!W.tokenizer)return;const r=W.tokenizer.encode(e).length;C(He,[...S(He),{name:t,content:e,tokens:r}],!0)}function tp(e){C(He,S(He).filter((t,r)=>r!==e),!0)}function rp(){C(He,[],!0)}async function sp(){if(S(Mi)&&!(!W.api||!W.model||!W.tokenizer)){C(ft,!0),C(Ht,0),C(ds,0),C(Kt,[],!0),C(cs,0),C(hs,null),C(Rt,null);try{const e=S(He).map(s=>s.content).join(`

`);C(Rr,new ju(W.api,W.model,W.tokenizer),!0);const t={maxSteps:S(as),batchSize:S(Mt),seqLength:S(Dt),learningRate:S(os),useAMP:S(us),useCheckpointing:S(ls)};await S(Rr).train(e,t,{onStepStart:s=>{C(Ht,s,!0)},onStepEnd:(s,n,i)=>{C(Ht,s+1),C(ds,n,!0),C(Kt,[...S(Kt),n],!0),C(cs,S(Mt)*S(Dt)/(i/1e3))},shouldStop:()=>!S(ft)});const r=await S(Rr).exportLoRAWeights();C(Rt,rl(r,{rank:String(W.loraRank),alpha:String(W.loraAlpha),base_model:"openai-community/gpt2",target_modules:"c_attn"}),!0)}catch(e){C(hs,e instanceof Error?e.message:"Training failed",!0)}finally{C(ft,!1)}}}function np(){C(ft,!1)}function ip(){if(!S(Rt))return;const e=new Blob([S(Rt)],{type:"application/octet-stream"}),t=URL.createObjectURL(e),r=document.createElement("a");r.href=t,r.download="gpt2-lora.safetensors",r.click(),URL.revokeObjectURL(t)}const se={get files(){return S(He)},get maxSteps(){return S(as)},get batchSize(){return S(Mt)},get seqLength(){return S(Dt)},get learningRate(){return S(os)},get useAMP(){return S(us)},get useCheckpointing(){return S(ls)},get isTraining(){return S(ft)},get currentStep(){return S(Ht)},get currentLoss(){return S(ds)},get lossHistory(){return S(Kt)},get tokensPerSecond(){return S(cs)},get trainingError(){return S(hs)},get loraWeights(){return S(Rt)},get totalTokens(){return S(Bi)},get canStartTraining(){return S(Mi)},set maxSteps(e){C(as,e,!0)},set batchSize(e){C(Mt,e,!0)},set seqLength(e){C(Dt,e,!0)},set learningRate(e){C(os,e,!0)},set useAMP(e){C(us,e,!0)},set useCheckpointing(e){C(ls,e,!0)},addTrainingData:ep,removeTrainingData:tp,clearTrainingData:rp,startTraining:sp,stopTraining:np,downloadLoRA:ip};var ap=ue('<p class="text-slate-300">Drop .txt files here or click to browse</p> <p class="text-slate-500 text-sm mt-1">Files will be used to train your LoRA</p>',1),op=ue('<p class="text-slate-500">Load the model first to add training data</p>'),up=ue('<div class="flex items-center justify-between bg-slate-700 rounded-md px-3 py-2"><div class="flex items-center gap-2"><svg class="w-4 h-4 text-slate-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"></path></svg> <span class="text-slate-200 text-sm"> </span> <span class="text-slate-500 text-xs"> </span></div> <button class="text-slate-400 hover:text-red-400 transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div>'),lp=ue('<div class="mt-4 space-y-2"></div> <div class="mt-3 flex justify-between items-center"><span class="text-slate-400 text-sm"> </span> <button class="text-sm text-slate-400 hover:text-slate-200 transition-colors">Clear all</button></div>',1),dp=ue('<div class="bg-slate-800 rounded-lg p-4"><h3 class="text-lg font-semibold text-white mb-3">Training Data</h3> <button><input type="file" accept=".txt,text/plain" multiple class="hidden"/> <svg class="w-10 h-10 mx-auto mb-3 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg> <!></button> <!></div>');function cp(e,t){bt(t,!0);let r=ne(!1),s;async function n(b){if(!(!b||!W.tokenizer)){for(const v of Array.from(b))if(v.name.endsWith(".txt")||v.type==="text/plain"){const k=await v.text();se.addTrainingData(k,v.name)}}}function i(b){b.preventDefault(),C(r,!1),n(b.dataTransfer?.files??null)}function a(b){b.preventDefault(),C(r,!0)}function o(){C(r,!1)}function u(){s?.click()}function l(b){const v=b.target;n(v.files),v.value=""}var d=dp(),c=F(I(d),2);c.__click=u;var h=I(c);h.__change=l,fn(h,b=>s=b,()=>s);var f=F(h,4);{var w=b=>{var v=ap();rt(2),Y(b,v)},m=b=>{var v=op();Y(b,v)};ce(f,b=>{W.isLoaded?b(w):b(m,!1)})}E(c);var p=F(c,2);{var g=b=>{var v=lp(),k=mt(v);gn(k,21,()=>se.files,mn,(D,B,R)=>{var L=up(),q=I(L),_=F(I(q),2),T=I(_,!0);E(_);var $=F(_,2),P=I($);E($),E(q);var j=F(q,2);j.__click=()=>se.removeTrainingData(R),E(L),ye(A=>{le(T,S(B).name),le(P,`(${A??""} tokens)`)},[()=>S(B).tokens.toLocaleString()]),Y(D,L)}),E(k);var y=F(k,2),x=I(y),z=I(x);E(x);var M=F(x,2);M.__click=()=>se.clearTrainingData(),E(y),ye(D=>le(z,`Total: ${D??""} tokens`),[()=>se.totalTokens.toLocaleString()]),Y(b,v)};ce(p,b=>{se.files.length>0&&b(g)})}E(d),ye(()=>{st(c,1,`w-full border-2 border-dashed rounded-lg p-6 text-center transition-colors cursor-pointer ${S(r)?"border-blue-500 bg-blue-500/10":"border-slate-600 hover:border-slate-500"}`),c.disabled=!W.isLoaded}),Vt("drop",c,i),Vt("dragover",c,a),Vt("dragleave",c,o),Y(e,d),vt()}_t(["click","change"]);var hp=ue('<button class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded-md text-sm font-medium transition-colors">Stop</button>'),pp=ue('<button class="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded-md text-sm font-medium transition-colors">Start Training</button>'),fp=ue('<div class="bg-slate-700 rounded-md p-3"><p class="text-slate-400 text-xs uppercase mb-2">Loss History</p> <svg class="w-full h-24" preserveAspectRatio="none"><path fill="none" stroke="#22c55e" stroke-width="2"></path></svg></div>'),mp=ue('<div class="mt-4 p-3 bg-red-900/50 rounded-md border border-red-700"><p class="text-red-400 text-sm"> </p></div>'),gp=ue('<div class="mt-4 p-3 bg-slate-700 rounded-md"><p class="text-slate-400 text-sm"><!></p></div>'),wp=ue('<div class="bg-slate-800 rounded-lg p-4"><div class="flex items-center justify-between mb-4"><h3 class="text-lg font-semibold text-white">Training Progress</h3> <!></div> <div class="mb-4"><div class="flex justify-between text-sm text-slate-400 mb-1"><span> </span> <span> </span></div> <div class="w-full bg-slate-700 rounded-full h-2"><div class="bg-green-500 h-2 rounded-full transition-all duration-300"></div></div></div> <div class="grid grid-cols-2 gap-4 mb-4"><div class="bg-slate-700 rounded-md p-3"><p class="text-slate-400 text-xs uppercase mb-1">Loss</p> <p class="text-white text-lg font-mono"> </p></div> <div class="bg-slate-700 rounded-md p-3"><p class="text-slate-400 text-xs uppercase mb-1">Tokens/sec</p> <p class="text-white text-lg font-mono"> </p></div></div> <!> <!> <!></div>');function yp(e,t){bt(t,!0);const r=300,s=100,n=Ct(()=>()=>{const $=se.lossHistory;if($.length<2)return"";const P=Math.max(...$,.1),j=Math.min(...$,0),A=P-j||1;return`M ${$.map((he,pe)=>{const we=pe/($.length-1)*r,Ee=s-(he-j)/A*s;return`${we},${Ee}`}).join(" L ")}`}),i=Ct(()=>se.maxSteps>0?se.currentStep/se.maxSteps*100:0);var a=wp(),o=I(a),u=F(I(o),2);{var l=$=>{var P=hp();P.__click=()=>se.stopTraining(),Y($,P)},d=$=>{var P=Yt(),j=mt(P);{var A=Q=>{var he=pp();he.__click=()=>se.startTraining(),Y(Q,he)};ce(j,Q=>{se.canStartTraining&&Q(A)},!0)}Y($,P)};ce(u,$=>{se.isTraining?$(l):$(d,!1)})}E(o);var c=F(o,2),h=I(c),f=I(h),w=I(f);E(f);var m=F(f,2),p=I(m);E(m),E(h);var g=F(h,2),b=I(g);E(g),E(c);var v=F(c,2),k=I(v),y=F(I(k),2),x=I(y,!0);E(y),E(k);var z=F(k,2),M=F(I(z),2),D=I(M,!0);E(M),E(z),E(v);var B=F(v,2);{var R=$=>{var P=fp(),j=F(I(P),2);gt(j,"viewBox","0 0 300 100");var A=I(j);E(j),E(P),ye(Q=>gt(A,"d",Q),[()=>S(n)()]),Y($,P)};ce(B,$=>{se.lossHistory.length>1&&$(R)})}var L=F(B,2);{var q=$=>{var P=mp(),j=I(P),A=I(j,!0);E(j),E(P),ye(()=>le(A,se.trainingError)),Y($,P)};ce(L,$=>{se.trainingError&&$(q)})}var _=F(L,2);{var T=$=>{var P=gp(),j=I(P),A=I(j);{var Q=pe=>{var we=Ve("Add training files to begin");Y(pe,we)},he=pe=>{var we=Yt(),Ee=mt(we);{var ge=_e=>{var Ce=Ve();ye(()=>le(Ce,`Need at least ${se.batchSize*(se.seqLength+1)} tokens
          (have ${se.totalTokens??""})`)),Y(_e,Ce)},ve=_e=>{var Ce=Ve("Load the model first");Y(_e,Ce)};ce(Ee,_e=>{se.totalTokens<se.batchSize*(se.seqLength+1)?_e(ge):_e(ve,!1)},!0)}Y(pe,we)};ce(A,pe=>{se.files.length===0?pe(Q):pe(he,!1)})}E(j),E(P),Y($,P)};ce(_,$=>{!se.canStartTraining&&!se.isTraining&&$(T)})}E(a),ye(($,P,j)=>{le(w,`Step ${se.currentStep??""} / ${se.maxSteps??""}`),le(p,`${$??""}%`),wn(b,`width: ${S(i)??""}%`),le(x,P),le(D,j)},[()=>S(i).toFixed(0),()=>se.currentLoss>0?se.currentLoss.toFixed(4):"",()=>se.tokensPerSecond>0?se.tokensPerSecond.toFixed(0):""]),Y(e,a),vt()}_t(["click"]);var Le=bn(()=>W),oe=bn(()=>se),bp=ue('<div class="bg-slate-800 rounded-lg p-4"><h3 class="text-lg font-semibold text-white mb-4">Training Configuration</h3> <div class="space-y-4"><div><label class="block text-sm text-slate-300 mb-1"> </label> <input type="range" min="2" max="32" step="2" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"/> <p class="text-xs text-slate-500 mt-1">Lower = smaller adapter, higher = more capacity</p></div> <div><label class="block text-sm text-slate-300 mb-1"> </label> <input type="range" min="4" max="64" step="4" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"/> <p class="text-xs text-slate-500 mt-1">Scaling factor (typically equal to rank)</p></div> <hr class="border-slate-700"/> <div><label class="block text-sm text-slate-300 mb-1"> </label> <input type="range" min="10" max="500" step="10" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"/></div> <div><label class="block text-sm text-slate-300 mb-1"> </label> <input type="range" min="1" max="4" step="1" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"/> <p class="text-xs text-slate-500 mt-1">Keep low to reduce GPU memory usage</p></div> <div><label class="block text-sm text-slate-300 mb-1"> </label> <input type="range" min="16" max="128" step="16" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"/> <p class="text-xs text-slate-500 mt-1">Shorter = less memory, longer = better context</p></div> <div><label class="block text-sm text-slate-300 mb-1"> </label> <input type="range" min="-5" max="-3" step="0.5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"/></div> <hr class="border-slate-700"/> <div class="space-y-3"><h4 class="text-sm font-medium text-slate-400">Memory Optimization</h4> <div class="flex items-center justify-between"><div><span class="text-sm text-slate-300">Mixed Precision (AMP)</span> <p class="text-xs text-slate-500">Use f16 for compute, reduces memory ~50%</p></div> <button><span></span></button></div> <div class="flex items-center justify-between"><div><span class="text-sm text-slate-300">Gradient Checkpointing</span> <p class="text-xs text-slate-500">Trade compute for memory, ~2x slower</p></div> <button><span></span></button></div></div></div></div>');function vp(e,t){bt(t,!1),ln();var r=bp(),s=F(I(r),2),n=I(s),i=I(n),a=I(i);E(i);var o=F(i,2);qe(o),rt(2),E(n);var u=F(n,2),l=I(u),d=I(l);E(l);var c=F(l,2);qe(c),rt(2),E(u);var h=F(u,4),f=I(h),w=I(f);E(f);var m=F(f,2);qe(m),E(h);var p=F(h,2),g=I(p),b=I(g);E(g);var v=F(g,2);qe(v),rt(2),E(p);var k=F(p,2),y=I(k),x=I(y);E(y);var z=F(y,2);qe(z),rt(2),E(k);var M=F(k,2),D=I(M),B=I(D);E(D);var R=F(D,2);qe(R),R.__input=A=>oe(oe().learningRate=Math.pow(10,parseFloat(A.target.value))),E(M);var L=F(M,4),q=F(I(L),2),_=F(I(q),2);_.__click=()=>oe(oe().useAMP=!oe().useAMP);var T=I(_);E(_),E(q);var $=F(q,2),P=F(I($),2);P.__click=()=>oe(oe().useCheckpointing=!oe().useCheckpointing);var j=I(P);E(P),E($),E(L),E(s),E(r),ye((A,Q)=>{le(a,`LoRA Rank: ${Le().loraRank??""}`),o.disabled=Le().isLoaded||oe().isTraining,le(d,`LoRA Alpha: ${Le().loraAlpha??""}`),c.disabled=Le().isLoaded||oe().isTraining,le(w,`Training Steps: ${oe().maxSteps??""}`),m.disabled=oe().isTraining,le(b,`Batch Size: ${oe().batchSize??""}`),v.disabled=oe().isTraining,le(x,`Sequence Length: ${oe().seqLength??""}`),z.disabled=oe().isTraining,le(B,`Learning Rate: ${A??""}`),ya(R,Q),R.disabled=oe().isTraining,st(_,1,`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${oe().useAMP?"bg-blue-600":"bg-slate-600"}`),_.disabled=oe().isTraining,st(T,1,`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${oe().useAMP?"translate-x-6":"translate-x-1"}`),st(P,1,`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${oe().useCheckpointing?"bg-blue-600":"bg-slate-600"}`),P.disabled=oe().isTraining,st(j,1,`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${oe().useCheckpointing?"translate-x-6":"translate-x-1"}`)},[()=>oe().learningRate.toExponential(0),()=>Math.log10(oe().learningRate)]),Ue(o,()=>Le().loraRank,A=>Le(Le().loraRank=A)),Ue(c,()=>Le().loraAlpha,A=>Le(Le().loraAlpha=A)),Ue(m,()=>oe().maxSteps,A=>oe(oe().maxSteps=A)),Ue(v,()=>oe().batchSize,A=>oe(oe().batchSize=A)),Ue(z,()=>oe().seqLength,A=>oe(oe().seqLength=A)),Y(e,r),vt()}_t(["input","click"]);async function*_p(e,t,r,s,n={}){const{maxNewTokens:i=100,temperature:a=.7,topK:o=50,stopSequences:u=[`

`]}=n;let l=r.encode(s);const d=t.config.blockSize;t.eval();let c="";for(let h=0;h<i;h++){const f=l.slice(-d),w=e.tensorFromArray(f,[1,f.length],{device:"webgpu"}),m=t.forward(w),p=await kp(e,m,f.length-1),g=await Sp(p,a,o),b=r.decode([g]);if(c+=b,yield b,l.push(g),u.some(v=>c.endsWith(v))||g===r.eosToken)break;await e.markStep()}}async function kp(e,t,r){const[s,n,i]=t.shape,a=await t.cpu(),o=r*i;return new Float32Array(a.slice(o,o+i))}async function Sp(e,t,r){const s=new Float32Array(e.length);for(let h=0;h<e.length;h++)s[h]=e[h]/t;const n=Math.max(...s),i=s.map(h=>Math.exp(h-n)),a=i.reduce((h,f)=>h+f,0),o=i.map(h=>h/a),u=Array.from(o).map((h,f)=>({prob:h,idx:f})).sort((h,f)=>f.prob-h.prob).slice(0,r),l=u.reduce((h,f)=>h+f.prob,0),d=u.map(h=>({...h,prob:h.prob/l}));let c=Math.random();for(const{prob:h,idx:f}of d)if(c-=h,c<=0)return f;return d[0].idx}let Pt=ne(ys([])),sr=ne(!1),tt=ne(""),nr=ne(null),ps=ne(.7),fs=ne(100),ms=ne(50);const Di=Ct(()=>W.isLoaded&&!S(sr));function gs(e,t){C(Pt,[...S(Pt),{role:e,content:t}],!0)}function xp(){C(Pt,[],!0),C(tt,""),C(nr,null)}async function Ap(e){if(!(!S(Di)||!e.trim())&&!(!W.api||!W.model||!W.tokenizer)){gs("user",e),C(sr,!0),C(tt,""),C(nr,null);try{const t=Ep(e),r={maxNewTokens:S(fs),temperature:S(ps),topK:S(ms),stopSequences:[`

User:`,`

Human:`]};for await(const s of _p(W.api,W.model,W.tokenizer,t,r))C(tt,S(tt)+s);gs("assistant",S(tt).trim()),C(tt,"")}catch(t){C(nr,t instanceof Error?t.message:"Generation failed",!0)}finally{C(sr,!1)}}}function Ep(e){let t="";const r=S(Pt).slice(-8);for(const s of r)s.role==="user"?t+=`User: ${s.content}
`:t+=`Assistant: ${s.content}
`;return t+=`User: ${e}
Assistant:`,t}const fe={get messages(){return S(Pt)},get isGenerating(){return S(sr)},get currentResponse(){return S(tt)},get chatError(){return S(nr)},get temperature(){return S(ps)},get maxTokens(){return S(fs)},get topK(){return S(ms)},get canChat(){return S(Di)},set temperature(e){C(ps,e,!0)},set maxTokens(e){C(fs,e,!0)},set topK(e){C(ms,e,!0)},addMessage:gs,clearChat:xp,sendMessage:Ap};var Ip=ue('<button class="text-sm text-slate-400 hover:text-slate-200 transition-colors">Clear</button>'),$p=ue('<div class="flex items-center justify-center h-full"><p class="text-slate-500 text-sm"><!></p></div>'),zp=ue('<div><p class="text-xs text-slate-400 mb-1"> </p> <p class="text-slate-200 text-sm whitespace-pre-wrap"> </p></div>'),Cp=ue('<div class="p-3 rounded-lg bg-slate-700 mr-8"><p class="text-xs text-slate-400 mb-1">GPT-2</p> <p class="text-slate-200 text-sm whitespace-pre-wrap"> <span class="animate-pulse"></span></p></div>'),Tp=ue("<!> <!>",1),Bp=ue('<div class="mb-4 p-2 bg-red-900/50 rounded-md border border-red-700"><p class="text-red-400 text-xs"> </p></div>'),Mp=Ri('<svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>'),Dp=ue('<div class="bg-slate-800 rounded-lg p-4 flex flex-col h-full"><div class="flex items-center justify-between mb-4"><h3 class="text-lg font-semibold text-white">Chat</h3> <!></div> <div class="grid grid-cols-3 gap-2 mb-4"><div><label class="block text-xs text-slate-400 mb-1"> </label> <input type="range" min="0.1" max="2" step="0.1" class="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"/></div> <div><label class="block text-xs text-slate-400 mb-1"> </label> <input type="range" min="10" max="200" step="10" class="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"/></div> <div><label class="block text-xs text-slate-400 mb-1"> </label> <input type="range" min="1" max="100" step="1" class="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer"/></div></div> <div class="flex-1 overflow-y-auto space-y-3 min-h-[200px] max-h-[400px] mb-4"><!></div> <!> <form class="flex gap-2"><input type="text" class="flex-1 bg-slate-700 text-white rounded-md px-3 py-2 text-sm placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"/> <button type="submit" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed"><!></button></form></div>');function Rp(e,t){bt(t,!0);let r=ne(""),s;async function n(A){if(A.preventDefault(),!S(r).trim()||!fe.canChat)return;const Q=S(r);C(r,""),await fe.sendMessage(Q),setTimeout(()=>{s?.scrollTo({top:s.scrollHeight,behavior:"smooth"})},100)}function i(A){A.key==="Enter"&&!A.shiftKey&&(A.preventDefault(),n(A))}var a=Dp(),o=I(a),u=F(I(o),2);{var l=A=>{var Q=Ip();Q.__click=()=>fe.clearChat(),Y(A,Q)};ce(u,A=>{fe.messages.length>0&&A(l)})}E(o);var d=F(o,2),c=I(d),h=I(c),f=I(h);E(h);var w=F(h,2);qe(w),E(c);var m=F(c,2),p=I(m),g=I(p);E(p);var b=F(p,2);qe(b),E(m);var v=F(m,2),k=I(v),y=I(k);E(k);var x=F(k,2);qe(x),E(v),E(d);var z=F(d,2),M=I(z);{var D=A=>{var Q=$p(),he=I(Q),pe=I(he);{var we=ge=>{var ve=Ve("Start a conversation");Y(ge,ve)},Ee=ge=>{var ve=Ve("Load the model to chat");Y(ge,ve)};ce(pe,ge=>{W.isLoaded?ge(we):ge(Ee,!1)})}E(he),E(Q),Y(A,Q)},B=A=>{var Q=Tp(),he=mt(Q);gn(he,17,()=>fe.messages,mn,(Ee,ge)=>{var ve=zp(),_e=I(ve),Ce=I(_e,!0);E(_e);var Xe=F(_e,2),Je=I(Xe,!0);E(Xe),E(ve),ye(()=>{st(ve,1,`p-3 rounded-lg ${S(ge).role==="user"?"bg-blue-900/50 ml-8":"bg-slate-700 mr-8"}`),le(Ce,S(ge).role==="user"?"You":"GPT-2"),le(Je,S(ge).content)}),Y(Ee,ve)});var pe=F(he,2);{var we=Ee=>{var ge=Cp(),ve=F(I(ge),2),_e=I(ve,!0);rt(),E(ve),E(ge),ye(()=>le(_e,fe.currentResponse)),Y(Ee,ge)};ce(pe,Ee=>{fe.isGenerating&&fe.currentResponse&&Ee(we)})}Y(A,Q)};ce(M,A=>{fe.messages.length===0?A(D):A(B,!1)})}E(z),fn(z,A=>s=A,()=>s);var R=F(z,2);{var L=A=>{var Q=Bp(),he=I(Q),pe=I(he,!0);E(he),E(Q),ye(()=>le(pe,fe.chatError)),Y(A,Q)};ce(R,A=>{fe.chatError&&A(L)})}var q=F(R,2),_=I(q);qe(_),_.__keydown=i;var T=F(_,2),$=I(T);{var P=A=>{var Q=Mp();Y(A,Q)},j=A=>{var Q=Ve("Send");Y(A,Q)};ce($,A=>{fe.isGenerating?A(P):A(j,!1)})}E(T),E(q),E(a),ye((A,Q)=>{le(f,`Temp: ${A??""}`),le(g,`Tokens: ${fe.maxTokens??""}`),le(y,`Top-K: ${fe.topK??""}`),gt(_,"placeholder",W.isLoaded?"Type a message...":"Load model to chat"),_.disabled=!fe.canChat,T.disabled=Q},[()=>fe.temperature.toFixed(1),()=>!fe.canChat||!S(r).trim()]),Ue(w,()=>fe.temperature,A=>fe.temperature=A),Ue(b,()=>fe.maxTokens,A=>fe.maxTokens=A),Ue(x,()=>fe.topK,A=>fe.topK=A),Vt("submit",q,n),Ue(_,()=>S(r),A=>C(r,A)),Y(e,a),vt()}_t(["click","keydown"]);var Pp=ue('<span class="text-xs text-green-400 bg-green-900/30 px-2 py-0.5 rounded">Cached</span>'),Fp=ue('<button class="px-3 py-1.5 text-slate-400 hover:text-slate-200 text-xs transition-colors">Clear Cache</button>'),Lp=ue('<button class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed"> </button>'),Np=ue('<div class="mt-4"><div class="flex justify-between text-sm text-slate-400 mb-1"><span> </span> <span> </span></div> <div class="w-full bg-slate-700 rounded-full h-2"><div class="bg-blue-500 h-2 rounded-full transition-all duration-300"></div></div></div>'),qp=ue('<div class="mt-3 p-3 bg-red-900/50 rounded-md border border-red-700"><p class="text-red-400 text-sm"> </p></div>'),Gp=ue('<div class="mt-3 p-3 bg-yellow-900/50 rounded-md border border-yellow-700"><p class="text-yellow-400 text-sm">WebGPU is not supported in this browser. Please use Chrome 113+, Edge 113+, or another WebGPU-enabled browser.</p></div>'),Up=ue('<div class="bg-slate-800 rounded-lg p-4 mb-6"><div class="flex items-center justify-between"><div class="flex items-center gap-3"><div></div> <span class="text-slate-200 font-medium"><!></span> <!></div> <div class="flex items-center gap-2"><!> <!></div></div> <!> <!> <!></div>');function Op(e,t){bt(t,!0);let r=ne(null);da(()=>{W.checkWebGPU(),s()});async function s(){C(r,await Us(),!0)}async function n(){await Qu(),C(r,await Us(),!0)}function i(R){return R<1024?`${R} B`:R<1024*1024?`${(R/1024).toFixed(1)} KB`:`${(R/(1024*1024)).toFixed(1)} MB`}var a=Up(),o=I(a),u=I(o),l=I(u),d=F(l,2),c=I(d);{var h=R=>{var L=Ve("Model Ready");Y(R,L)},f=R=>{var L=Yt(),q=mt(L);{var _=$=>{var P=Ve("Loading Model...");Y($,P)},T=$=>{var P=Ve("Model Not Loaded");Y($,P)};ce(q,$=>{W.isLoading?$(_):$(T,!1)},!0)}Y(R,L)};ce(c,R=>{W.isLoaded?R(h):R(f,!1)})}E(d);var w=F(d,2);{var m=R=>{var L=Pp();Y(R,L)};ce(w,R=>{S(r)?.hasWeights&&!W.isLoaded&&!W.isLoading&&R(m)})}E(u);var p=F(u,2),g=I(p);{var b=R=>{var L=Fp();L.__click=n,ye(q=>gt(L,"title",`Clear cached model (${q??""})`),[()=>i(S(r).weightsSize)]),Y(R,L)};ce(g,R=>{S(r)?.hasWeights&&!W.isLoading&&R(b)})}var v=F(g,2);{var k=R=>{var L=Lp();L.__click=()=>W.loadModel();var q=I(L,!0);E(L),ye(()=>{L.disabled=W.webgpuSupported===!1,le(q,S(r)?.hasWeights?"Load from Cache":"Download Model")}),Y(R,L)};ce(v,R=>{!W.isLoaded&&!W.isLoading&&R(k)})}E(p),E(o);var y=F(o,2);{var x=R=>{var L=Np(),q=I(L),_=I(q),T=I(_,!0);E(_);var $=F(_,2),P=I($);E($),E(q);var j=F(q,2),A=I(j);E(j),E(L),ye(()=>{le(T,W.loadStatus),le(P,`${W.loadProgress??""}%`),wn(A,`width: ${W.loadProgress??""}%`)}),Y(R,L)};ce(y,R=>{W.isLoading&&R(x)})}var z=F(y,2);{var M=R=>{var L=qp(),q=I(L),_=I(q,!0);E(q),E(L),ye(()=>le(_,W.error)),Y(R,L)};ce(z,R=>{W.error&&R(M)})}var D=F(z,2);{var B=R=>{var L=Gp();Y(R,L)};ce(D,R=>{W.webgpuSupported===!1&&R(B)})}E(a),ye(()=>st(l,1,`w-3 h-3 rounded-full ${W.isLoaded?"bg-green-500":W.isLoading?"bg-yellow-500 animate-pulse":"bg-slate-500"}`)),Y(e,a),vt()}_t(["click"]);var Vp=ue('<div class="bg-slate-800 rounded-lg p-4"><div class="flex items-center gap-3"><div class="flex-shrink-0 w-10 h-10 bg-green-600 rounded-full flex items-center justify-center"><svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg></div> <div class="flex-1"><p class="text-white font-medium">Training Complete!</p> <p class="text-slate-400 text-sm"> </p></div> <button class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-medium transition-colors flex items-center gap-2"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg> Download LoRA</button></div></div>');function jp(e,t){bt(t,!1),ln();var r=Yt(),s=mt(r);{var n=i=>{var a=Vp(),o=I(a),u=F(I(o),2),l=F(I(u),2),d=I(l);E(l),E(u);var c=F(u,2);c.__click=()=>se.downloadLoRA(),E(o),E(a),ye(h=>le(d,`Final loss: ${h??""}`),[()=>se.currentLoss.toFixed(4)]),Y(i,a)};ce(s,i=>{se.loraWeights&&i(n)})}Y(e,r),vt()}_t(["click"]);var Wp=ue('<div class="container mx-auto p-6 max-w-7xl"><header class="mb-8"><h1 class="text-4xl font-bold text-white mb-2">GPT-2 LoRA Trainer</h1> <p class="text-slate-400">Train a LoRA adapter on your text data, entirely in the browser using WebGPU</p></header> <!> <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6"><div class="space-y-6"><!> <!> <!> <!></div> <div><!></div></div> <footer class="mt-12 text-center text-slate-500 text-sm"><p>Powered by <a href="https://github.com/anthropics/torchlette" class="text-blue-400 hover:underline">Torchlette</a> - WebGPU Tensor Library</p></footer></div>');function tf(e){var t=Wp(),r=F(I(t),2);Op(r,{});var s=F(r,2),n=I(s),i=I(n);vp(i,{});var a=F(i,2);cp(a,{});var o=F(a,2);yp(o,{});var u=F(o,2);jp(u,{}),E(n);var l=F(n,2),d=I(l);Rp(d,{}),E(l),E(s),rt(2),E(t),Y(e,t)}const Hp=Object.freeze(Object.defineProperty({__proto__:null,getAllPendingTensors:Do},Symbol.toStringTag,{value:"Module"})),Kp=Object.freeze(Object.defineProperty({__proto__:null,getAllPendingTensors:gd},Symbol.toStringTag,{value:"Module"}));export{tf as _,vs as g,Ie as n};
